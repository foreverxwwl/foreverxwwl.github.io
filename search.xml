<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[IOC的作用和理解]]></title>
    <url>%2F2020%2F01%2F16%2Fspring1%2F</url>
    <content type="text"><![CDATA[程序间的耦合与解耦程序间的耦合耦合指的就是模块间关联程度的量，在软件中指对象之间的依赖性。对象之间的耦合越高，维护成本越高。因此对象的设计时就要尽量降低程序间的耦合度。在平时的开发中我们会遇到很多程序间的依赖，例如业务层调用持久层，并且此时业务层在依赖持久层的接口和实现类。如果此时没有持久层实现类，编译将不能通过。 1234public class UserServiceImpl implements UserService &#123; private UserDao userDao = new UserDaoImpl(); &#125;&#125; 工厂模式解耦我们可以使用工厂模式，用一个专门创建对象的工厂来创建指定的对象。在工厂内部创建对象时，由我们提出要创建的对象，工厂内部通过反射去控制对象的创建以及销毁，这就是控制反转。即把创建对象的权利交给框架。它包括以来注入和以来查找。 基于上述方法，我们可以编写一个创建Bean对象的工厂。通过一个工厂组件创建service和dao对象 通过一个配置文件来配置service和dao内容：唯一标识=全限定类名（key=value） 通过读取配置文件反射创建对象。通过一个map存放创建的对象。 123&gt; userService = DesignPattern.Factory.service.impl.UserServiceImpl&gt; userDao = DesignPattern.Factory.dao.daoImpl.UserDaoImpl&gt; 1234567891011121314151617181920212223242526272829303132333435363738public class BeanFactory &#123; //定义一个Properties对象 private static Properties properties; //定义一个Map。用于存放我们要创建的对象，看做容器 private static Map&lt;String, Object&gt; beans; //使用静态代码块为Properties对象复制 static &#123; try&#123; //实例化对象 properties = new Properties(); //获取properties文件流对象 InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream("DesignPattern/resources/bean.properties"); properties.load(in); //实例化容器 beans = new HashMap&lt;String, Object&gt;(); //读取配置文件 Enumeration keys = properties.keys(); //遍历取出key while (keys.hasMoreElements())&#123; //取出每个key String key = keys.nextElement().toString(); //更具key获取value String beanPath = properties.getProperty(key); //反射创建对象 Object value = Class.forName(beanPath).newInstance(); //把key和value存入容器 beans.put(key, value); &#125; &#125;catch (Exception e)&#123; throw new ExceptionInInitializerError("初始化properties对象失败"); &#125; &#125; public static Object getBean(String beanName)&#123; return beans.get(beanName); &#125;&#125;]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis缓存机制与注解开发]]></title>
    <url>%2F2020%2F01%2F05%2Fmybatis%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E4%B8%8E%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[mybatis缓存机制mybatis中的延迟加载例如在一对多查询中，当我们有一个用户，它有100个账户。那么这种情况下的查询方式应该是 在查询用户时，用户下的账户信息应该是，什么时候使用，什么时候查询的。 在查询账户时，账户的所属用户信息应该是随着账户查询时一起查询出来。则在查询用户时就要用到延迟加载。 延迟加载就是在真正使用数据时才发起查询，不用的时候不查询。按需加载（懒加载）在对应的四种表关系中：一对多，多对一，一对一，多对多 一对多，多对多：通常情况下我们都是采用延迟加载。 多对一，一对一：通常情况下我们都是采用立即加载。 延迟加载示例查询用户时，用户下的账户信息延迟加载 在原本的基础上，在主配置文件SqlMapConfig.xml中加入配置信息 123456&lt;!--配置参数--&gt; &lt;settings&gt; &lt;!--开启Mybatis支持延迟加载--&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;setting name="aggressiveLazyLoading" value="false"&gt;&lt;/setting&gt; &lt;/settings&gt; 修改表的查询方式userDao.xml 这种方式在进行findAll查询时，在查询到user对象中封装的accounts对象集合时，会通过调用select属性中编写的 AccountDao中的查询方法。来查询account，其中传入的查询约束条件就在column属性中。注意，此属性中对的内容对应数据库中user表的字段。 1234567891011121314&lt;resultMap id="userAccount" type="User"&gt; &lt;id property="id" column="id"&gt;&lt;/id&gt; &lt;result property="username" column="username"&gt;&lt;/result&gt; &lt;result property="birthday" column="birthday"&gt;&lt;/result&gt; &lt;result property="sex" column="sex" &gt;&lt;/result&gt; &lt;result property="address" column="address"&gt;&lt;/result&gt; &lt;!-- 配置user对象中accounts集合的映射 --&gt; &lt;collection property="accounts" ofType="account" select="com.dao.AccountDao.findAccountByUid" column="id"&gt;&lt;/collection&gt; &lt;/resultMap&gt; &lt;select id="findAll" resultMap="userAccount"&gt; select * from user &lt;/select&gt; account.xml中的查询方法 123&lt;select id="findAccountByUid" parameterType="java.lang.Integer" resultType="account"&gt; select * from account where uid = #&#123;uid&#125;&lt;/select&gt; 结果对比：控制台中的日志显示延迟加载以前，后续操作直接加载 123456789101112131415 ==&gt; Preparing: select * from user ==&gt; Parameters: ====&gt; Preparing: select * from account where uid = ? ====&gt; Parameters: 41(Integer) &lt;==== Total: 0 ====&gt; Preparing: select * from account where uid = ? ====&gt; Parameters: 42(Integer)&lt;==== Total: 0====&gt; Preparing: select * from account where uid = ? ====&gt; Parameters: 43(Integer) &lt;==== Total: 0 ====&gt; Preparing: select * from account where uid = ? ====&gt; Parameters: 45(Integer)&lt;==== Total: 1 ====&gt; Preparing: select * from account where uid = ? 延迟加载以后，后续的查询操作是在测试函数中，需要使用的时候才开始加载 1234567==&gt; Preparing: select * from user ==&gt; Parameters:==&gt; Preparing: select * from account where uid = ? ==&gt; Parameters: 41(Integer)&lt;== Total: 0User&#123;id=41, username=&apos;老王&apos;, birthday=Wed Feb 28 01:47:08 CST 2018, sex=&apos;男&apos;, address=&apos;北京&apos;&#125;==&gt; Preparing: select * from account where uid = ? myBatis中的缓存缓存就是存在内存中的临时数据，减少和数据库的交互次数，提高执行效率什么样的数据适合缓存 经常查询的 不经常改变的 数据的正确与否对最终结果影响不大的（有可能缓存中数据和数据库中的数据不同步） mybatis中的一级缓存 它指的是Mybatis中SqlSession对象的缓存。当我们执行查询之后，查询的结果会同时存入到SqlSession为我们提供一块区域中。该区域的结构是一个Map。当我们再次查询同样的数据，mybatis会先去sqlsession中查询是否有，有的话直接拿出来用。当SqlSession对象消失时，mybatis的一级缓存也就消失了。 一级缓存保证数据同步方法一级缓存是 SqlSession 范围的缓存，当调用 SqlSession 的修改，添加，删除，commit()，close()等方法时，就会自动清空一级缓存。 mybatis中的二级缓存 二级缓存是 mapper 映射级别的缓存，多个 SqlSession 去操作同一个 Mapper 映射的 sql 语句，多个 SqlSession 可以共用二级缓存，二级缓存是跨 SqlSession 的。 123456789101112131415public void testFirstLevelCache()&#123; SqlSession sqlSession1 = factory.openSession(); IUserDao dao1 = sqlSession1.getMapper(IUserDao.class); User user1 = dao1.findById(41); System.out.println(user1); sqlSession1.close();//一级缓存消失 SqlSession sqlSession2 = factory.openSession(); IUserDao dao2 = sqlSession2.getMapper(IUserDao.class); User user2 = dao2.findById(41); System.out.println(user2); sqlSession2.close(); System.out.println(user1 == user2); &#125; 二级缓存中存放的不是查询出来的对象，而是查询出来的数据。在后来的SqlSession需要数据是就在二级缓存中找，如果有就直接取出。然后创建对象，所以查询操作只进行一次，但是返回的对象不是同一个对象 二级缓存的打开方式 让Mybatis框架支持二级缓存（在SqlMapConfig.xml中配置） 让当前的映射文件支持二级缓存（在UserDao.xml中配置） 让当前的操作支持二级缓存（在select标签中配置）第一步加上二级缓存支持12&lt;settings&gt; &lt;!-- 开启二级缓存的支持 --&gt; &lt;setting name="cacheEnabled" value="true"/&gt; &lt;/settings&gt; 第二部直接加上标签 1&lt;!-- 开启二级缓存的支持 --&gt; &lt;cache&gt;&lt;/cache&gt; 第三部加上usecache属性 1&lt;select id="findById" resultType="user" parameterType="int" useCache="true"&gt; select * from user where id = #&#123;uid&#125; &lt;/select&gt; mybatis注解开发注解开发可以省去mapper映射的编写，增强开发效率。环境搭建步骤步骤和以前类似。在开发前要做几点准备。 12345678&lt;!--配置别名--&gt; &lt;typeAliases&gt; &lt;package name="com.domain"&gt;&lt;/package&gt; &lt;/typeAliases&gt;&lt;!-- 指定带有注解的dao接口所在位置 --&gt; &lt;mappers&gt; &lt;package name="com.dao"&gt;&lt;/package&gt; &lt;/mappers&gt; 还有一点注意就是注解开发不能有映射配置文件，否则会报错 注解开发的增删改查操作注解开发直接在dao接口中进行 123456789101112131415161718192021222324252627282930/** * 通过id查找用户 */@Select("select * from user where id = #&#123;id&#125;")public User findUserById(int id);/** * 保存用户 */@Insert("insert into user(username,address,sex) values(#&#123;username&#125;,#&#123;address&#125;,#&#123;sex&#125;)")public void saveUser(User user);/** * 修改用户 */@Update("update user set username=#&#123;username&#125;,sex=#&#123;sex&#125;,birthday=#&#123;birthday&#125;,address=#&#123;address&#125; where id=#&#123;id&#125;")public void updateUser(User user);/** * 删除用户 */@Delete("delete from user where id=#&#123;id&#125;")public void deleteUser(int id);/** * 模糊查询用户 */@Select("select * from user where username like #&#123;username&#125;")public List&lt;User&gt; findUserByUsername(String username);/** * 查询用户总量 */@Select("select count(*) from user")public int findUserTotal(); 注解开发的多表查询操作及延迟加载在注解开发的多表查询操作，和xml映射配置文件思路一样，用results注解来封装返回集在Results外层注解中：id：代表这个results映射配置，方便别的地方引用在result内注解中：id：代表主键，默认为false在配置字表属性的时候，column：代表本张表与子表相关联的字段many（one）：用于一对多时用many一对一时用one。fetchType：延时加载FetchType.LAZY，立即加载：FetchType.EAGER 1234567891011121314151617@Results(id = "userMap" ,value = &#123; @Result(id = true, column = "id",property = "id"), @Result(column = "username", property = "username"), @Result(column = "address" ,property = "address"), @Result(column = "sex", property = "sex"), @Result(column = "birthday", property = "birthday"), @Result(property = "accounts", column = "id", many = @Many(select = "com.dao.AccountDao.findAccountByUid",fetchType = FetchType.LAZY)) &#125;) /** * 根据id查询用户 * @param userId * @return */ @Select("select * from user where id=#&#123;id&#125; ") @ResultMap("userMap")//其他地方要用映射时，直接用id引用 User findById(Integer userId); 123456@Results(id = "accountMap", value = &#123; @Result(id = true, column = "id",property = "id"), @Result(column = "uid", property = "uid"), @Result(column = "money", property = "money"), @Result(property = "user", column = "uid",one = @One(select = "com.dao.UserDao.findUserById", fetchType = FetchType.EAGER)) &#125;)]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之工厂模式和代理模式]]></title>
    <url>%2F2019%2F12%2F26%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[什么是设计模式设计模式（Design Patterns）： 设计模式是一套被反复使用，多数人知晓，经过分类编目，代码设计的总结。 使用设计模式是为了可重用代码，让代码更容易理解，保证代码可靠性。 项目中合理运用设计模式可以完美的解决很多问题，每种设计模式都有相应的原理与之对应。 每个模式描述了一份在我们周围不断重复发生的问题，以及该问题解决的核心方法。 总的来说设计模式是一种代码设计的通用方法，可以帮助大家快速解决日常的业务问题。java中常见的设计模式有23种，分为创建型模式例如工厂方法模式；结构型模式例如代理模式；行为型模式例如策略模式；这三大类。在mybatis的学习中，运用多的就是 “工厂方法模式”和“代理模式” 今天就来学习一下这两种模式。 工厂方法模式工厂方法模式分为三种：普通工厂模式，多个工程方法模式，静态工厂方法模式工厂模式适合出现大量的产品需要创建,并且具有共同的接口,可以通过工厂方法模式创建: 普通工厂模式: 如果传入字符串有误,就不能创建对象 静态工厂方法模式：相对于多个工厂方法模式 ,不需要实例化工厂类 大多情况下采用静态工厂方法模式普通工厂模式建立一个工厂类 ，对实现了同一接口的一些类进行实例的创建。1234567891011121314151617181920212223242526272829303132333435363738394041//发送接口public interface Sender&#123;public void Send();&#125;//发送邮件实现类public class MailSender implements Sender&#123;@Overridepublic void Send()&#123; System.out.println("MailSender Method");&#125;&#125;//发送SMS实现类public class SmsSender implements Sender&#123; @Override public void Send()&#123; System.out.println("SmsSender Method"); &#125;&#125;//创建发送的工厂public class SendFactory&#123; public Sender produce(String type)&#123; if("mail".equals(type))&#123; return new MailSender(); &#125;else if("sms".equals(type))&#123; return new SmsSender(); &#125;else&#123; System.out.println("Please input right type!"); &#125; &#125;&#125;public class FactoryTest&#123; public static void main(String[] args)&#123; //创建一个工厂类 SendFactory factory=new SendFactory(); //调用工厂类的创建方法创建相应的发送实现类 Sender sender=factory.produce("sms"); //发送邮件 sender.Send(); &#125;&#125; 多个工厂方法模式多个工厂方法模式是对普通工厂方法模式的改进，普通工厂方法模式中,如果传递的字符串出错,则不能创建对象，多个工厂方法模式提供多个工厂方法,分别创建对象。 12345678910111213141516171819//发送工厂类public class SendFactory&#123; public Sender produceMail()&#123; return new MailSender(); &#125; public Sender produceSms()&#123; return new SmsSender(); &#125;&#125;//测试类public class FactoryTest&#123; public static void main(String[] args)&#123; SendFactory factory=new SendFactory(); Sender sender=factory.produceMail(); sender.Send(); &#125;&#125; 静态工厂方发模式将多个工厂方法模式中的方法设置为静态方法, 不需要创建实例 ,直接调用即可 12345678910111213141516171819//发送工厂类类public class SendFactory&#123; public Sender produceMail()&#123; return new MailSender(); &#125; public Sender produceSms()&#123; return new SmsSender(); &#125;&#125;//测试类public class FactoryTest&#123; public static void main(String[] args)&#123; SendFactory factory=new SendFactory(); Sender sender=factory.produceMail(); sender.Send(); &#125;&#125; 代理模式代理就像我们生活中常见的中介一样，给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。增强原对象的方法。代理模式的好处： 可以适真实角色的操作更加纯粹，不用去关心一些公共业务。 公共也就交给代理角色，实现了业务的分工。 功能业务发生扩展，方便集中管理 下面我们通过一个实例（租房业务）来说明说明一下代理现在有四种角色： 抽象角色：一般会用抽象类或者接口实现（租房的行为） 真实角色：被代理的角色（房东，要出租他的房子） 代理角色：代理真实角色，做一些增强操作（房屋中介） 客户：访问代理对象的人（要租房的人） 静态代理直接创建一个代理对象，在代理对象中创建被代理对象的实例，并进行操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * @outhor li * @create 2019-12-26 16:32 * 租房接口 */public interface Rent &#123; public void rent();&#125;/** * @outhor li * @create 2019-12-26 16:33 * 房东类 */public class Host implements Rent&#123; @Override public void rent() &#123; System.out.println("我要出租房屋"); &#125;&#125;/** * @outhor li * @create 2019-12-26 16:34 * 代理类 */public class Proxy implements Rent&#123; //被代理对象 Host host = new Host(); public Proxy() &#123; &#125; public Proxy(Host host)&#123; this.host = host; &#125; //增强被代理对象出租方法(rent) @Override public void rent() &#123; look(); host.rent(); &#125; public void look()&#123; System.out.println("带租客看房"); &#125;&#125;/** * @outhor li * @create 2019-12-26 16:43 * 租客租房类 */public class Client &#123; /** * 静态代理模式租房 */ @Test public void lease1()&#123; //想要向房东租房 Host host = new Host(); //通过代理解决 Proxy proxy = new Proxy(host); //租房 proxy.rent(); &#125;&#125; 缺点：我们得为每一个服务都得创建代理类，工作量太大，不易管理。同时接口一旦发生改变，代理类也得相应修改。 动态代理为了解决原有的缺陷，我们有了动态代理。动态代理的代理类是动态生成的不是写死的。动态代理分为两大类：基于接口的动态代理和基于类的动态代理 基于接口 ： JDK动态代理，只能通过接口来生成代理对象 基于类： cglib java字节码实现：javassist JDK动态代理Proxy类中的方法（newProxyInstance（））创建代理对象，此方法创建代理对象时第三个参数要接受InvocationHandler接口（此接口是调用处理程序实现的接口）。所以就需要重写InvocationHandler接口中的invoke方法。一般步骤： 通过Proxy的newProxyInstance方法来创建我们的代理对象，此方法有三个参数： 第一个参数 ：加载器用于定义代理类的类加载器。 第二个参数： 被代理的对象的类的接口列表实现 ，我们这里为代理对象提供的接口是真实对象所实行的接口，表示我要代理的是该真实对象，这样我就能调用这组接口中的方法了。 第三个参数： 设置调用处理程序，将方法调用分派给的代理对象， handler， 我们这里将这个代理对象关联到了 InvocationHandler 这个对象上。 创建InvocationHandler对象实现InvocationHandler接口 创建需要被代理的目标对象，就代理这个对象，使用有参构造赋值 重写InvocationHandler对象中的invoke方法，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为invoke方法的调用。此调用是底层调用。 invoke返回值就是动态代理对象，但真正的操作还是靠基本对象做 proxy参数,指代我们所代理的那个真实对象 method参数，指代的是我们所要调用真实对象的某个方法的Method对象 Object args[]参数，指代的是调用真实对象某个方法时接受的参数 在invoke方法中添加响应操作，并通过反射机制来调用invoke方法（原本的方法） method.invoke(被代理对象，args);返回代理对象 在调用处创建InvocationHandler实例，并在调用构造函数时传入被代理对象 // 我们要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的InvocationHandler handler = new ZhongJieProxy2(被代理对象); 调用Proxy的静态方法newProxyInstance创建代理，返回代理对象（接口 ）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * @outhor li * @create 2019-12-26 16:32 * 租房接口 */public interface Rent &#123; public void rent();&#125;/** * @outhor li * @create 2019-12-26 16:33 * 房东类 */public class Host implements Rent&#123; @Override public void rent() &#123; System.out.println("我要出租房屋"); &#125;&#125;/** * @outhor li * @create 2019-12-27 20:39 * 动态代理获取对象 *///2. 创建InvocationHandler对象实现InvocationHandler接口public class MyInvocationHandler implements InvocationHandler &#123; //创建被代理对象实体用于获取被代理对象 private Object object = new Object(); public MyInvocationHandler()&#123; &#125; public MyInvocationHandler(Object object)&#123; this.object = object; &#125; /*3. 重写InvocationHandler对象中的invoke方法，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为invoke方法的调用。此调用是底层调用。 - invoke返回值就是动态代理对象，但真正的操作还是靠基本对象做 - proxy参数,指代我们所代理的那个真实对象 - method参数，指代的是我们所要调用真实对象的某个方法的Method对象 - Object args[]参数，指代的是调用真实对象某个方法时接受的参数 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("带租客看房"); //4. 在invoke方法中添加响应操作，并通过反射机制来调用invoke方法（原本的方法） Object ProxyResult = method.invoke(object, args); return ProxyResult; &#125;&#125;/** * @outhor li * @create 2019-12-26 16:43 * 租客租房类 */public class Client &#123; /** * 动态代理模式租房 */ @Test public void lease2()&#123; //创建被代理对象 Rent host = new Host(); //5. 在调用处创建InvocationHandler实例，并在调用构造函数时传入被代理对象 MyInvocationHandler myInvocationHandler = new MyInvocationHandler(host); /*6. 调用Proxy的静态方法newProxyInstance创建代理，返回代理对象（接口 ）。 - 第一个参数 ：加载器用于定义代理类的类加载器。 - 第二个参数： 被代理的对象的类的接口列表实现 ，我们这里为代理对象提供的接口是**真实对象**所实行的接口，表示我要代理的是该真实对象，这样我就能调用这组**接口中的方法**了。 - 第三个参数： 设置调用处理程序，将方法调用分派给的代理对象， handler， 我们这里将这个代理对象关联到了 InvocationHandler 这个对象上。 */ Rent proxy = (Rent)Proxy.newProxyInstance(myInvocationHandler.getClass().getClassLoader(), host.getClass().getInterfaces(), myInvocationHandler); proxy.rent(); &#125;&#125; 也可以将Proxy.newProxyInstance()方法直接写在 MyInvocationHandler中，抽象为一个工具类。 123456789101112131415161718192021222324252627282930/** * @outhor li * @create 2019-12-27 20:39 * 动态代理获取对象 *///2. 创建InvocationHandler对象实现InvocationHandler接口public class MyInvocationHandler implements InvocationHandler &#123; //创建被代理对象实体用于获取被代理对象 private Object object = new Object(); public MyInvocationHandler()&#123; &#125; public MyInvocationHandler(Object object)&#123; this.object = object; &#125; public Object getProxy() &#123; //6. 调用Proxy的静态方法newProxyInstance创建代理，返回代理对象（接口）。 Object proxy = Proxy.newProxyInstance(this.getClass().getClassLoader(), object.getClass().getInterfaces(), this); return proxy; &#125; /*3. 重写InvocationHandler对象中的invoke方法，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为invoke方法的调用。此调用是底层调用。*/ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("带租客看房"); //4. 在invoke方法中添加响应操作，并通过反射机制来调用invoke方法（原本的方法） Object ProxyResult = method.invoke(object, args); return ProxyResult; &#125;&#125; cglib动态代理JDK动态代理，只能通过接口来生成代理对象，当没有接口时就不能使用，此时可以使用基于子类的动态代理。及cglib动态代理。这种代理方式，通过Enhancer类中的中的create方法创建代理对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Client &#123; public static void main(final String[] args) &#123; final Producer producer = new Producer(); /** * create方法的参数： * Class：字节码 * 它是用于指定被代理对象的字节码。 * * Callback：用于提供增强的代码 * 它是让我们写如何代理。我们一般都是些一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的。 * 此接口的实现类都是谁用谁写。 * 我们一般写的都是该接口的子接口实现类：MethodInterceptor */ Producer cglibProducer = (Producer)Enhancer.create(producer.getClass(), new MethodInterceptor() &#123; /** * @param o 代理对象的引用 * @param method 当前执行的方法 * @param objects 当前执行方法所需的参数 * @param methodProxy 当前执行方法的代理对象 * @return 被代理对象方法有相同的返回值 * @throws Throwable */ public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; //提供增强代码 Object returnValue = null; //1.获取方法参数 Float money = (Float)objects[0]; //2.判段方法是不是销售 if ("saleProduct".equals(method.getName()))&#123; returnValue = method.invoke(producer, money*0.8f); &#125; return returnValue; &#125; &#125;); cglibProducer.saleProduct(1000f); &#125;&#125;public class Producer &#123; /** * 销售 */ public void saleProduct(float money)&#123; System.out.println("销售产品，并拿到钱："+money); &#125; /** * 售后 */ public void afterService(float money)&#123; System.out.println("提供售后服务，并拿到钱："+money); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis映射文件的Sql深入]]></title>
    <url>%2F2019%2F12%2F25%2Fmybatis%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E7%9A%84Sql%E6%B7%B1%E5%85%A5%2F</url>
    <content type="text"><![CDATA[动态sql语句在有些查询过程中，例如前面案例中列表查询时，有时要加上约束条件，此时sql是动态变化的。此时我们可以用if，when，where，set，foreach。 &lt; if&gt;标签的使用我们根据实体类的不同取值，使用不同的 SQL 语句来进行查询。比如在 id 如果不为空时可以根据 id 查询， 如果 username 不同空时还要加入用户名作为条件。则可以进行组合查询。当if条件为真时，则可以将标签中的语句加入 123456789101112&lt;!-- 使用where if 语句进行条件查询--&gt; &lt; select id="findUserByCondition" resultType="user" parameterType="User" &gt; select * from user &lt; where &gt; &lt; if test="username != null" &gt; and username like #&#123;username&#125; &lt; /if &gt; &lt; if test="sex != null" &gt; and sex = #&#123;sex&#125; &lt; /if &gt; &lt;/where&gt; &lt;/select&gt; &lt; foreach&gt;标签的使用当我们需要运行 SELECT * FROM USERS WHERE username LIKE ‘%张%’ AND id IN (10,89,16) 这个sql语句时，我们需要将id中那几个值注意添加进来，则可以用list集合。封装后使用foreach标签逐一取出。collection：要遍历的集合名。 open：要加入的语句开始的内容 close：要加入的语句结束的内容item：遍历出来的元素名 separator：每个加入元素之间的分隔 1234567891011&lt;!--更具queryVo对象中 id集合来实现查询--&gt; &lt;select id="findUserByIds" resultType="user" parameterType="QueryVo"&gt; select * from user &lt;where&gt; &lt;if test="ids != null and ids.size() &gt; 0"&gt; &lt;foreach collection="ids" open="and id in (" close=")" item="uid" separator=","&gt; #&#123;uid&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; MyBatis多表查询多对一查询(一对一查询)在多对一查询中，我们常常吧多的哪一个表中其中单独一项拿出来，然后将对应关系看成一对一查询。例如在用户和账户的案例中，多个账户（account）对应一个用户（user）。这种多表查询有两种方式 ： 定义一个专门封装查询结果集的实体类，其中包含两张表的元素属性，查询结果直接封装 在主表（一对多中的多）对应的实体类中创建一个从表的对象元素。在 accountDao.xml中定义一个&lt; resultMap&gt;封装返回值。方式一 定义一个封装结果集的实体类accountUser 12345678910111213141516171819202122232425262728public class AccountUser extends Account&#123; private String username; private String address; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return super.toString() + " AccountUser&#123;" + "username='" + username + '\'' + ", address='" + address + '\'' + '&#125;'; &#125;&#125; 创建查询 1234&lt;!--方式一 直接创建result实体类 --&gt; &lt;select id="findAccountUser" resultType="AccountUser"&gt; select a.*, u.username, u.address from account a, user u where a.uid = u.id &lt;/select&gt; 方式二 在从表中创建主表对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Account &#123; //基本属性 private int id; private int uid; private double money; //主表实体类应该包含一个从表的实体类对象 //user对应account是多对一关系，所以关系中的多account，就是主表。 private User user; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getUid() &#123; return uid; &#125; public void setUid(int uid) &#123; this.uid = uid; &#125; public double getMoney() &#123; return money; &#125; public void setMoney(double money) &#123; this.money = money; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; @Override public String toString() &#123; return "Account&#123;" + "id=" + id + ", uid=" + uid + ", money=" + money + '&#125;'; &#125;&#125; 在xml中编写&lt; resultMap&gt; 12345678910111213141516&lt;!--定义封装account和user的resultMap 主类型还是account类型 应为account类型中有user类型的元素--&gt; &lt;resultMap id="accountUserMap" type="account"&gt; &lt;!--属性名property和查询结果的列名column之间的对应关系--&gt; &lt;id property="id" column="aid"&gt;&lt;/id&gt;&lt;!--主键 sql语句中起了别名为aid--&gt; &lt;result property="uid" column="uid"&gt;&lt;/result&gt; &lt;result property="money" column="money"&gt;&lt;/result&gt; &lt;!-- 一对一的关系映射 配置user的内容--&gt; &lt;association property="user" column="uid" javaType="user"&gt; &lt;id property="id" column="id" &gt;&lt;/id&gt; &lt;result property="username" column="username"&gt;&lt;/result&gt; &lt;result property="address" column="address"&gt;&lt;/result&gt; &lt;result property="sex" column="sex"&gt;&lt;/result&gt; &lt;result property="birthday" column="birthday"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; 创建查询 1234&lt;!--查询所有 方式二 使用resultMap集合 封装返回 --&gt; &lt;select id="findAll" resultMap="accountUserMap"&gt; select a.id as aid, a.uid,a.money,u.* from account a, user u where a.uid = u.id &lt;/select&gt; 一对多查询在一对多查询中，我们采用上述的第二种方法的思想，在主表中建立从表的对象集合 在主表中建立从表的对象集合 1234567private Integer id; private String username; private Date birthday; private String sex; private String address; //一对多关系映射：主表（一）应有一个从表（多）的实体类集合引用 private List&lt;Account&gt; accountList; 在UserDao.xml中配置resultMap映射关系 1234567891011121314&lt;!-- 一对多查询的关系映射--&gt; &lt;resultMap id="userAccount" type="User"&gt; &lt;id property="id" column="id"&gt;&lt;/id&gt; &lt;result property="username" column="username"&gt;&lt;/result&gt; &lt;result property="birthday" column="birthday"&gt;&lt;/result&gt; &lt;result property="sex" column="sex" &gt;&lt;/result&gt; &lt;result property="address" column="address"&gt;&lt;/result&gt; &lt;!--account集合属性的映射--&gt; &lt;collection property="accountList" ofType="account"&gt; &lt;id column="aid" property="id"&gt;&lt;/id&gt; &lt;!--设置别名--&gt; &lt;result property="uid" column="uid"&gt;&lt;/result&gt; &lt;result property="money" column="money"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; 创建查询 123&lt;select id="findUserAccount" resultMap="userAccount"&gt; select u.* ,a.id as aid, a.uid, a.money from user u left outer join account a on u.id = a.uid &lt;/select&gt; 多对多查询多对多查询思想也与上面的相同，以谁为基准查询就在谁的实体类中建立另一个实体类的集合对象，然后在编写&lt; resultMap&gt;。但是在多对多查询中，就需要sql语句涉及三张表，在查询时使用left语句来协调。 创建另一个对象的实体类 123456private int id; private String roleName; private String roleDesc; //包含一个对应user的实体类集合 private List&lt;User&gt; users; 编写&lt; resultMap&gt; 123456789101112&lt;resultMap id="roleUser" type="role"&gt; &lt;id column="rid" property="id"&gt;&lt;/id&gt; &lt;result column="ROLE_NAME" property="roleName"&gt;&lt;/result&gt; &lt;result column="ROLE_DESC" property="roleDesc"&gt;&lt;/result&gt; &lt;collection property="users" ofType="user"&gt; &lt;id property="id" column="id"&gt;&lt;/id&gt; &lt;result property="username" column="username"&gt;&lt;/result&gt; &lt;result property="birthday" column="birthday"&gt;&lt;/result&gt; &lt;result property="sex" column="sex"&gt;&lt;/result&gt; &lt;result property="address" column="address"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; 创建查询 在查询中使用left查询，将主表和中间表连接后，再使用left查询与从表连接 12345&lt;select id="findAll" resultMap="roleUser"&gt; select r.id as rid, r.role_name, r.role_desc,u.* from role r left outer join user_role ur on r.id = ur.rid left outer join user u on u.id = ur.uid&lt;/select&gt;]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis学习]]></title>
    <url>%2F2019%2F12%2F24%2Fmybatis1%2F</url>
    <content type="text"><![CDATA[mybatis环境搭建 新建一个空的maven工程 配置相应的pom文件（其中包含mybatis，mysql等） 12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;li&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 创建实体类，例如放在 com.domain **包下的一个User**类，实现Serializable接口 1234567891011121314151617181920212223242526public class User implements Serializable&#123; private Integer id; private String username; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; @Override public String toString() &#123; return "User&#123;" + "id=" + id + ", username='" + username + '\'' + ", birthday=" + birthday + ", sex='" + sex + '\'' + ", address='" + address + '\'' + '&#125;'; &#125;&#125; resources文件夹下创建mysql数据库连接的主配置文件（SQLMapConfig.xml）。其中要配置映射文件位置，映射到dao.xml的位置 123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;!-- mybatis的主配置文件 --&gt;&lt;configuration&gt; &lt;!-- 配置环境 --&gt; &lt;environments default="mysql"&gt; &lt;!-- 配置mysql的环境--&gt; &lt;environment id="mysql"&gt; &lt;!-- 配置事务的类型--&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!-- 配置数据源（连接池） --&gt; &lt;dataSource type="POOLED"&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name="driver" value="com.mysql.cj.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/myBatis?serverTimezone=UTC"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="123456"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 如果是用注解来配置的话，此处应该使用class属性指定被注解的dao全限定类名 --&gt; &lt;mappers&gt; &lt;mapper resource="com/dao/UserDao.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 创建dao接口（在包com.dao中），使用mybatis可以不用写其接口的实现类，使用工厂模式动态代理 123public interface UserDao &#123; List&lt;User&gt; findAll();&#125; 在resources文件夹下创建映射文件(UserDao.xml)，路径要对应dao接口的包的路径（com.dao 下）。同时需要添加resultType对应实体类的class文件(com.daomain.User)。namespace代表那个dao接口，id代表接口中的那个方法。 123456789&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.dao.UserDao"&gt; &lt;select id="findAll" resultType="com.domain.User"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 环境搭建完毕，编写测试类测试 12345678910111213141516171819public static void main(String[] args) throws IOException &#123; //1.读取配置文件 InputStream in = Resources.getResourceAsStream("SqlMapConfig.xml"); //2.创建SqlSessionFactory工厂 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(in); //3.使用工厂生产SqlSession对象 SqlSession session = factory.openSession(); //4.使用SQLSession创建Dao代理对象 UserDao userDao = session.getMapper(UserDao.class); //5.使用对象执行方法 List&lt;User&gt; users = userDao.findAll(); for (User user : users) &#123; System.out.println(user); &#125; //6.释放资源 session.close(); in.close(); &#125; 传递pojo包装对象开发中通过 pojo 传递查询条件 ，查询条件是综合的查询条件，不仅包括用户查询条件还包括其它的查 询条件（比如将用户购买商品信息也作为查询条件），这时可以使用包装对象传递输入参数。例如：根据用户名查询用户信息，查询条件放入QueryVo的user属性中。 编写QueryVo 1234567891011public class QueryVo &#123; private User user; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125;&#125; 编写DAO接口 1List&lt;User&gt; findUserByName(QueryVo queryVo); 编写映射文件 123&lt;select id="findUserByName" parameterType="com.domain.QueryVo" resultType="com.domain.User"&gt; select * from user where username like #&#123;user.username&#125;; &lt;/select&gt; 测试包装类作为参数 12345678910public void testFindUserByName()&#123; User user = new User(); user.setUsername("%王%"); QueryVo queryVo = new QueryVo(); queryVo.setUser(user); List&lt;User&gt; users = userDao.findUserByName(queryVo); for (User user1 : users)&#123; System.out.println(user1); &#125; &#125; 修改实体类在编写实体类时，我们做了约定，实体类中的属性名要和数据库中的列名相同，这样才可以实现自动映射。但是如果需要名称不一样时应该如何编写，下面有两种方式。 修改映射中的sql语句，使用as，别名的方式。这种方式应为是sql层面的修改，所以效率高，但是不修改麻烦 123&lt;select id="findAll" resultType="com.domain.User"&gt; select id as userId,username as userName,birthday as userBirthday, sex as userSex,address as userAddress from user &lt;/select&gt; 第二种方法是在映射文件中加入resultMap标签，建立查询的列名和实体类的属性名称不一致时建立对应关系。从而实现封装。这种方式效率低但是修改简便。12345678&lt;!-- 建立 User 实体和数据库表的对应关系，type 属性：指定实体类的全限定类名 id 属性：给定一个唯一标识，是给查询 select 标签引用用的。 --&gt; &lt;resultMap type="com.domain.User" id="userMap"&gt; &lt;id column="id" property="userId"/&gt; &lt;result column="username" property="userName"/&gt; &lt;result column="sex" property="userSex"/&gt; &lt;result column="address" property="userAddress"/&gt; &lt;result column="birthday" property="userBirthday"/&gt; &lt;/resultMap&gt; id 标签：用于指定主键字段， result 标签：用于指定非主键字段 ，column 属性：用于指定数据库列名 ，property 属性：用于指定实体类属性名称 1234&lt;!-- 配置查询所有操作 --&gt; &lt;select id="findAll" resultMap="userMap"&gt; select * from user &lt;/select&gt; properties标签的使用在数据库连接配置文件中（SqlMapConfig.xml）使用properties标签可以配置数据库连接信息。 1234567&lt;properties&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name="driver" value="com.mysql.cj.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/myBatis?serverTimezone=UTC"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="123456"/&gt; &lt;/properties&gt; 在原本配置连接信息的地方，我们就将其改为${}引用的形式 1234567&lt;dataSource type="POOLED"&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;root&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt;&lt;/dataSource&gt; 但我们一般将此配置放在config文件外面的一个单独的.properties文件在引用时，properties标签中的resource属性： 用于指定配置文件的位置，是按照类路径的写法来写，并且必须存在于类路径下。resource=”jdbcConfig.proper”或者使用url属性，但是url属性应为不灵活所以不经常使用 1234driver=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/myBatis?serverTimezone=UTCusername=rootpassword=123456 typeAliases标签和package标签的使用在编写UserDao.xml时经常会用到实体类作为参数或者返回值，但是每次都要写全限定类名，会很麻烦，所以我们可以在SQLMapConfig.xml中使用&lt; typeAliases&gt;标签来起一个别名，或者用package标签来指定包路径。 12&lt;!-- typeAlias用于配置别名。type属性指定的是实体类全限定类名。alias属性指定别名，当指定了别名就再区分大小写--&gt; &lt;typeAlias type="com.domain.User" alias="user"&gt;&lt;/typeAlias&gt; 或者用package标签 12&lt;!-- 用于指定要配置别名的包，当指定之后，该包下的实体类都会注册别名，并且类名就是别名，不再区分大小写--&gt; &lt;package name="com.domain"&gt;&lt;/package&gt; 如此编写后在xml中的全限定类名可写为 1234&lt;!--&lt;select id="findAll" resultType="com.domain.User"&gt;--&gt; &lt;select id="findAll" resultType="user"&gt; select * from user; &lt;/select&gt; SQLMapConfig.xml中配置map映射UserDao.xml也可以用package修改 12345&lt;mappers&gt;&lt;!-- &lt;mapper resource="com/dao/UserDao.xml"/&gt;--&gt; &lt;!-- package标签是用于指定dao接口所在的包,当指定了之后就不需要在写mapper以及resource或者class了 --&gt; &lt;package name="com.dao"&gt;&lt;/package&gt; &lt;/mappers&gt; 连接池的使用连接池的分类在Mybatis中数据源dataSource分为三类，分别是：UNPOOLED 不使用连接池的数据源，POOLED 使用连接池的数据源，JNDI 使用JNDI实现的数据源。相应，MyBatis内部有两个实现了UnpooledDataSource，PooledDataSource的类继承自java.sql.DataSource接口。 这两个类都实现了DataSource接口，并且PooledDataSource有一个UnpooledDataSource的引用，当PooleDataSource要创建需要创建java.sql.Connection实例对象时，还是通过UnpooledDataSource来创建，PooledDataSource只是提供一种缓存连接池机制。 连接方式通过源码分析，发现在连接时，首先在空闲连接池集合中查看有没有空闲的连接，如果没有则判断活动连接池集合中还有没有地方，如果有则创建一个连接在活动连接池中。如果还是没有，则将连接池中最老的一个连接，将其更新后使用。连接池的配置在SqlMapConfig.xml中配置连接池。12345&lt;mappers&gt;&lt;!-- &lt;mapper resource="com/dao/UserDao.xml"/&gt;--&gt; &lt;!-- package标签是用于指定dao接口所在的包,当指定了之后就不需要在写mapper以及resource或者class了 --&gt; &lt;package name="com.dao"&gt;&lt;/package&gt; &lt;/mappers&gt; MyBatis 在初始化时，根据&lt; dataSource&gt;的 type 属性来创建相应类型的的数据源 DataSource，即：type=”POOLED”：MyBatis 会创建 PooledDataSource 实例type=”UNPOOLED” ： MyBatis 会创建 UnpooledDataSource 实例type=”JNDI”：MyBatis 会从 JNDI 服务上查找 DataSource 实例，然后返回使用 mybatis事物什么是事物，四大特性ACID，不考虑隔离性会产生的3个问题以及解决方法：四种隔离级别在创建sqlSession对象的时候如果将openSession（）参数设置为true，则不用手动提交事物。 1session = factory.openSession(true);]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA查看源码小技巧]]></title>
    <url>%2F2019%2F12%2F18%2F%E6%9F%A5%E7%9C%8B%E6%BA%90%E7%A0%81%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[当我们查看源码时，往往进入一个接口后，就不知道怎么进入他的实现类了，这种情况下，我们可以进行如下操作: 首先我们要找的实现类是这个接口的那个实现类，这时，我们可以在使用这个接口的语句处打一个断点，并debug，这样就可以看到是哪个实现类了。 进入这个接口的源码 右键选择Diagram下的show Diagram… 就可以看到他的继承关系 右键点击要查看的接口，选择show Implementations就可以看到其实现类，选择需要的实现类就可。 单机要查看的实现类，在上方点击该实现类，就可进入其源码]]></content>
      <categories>
        <category>基础知识学习</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb(初级)学习总结(下篇)]]></title>
    <url>%2F2019%2F12%2F02%2FJavaWeb(%E5%88%9D%E7%BA%A7)%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%20(%E4%B8%8B)%2F</url>
    <content type="text"><![CDATA[上面从整体上说了JavaWeb的项目结构以及实现方式。这一篇主要通过几个实例，记录一下JavaWeb编程中的一些技巧及思想。 BaseServlet抽取在初步的Servlet编写中，通常一个业务逻辑会编写一个servlet，但是这样编写不利于查看，管理和重用，而且在前端访问过程中难以管理。为了解决这个问题，我们便采用一个BaseServlet来继承自HttpServlet，通过这个servlet来统一接收页面请求，并获取请求uri，通过请求路径将其分发给其他的servlet，其他servlet便继承自BaseServlet。下面的例子都是使用BaseServlet以后的实现方式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class BaseServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //完成方法分发 //1.获取请求路径 String uri = req.getRequestURI(); // /travel/user/add //System.out.println("请求uri:"+uri);// /travel/user/add //2.获取方法名称 String methodName = uri.substring(uri.lastIndexOf('/') + 1); //System.out.println("方法名称："+methodName); //3.获取方法对象Method //谁调用我？我代表谁 //System.out.println(this);//UserServlet的对象cn.itcast.travel.web.servlet.UserServlet@4903d97e try &#123; //获取方法 Method method = this.getClass().getMethod(methodName, HttpServletRequest.class, HttpServletResponse.class); //4.执行方法 method.invoke(this,req,resp); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; /** * 直接将传入的对象序列化为json，并且写回客户端 * @param obj */ public void writeValue(Object obj,HttpServletResponse response) throws IOException &#123; ObjectMapper mapper = new ObjectMapper(); response.setContentType("application/json;charset=utf-8"); mapper.writeValue(response.getOutputStream(),obj); &#125; /** * 将传入的对象序列化为json，返回 * @param obj * @return */ public String writeValueAsString(Object obj) throws JsonProcessingException &#123; ObjectMapper mapper = new ObjectMapper(); return mapper.writeValueAsString(obj); &#125;&#125; 发邮件激活问题 在用户注册时，就会有一个唯一的激活码随之生成，设置激活状态为“N”，并且发送邮件给用户，用户点击后进入激活的Servlet。 进入激活的Servlet后获取刚才生成的激活码，并调用Service通过激活码查询用户，将查询到的用户的激活状态置为“Y”。以下是具体实现Servlet123456789101112131415161718192021public void active(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.获取激活码 String code = request.getParameter("code"); if(code != null)&#123; //2.调用service完成激活 //UserService service = new UserServiceImpl(); boolean flag = service.active(code); //3.判断标记 String msg = null; if(flag)&#123; //激活成功 msg = "激活成功，请&lt;a href='login.html'&gt;登录&lt;/a&gt;"; &#125;else&#123; //激活失败 msg = "激活失败，请联系管理员!"; &#125; response.setContentType("text/html;charset=utf-8"); response.getWriter().write(msg); &#125; &#125; Service层12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 注册用户 * @param user 注册用户信息 * @return 是否注册成功 */ @Override public boolean regist(User user) &#123; //通过用户名查询用户 User byUsername = userDao.findByUsername(user.getUsername()); //如果用户已存在 if (byUsername != null)&#123; //返回失败 return false; &#125; //保存用户信息 //1.设置激活码对应唯一用户 user.setCode(UuidUtil.getUuid()); //2.设置激活状态 user.setStatus("N"); userDao.save(user); //发送激活邮件 String content="&lt;a href='http://localhost/travel/user/active?code="+user.getCode()+"'&gt;点击激活【黑马旅游网】&lt;/a&gt;"; MailUtils.sendMail(user.getEmail(),content,"激活邮件"); return true; &#125; /** * 激活用户 * @param code 激活码 * @return 激活状态 */ @Override public boolean active(String code) &#123; //通过激活码查询用户 User user = userDao.findBycode(code); if (user == null)&#123; return false; &#125; userDao.active(user); return true; &#125; Dao层12345678910111213141516171819202122232425/** * 通过激活码查找用户 * @param code 激活码 * @return 找到的用户 */@Overridepublic User findBycode(String code) &#123; User user = null; try &#123; String sql = "select * from tab_user where code = ?"; user = template.queryForObject(sql, new BeanPropertyRowMapper&lt;User&gt;(User.class), code); &#125;catch (Exception e)&#123; &#125; return user;&#125;/** * 修改用户激活状态 * @param user 待修改用户 */@Overridepublic void active(User user) &#123; String sql = "update tab_user set status = 'Y' where code=?"; template.update(sql,user.getCode());&#125; 分页显示功能 从客户端获取到当前页码、每页显示条数、以及当前页面分类 处理获取到的参数，将其转为适当类型，没有输入则将获取到的字符串“null”变为null。并调用Service 在Service中通过页面分类id调dao查出总记录数 通过当前页码数以及每页显示条数算出本页起始记录数 = (currentPage - 1) * pageSize 调用dao查到本页要展示的记录信息 计算总页数=totalCount % pageSize == 0? totalCount / pageSize :(totalCount / pageSize) + 1 封装分页的JavaBean类PageBean并返回 PageBean1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class PageBean&lt;T&gt; &#123; private int totalCount;//总记录数 private int totalPage;//总页数 private int currentPage;//当前页码 private int pageSize;//每页显示条数 private List&lt;T&gt; list;//每页显示的数据集合 public int getTotalCount() &#123; return totalCount; &#125; public void setTotalCount(int totalCount) &#123; this.totalCount = totalCount; &#125; public int getTotalPage() &#123; return totalPage; &#125; public void setTotalPage(int totalPage) &#123; this.totalPage = totalPage; &#125; public int getCurrentPage() &#123; return currentPage; &#125; public void setCurrentPage(int currentPage) &#123; this.currentPage = currentPage; &#125; public int getPageSize() &#123; return pageSize; &#125; public void setPageSize(int pageSize) &#123; this.pageSize = pageSize; &#125; public List&lt;T&gt; getList() &#123; return list; &#125; public void setList(List&lt;T&gt; list) &#123; this.list = list; &#125;&#125; servlet12345678910111213141516171819202122232425262728293031323334public void pageQuery(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.接受参数 String currentPageStr = request.getParameter("currentPage"); String pageSizeStr = request.getParameter("pageSize"); String cidstr = request.getParameter("cid"); String rname = request.getParameter("rname"); //解决git请求中文乱码问题 rname = new String(rname.getBytes("iso-8859-1"), "utf-8"); if ("null".equals(rname))&#123; rname = null; &#125; //2.处理参数 int cid = 0; if (cidstr != null &amp;&amp; cidstr.length() &gt; 0 &amp;&amp; !"null".equals(cidstr))&#123; cid = Integer.parseInt(cidstr); &#125; int currentPage = 0;//当前页码默认为第一页 if (currentPageStr != null &amp;&amp; currentPageStr.length() &gt; 0)&#123; currentPage = Integer.parseInt(currentPageStr); &#125;else &#123; currentPage = 1; &#125; //页面大小、默认为5 int pageSize = 0; if (pageSizeStr != null &amp;&amp; pageSizeStr.length() &gt; 0)&#123; pageSize = Integer.parseInt(pageSizeStr); &#125;else &#123; pageSize = 5; &#125; //3.调动service查询 PageBean&lt;Route&gt; pb = routeService.pageQuery(cid, currentPage, pageSize, rname); //4.序列化为Json返回 writeValue(pb, response); &#125; service1234567891011121314151617181920public PageBean&lt;Route&gt; pageQuery(int cid, int currentPage, int pageSize, String rname) &#123; PageBean&lt;Route&gt; pb = new PageBean&lt;Route&gt;(); //1.封装pageBean //设置页码 pb.setCurrentPage(currentPage); //设置每页显示条数 pb.setPageSize(pageSize); //设置总记录数 int totalCount = routeDao.findTotalCount(cid, rname); pb.setTotalCount(totalCount); //设置当前显示的数据集合 int start = (currentPage - 1) * pageSize;//开始的记录数 List&lt;Route&gt; list = routeDao.findByPage(cid, start, pageSize, rname); pb.setList(list); //设置总页数 int totalPage = totalCount % pageSize == 0? totalCount / pageSize :(totalCount / pageSize) + 1; pb.setTotalPage(totalPage); return pb; &#125; dao12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 查询cid总记录数 * @param cid * @return */ @Override public int findTotalCount(int cid, String rname) &#123; //String sql = "select count(*) from tab_route where cid = ?"; //1.定义sql模板 String sql = "select count(*) from tab_route where 1=1 "; StringBuilder sb = new StringBuilder(sql); List params = new ArrayList();//条件们 //2.判断参数是否有值 if(cid != 0)&#123; sb.append( " and cid = ? "); params.add(cid);//添加？对应的值 &#125; if(rname != null &amp;&amp; rname.length() &gt; 0)&#123; sb.append(" and rname like ? "); params.add("%"+rname+"%"); &#125; sql = sb.toString(); return template.queryForObject(sql, Integer.class, params.toArray()); &#125; /** * 根据cid，start，pageSize查询当前的页数集合 * @param cid * @param start * @param pageSize * @return */ @Override public List&lt;Route&gt; findByPage(int cid, int start, int pageSize, String rname) &#123; //String sql = "select * from tab_route where cid = ? limit ? , ?"; String sql = " select * from tab_route where 1 = 1 "; //1.定义sql模板 StringBuilder sb = new StringBuilder(sql); List params = new ArrayList();//条件们 //2.判断参数是否有值 if(cid != 0)&#123; sb.append( " and cid = ? "); params.add(cid);//添加？对应的值 &#125; if(rname != null &amp;&amp; rname.length() &gt; 0)&#123; sb.append(" and rname like ? "); params.add("%"+rname+"%"); &#125; sb.append(" limit ? , ? ");//分页条件 sql = sb.toString(); params.add(start); params.add(pageSize); return template.query(sql,new BeanPropertyRowMapper&lt;Route&gt;(Route.class),params.toArray()); &#125; 缓存优化对于一些要多次加载，且一次加载后不会有变动的数据，我们通常使用redis优化。例如分类的数据在每一次页面加载后都会重新请求数据库来加载，对数据库的压力比较大，而且分类的数据不会经常产生变化，所以可以使用redis来缓存这个数据。 service1234567891011121314151617181920212223242526272829303132333435/** * 查询所有,使用Redis缓存优化 * @return */ public List&lt;Category&gt; findAll() &#123; //1.查询Redis数据库 //获取jedis数据库 Jedis jedis = JedisUtil.getJedis(); //可使用sortedset排序查询 //Set&lt;String&gt; categorys = jedis.zrange("category", 0, -1); //1.3查询sortedset中的分数(cid)和值(cname) Set&lt;Tuple&gt; categorys = jedis.zrangeWithScores("category", 0, -1); List&lt;Category&gt; cs = null; if (categorys.size() == 0 || categorys == null)&#123; //2.如果没有查到，那么查询数据库 cs = categoryDao.findAll(); //将查询结果保存 for (int i = 0; i &lt; cs.size(); i++) &#123; jedis.zadd("category", cs.get(i).getCid(), cs.get(i).getCname()); &#125; &#125;else &#123; //3.如果查到了，那么将查到的Set集合categorys存入List集合cs cs = new ArrayList&lt;Category&gt;(); for (Tuple tuple : categorys) &#123; //封装一个分类集合 Category category = new Category(); category.setCname(tuple.getElement()); category.setCid((int)tuple.getScore()); //将集合放入cs中 cs.add(category); &#125; &#125; return cs; &#125;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb(初级)学习总结(上篇)]]></title>
    <url>%2F2019%2F11%2F29%2FJavaWeb(%E5%88%9D%E7%BA%A7)%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93(%E4%B8%8A)%2F</url>
    <content type="text"><![CDATA[初级阶段JavaWeb的学习已经持续了一个多月，第一次接触服务端的代码编程，不同的思想以及实现方式，加上各种各样的bug使得一开始的学习变得极为困难。现在要结束javaWeb学习时，对近一个阶段的学习做一个总结。 一、一般JavaWeb项目的目录结构使用maven管理的JavaWeb项目，目录分为 src 项目源码 main 主代码 java java代码resources 配置文件webapp 页面文件 pom.xml maven项目配置文件target 二、java服务端代码的结构以及问题解决模式java服务端代码一般有web，service，dao，domain，util，web下又有servlet，filter等。以下是详细内容。 1. servletweb中放的一般是servlet,filter和listener。其中servlet可实现后台逻辑的编写，继承自HttpServlet可以直接处理页面的请求，并响应。获取页面数据，并且将数据存入session中。 注册功能解决模式创建返回前端数据的javaBean(resultInfo)内容包括： 123private boolean flag;//后端返回结果正常为true，发生异常返回falseprivate Object data;//后端返回结果数据对象private String errorMsg;//发生异常的错误消息 创建封装用户信息的javaBean(User)内容包括： 12345678910private int uid;//用户idprivate String username;//用户名，账号private String password;//密码private String name;//真实姓名private String birthday;//出生日期private String sex;//男或女private String telephone;//手机号private String email;//邮箱private String status;//激活状态，Y代表激活，N代表未激活private String code;//激活码（要求唯一） 获取页面注册数据（request.getParameter();) 封装user对象 从session中获取验证码（request.getSession.getAttribute();) 将页面获取的验证码和session中的比较，如果错误则跳转错误页面并将错误信息存入返回前端的数据对象(ResultInfo)中。 调用service查询，判断返回结果，封装resultInfo对象 将resultInfo对象序列化为json 将json数据写会客户端 1234567//将info对象序列化为jsonObjectMapper mapper = new ObjectMapper();String json = mapper.writeValueAsString(info);//将json数据写回客户端//设置content-typeresponse.setContentType("application/json;charset=utf-8");response.getWriter().write(json); 2. filter和listenerfilter可以一次性解决页面编码问题，不用在每个servlet中都处理一次页面的编码问题。filter还可以解决页面过滤问题，例如用户没有登录时不能访问其他页面。 解决页面编码问题1234567891011121314151617181920212223242526//页面编码问题@WebFilter("/*")public class CharchaterFilter implements Filter &#123; @Override public void destroy() &#123; &#125; @Override public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123; //将父接口转为子接口 HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) resp; //获取请求方法 String method = request.getMethod(); //解决post请求中文数据乱码问题 if(method.equalsIgnoreCase("post"))&#123; request.setCharacterEncoding("utf-8"); &#125; //处理响应乱码 response.setContentType("text/html;charset=utf-8"); chain.doFilter(request,response); &#125; @Override public void init(FilterConfig config) throws ServletException &#123; &#125;&#125; 未登录不能浏览问题1234567891011121314151617181920212223242526272829@WebFilter("/*")public class LoginFilter implements Filter &#123; public void destroy() &#123; &#125; public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123; //强制转化 HttpServletRequest request = (HttpServletRequest) req; //1.获取资源请求路径 String uri = request.getRequestURI(); //2.设置放行路径，要将css，js，图片，验证码等资源也放行 if (uri.contains("/Login.jsp") || uri.contains("/loginServlet") || uri.contains("/verifyCodeServlet") || uri.contains("/verificationCode/") || uri.contains("/css/") || uri.contains("/js/") ||uri.contains("/fonts/"))&#123; chain.doFilter(req, resp); &#125;else &#123; Object user = request.getSession().getAttribute("user"); //如果不包含，则验证是否登录 if (user != null)&#123; //有登录信息，放行 chain.doFilter(req, resp); &#125;else &#123; //跳转登录页面 request.setAttribute("Login_msg","没有登录，请先登录"); request.getRequestDispatcher("/Login.jsp").forward(request,resp); &#125; &#125; &#125; public void init(FilterConfig config) throws ServletException &#123; &#125;&#125; 3. service层service层是服务层，可以封装一个完整的服务流程，封装多个数据库查询逻辑。在我们编写service层的时候，通常将接口与实现类分离。这样做的好处有以下三种 在java中接口是多继承的，而类是单继承的，如果你需要一个类实现多个service，你用接口可以实现，用类定义service就没那么灵活 要提供不同的数据库的服务时，我们只需要面对接口用不同的类实现即可，而不用重复地定义类 编程规范问题，接口化的编程为的就是将实现封装起来，然调用者只关心接口不关心实现，也就是“高内聚，低耦合”的思想。查看路线详细信息因为路线详细信息显示，涉及到了对于三数据库表的查询（路线信息表，路线图片表，商家信息表），则可以通过一个service封装起来，servlet调用时只需输入路线的id就可查询出所有信息。 1234567891011121314151617 private RouteDao routeDao = new RouteDaoImpl(); private RouteImgDao routeImgDao = new RouteImgDaoImpl(); private SellerDao sellerDao = new SellerDaoImpl(); public Route findOne(String rid) &#123; //1.更具id去route表查询route对象 Route route = routeDao.findOne(Integer.parseInt(rid)); //2.更具route的id查询图片集合信息 List&lt;RouteImg&gt; routeImgs = routeImgDao.findByRid(route.getRid()); route.setRouteImgList(routeImgs); //3.更具route的sid（商家id）查询商家对象 Seller seller = sellerDao.findByid(route.getSid()); route.setSeller(seller); //4.查询收藏次数 int count = favoriteDao.findCountByRid(route.getRid()); route.setCount(count); return route;&#125; 4. dao层dao层为数据库访问层，每一个方法都具体到对一张数据库表的操作。是最底层。 多条件查询的sql模板建立在查询数据库时，常会遇到多条件查询数据库，但是有些条件在有些情况下不用添加，但是如何编写sql语句就成了问题。这时我们可以定义sql模板，通过字符串拼接的方式来实现扩展sql语句的功能。例如在下面的例子中，在有些情况下想要添加模糊查询，有些情况下要加上分页条件。 1234567891011121314151617181920212223242526272829public List&lt;Route&gt; findByPage(int cid, int start, int pageSize, String rname) &#123; //String sql = "select * from tab_route where cid = ? limit ? , ?"; String sql = " select * from tab_route where 1 = 1 "; //1.定义sql模板 StringBuilder sb = new StringBuilder(sql); List params = new ArrayList();//条件们 //2.判断参数是否有值 if(cid != 0)&#123; sb.append( " and cid = ? "); params.add(cid);//添加？对应的值 &#125; if(rname != null &amp;&amp; rname.length() &gt; 0)&#123; sb.append(" and rname like ? "); params.add("%"+rname+"%"); &#125; sb.append(" limit ? , ? ");//分页条件 sql = sb.toString(); params.add(start); params.add(pageSize); return template.query(sql,new BeanPropertyRowMapper&lt;Route&gt;(Route.class),params.toArray());&#125; domain层这一层主要是各类JavaBean，在javaBean的 例如有用于分页显示的JavaBean，其中封装了总的记录数，页数，页码，每页条数等，可以实现一个分页逻辑的数据需求。 123456789101112131415161718192021222324252627282930313233343536373839404142434445private int totalCount;//总记录数 private int totalPage;//总页数 private int currentPage;//当前页码 private int pageSize;//每页显示条数 private List&lt;T&gt; list;//每页显示的数据集合 public int getTotalCount() &#123; return totalCount; &#125; public void setTotalCount(int totalCount) &#123; this.totalCount = totalCount; &#125; public int getTotalPage() &#123; return totalPage; &#125; public void setTotalPage(int totalPage) &#123; this.totalPage = totalPage; &#125; public int getCurrentPage() &#123; return currentPage; &#125; public void setCurrentPage(int currentPage) &#123; this.currentPage = currentPage; &#125; public int getPageSize() &#123; return pageSize; &#125; public void setPageSize(int pageSize) &#123; this.pageSize = pageSize; &#125; public List&lt;T&gt; getList() &#123; return list; &#125; public void setList(List&lt;T&gt; list) &#123; this.list = list; &#125;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb练习中出现的问题及解决]]></title>
    <url>%2F2019%2F11%2F20%2FjavaWeb%E7%BB%83%E4%B9%A0%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[数据库连接问题连接MySQL最开始连接MySQL时就出现了问题，应为我下载的版本为最新版本MySQL（8.0）对应的mysql-connector jar包也就是最新的8.0.17版本。此时连接数据库加载驱动时写法和以前版本不同，应该是：中间要加上cj 1com.mysql.cj.jdbc.Driver 且在配置URL时要书写完整如下 1jdbc:mysql://localhost:3306/travel?characterEncoding=utf-8&amp;serverTimezone=UTC 否则会报错如下 1The server time zone value &apos;�й���׼ʱ��&apos; is unrecognized or represents more than one time zone. 配置druid连接池在配置druid时出现了两个问题。 在编写druid.properties配置文件时，应将配置信息书写完整并遵循上述方法 12345678910111213141516driverClassName=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/travel?characterEncoding=utf-8&amp;serverTimezone=UTCusername=rootpassword=123456filters=statinitialSize=5maxActive=300maxWait=60000timeBetweenEvictionRunsMillis=60000minEvictableIdleTimeMillis=300000validationQuery=SELECT 1testWhileIdle=truetestOnBorrow=falsetestOnReturn=falsepoolPreparedStatements=falsemaxPoolPreparedStatementPerConnectionSize=200 在连接数据库加载配置文件时JdbcUtils中使用getClassLoader()时应该注意按照如下方式编写 123InputStream is = new FileInputStream(JDBCUtils.class.getResource("/").getPath() + "/druid.properties");Properties pp = new Properties();pp.load(is); 不能直接写成 1InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream("/druid.properties"); 这种情况加载不出配置文件，会报错获取不到connection连接如下 12for servlet [cn.itcast.travel.web.servlet.RegistUserServlet] in context with path [/travel] threw exceptionjava.lang.IllegalArgumentException: Property &apos;dataSource&apos; is required 上面错误的写法，在我最开始写简单servlet项目的时候，在本地测试是可以通过的，并且可以操作数据库。但是一旦运行在tomcat服务器上就会报错。只有修改过后才可。 数据库链接jar包和数据库匹配问题在本次实践中还出现了一个比较低级的错误。在写maven项目的pom.xml文件时直接照搬了教程中的配置信息，就导致项目加载的本地依赖中的MySQL-connector包与数据库版本不匹配。报错如下 12com.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException: Could not create connection to database server.Caused by: java.lang.NullPointerException maven项目问题maven本地依赖问题接上文问题，在发现版本不一致后，就需要加载高版本的连接驱动。但是maven的本地依赖中没有相应的jar包就需要下载。但是通过IDEA下载很慢。一般解决方法如下： 在Maven根目录下有个Conf的目录，下面有一个settings.xml配置文件，打开并在mirrors配置节中加入如下配置：12345678910111213141516171819202122232425&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;repo1&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo1.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;!-- 中央仓库2 --&gt; &lt;mirror&gt; &lt;id&gt;repo2&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo2.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; 如此将其改成阿里云的maven仓库配置。 查找我们需要的依赖包dependency。到 https://mvnrepository.com/ 搜索可以得到&lt; dependency&gt;查关配置，并粘贴入pom.xml文件。 先搜索需要的依赖选择合适的版本复制内容到pom文件 在cmd中进入pom.xml文件所在位置，运行 call mvn -f pom.xml dependency:copy-dependencies 。在本地仓库就可以看到依赖包下载下来了。 代码编写问题使用BaseServlet抽取时发生的小问题为了使得代码的复杂度降低便于阅读，我们通常会创建一个BaseServlet继承自（HttpServlet）来完成请求的分发。但是要注意的是其servlet中一定要继承自BaseServlet否则会报错 接收json数据时对null处理在后端响应json数据时，有些数据是null，但是在后端接收解析以后会把他当成一个字符串”null“来处理，从而使得查询数据库时会出现错误查询不到，或者将其由String类型转为int类型时会抛出异常。所以应注意此类问题。 123456if ("null".equals(rname))&#123; rname = null;&#125;if (cidstr != null &amp;&amp; cidstr.length() &gt; 0 &amp;&amp; !"null".equals(cidstr))&#123; cid = Integer.parseInt(cidstr);&#125; get请求中有中文是乱码问题在有搜索需求时，请求汇总势必会有中文，但是会有编码（%E4%B8%8B%E8%BD%BD%E4%BE%9D），如果不处理会导致数据库查询出问题，结局方案如下，如解决rname的编码问题 1rname = new String(rname.getBytes("iso-8859-1"), "utf-8");]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程基础]]></title>
    <url>%2F2019%2F11%2F15%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B1%2F</url>
    <content type="text"><![CDATA[多线程基本概念并发与并行并发：同一时间段内两任务交替执行并行：同一时间段内两任务同时执行 进程与线程 进程是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。 线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 一个程序运行后至少有一个进程，一个进程中可以包含多个线程 线程调度 分时调度：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。 抢占式调度：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。 实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。 多线程代码实现多线程实现(方式1)Java使用java.lang.Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。一般创建步骤如下: 定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。 创建Thread子类的实例，即创建了线程对象 调用线程对象的start()方法来启动该线程 主类： 123456789101112public class Main &#123; //定义线程对象 MyThread myThread = new MyThread("新线程"); //执行线程 myThread.start(); new MyThread("新线程2").start(); //定义主线程 for (int i = 0; i &lt; 5; i++) &#123; System.out.println(Thread.currentThread().getName()+i); &#125; &#125;&#125; 自定义线程类： 1234567891011121314151617181920public class MyThread extends Thread &#123; //定义线程名称的构造方法 public MyThread(String name)&#123; super(name); &#125; //重写父类的run方法，实现线程逻辑 @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; //使用Thread类的sleep方法让程序睡眠1秒钟 try &#123; Thread.sleep(1000); System.out.println(Thread.currentThread().getName()+"：正在执行！"+i); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 结果： 123456789101112131415main0main1main2main3main4新线程2：正在执行！0新线程1：正在执行！0新线程2：正在执行！1新线程1：正在执行！1新线程2：正在执行！2新线程1：正在执行！2新线程2：正在执行！3新线程1：正在执行！3新线程2：正在执行！4新线程1：正在执行！4 线程的名称 默认情况下主线程: main。新线程: Thread-0,Thread-1,Thread-2 获取线程的名称 使用Thread类中的方法getName() 返回线程名称 可以先获取到当前正在执行的线程,使用线程中的方法getName()获取线程的名称。 static Thread currentThread() 返回对当前正在执行的线程对象的引用。 Thread.currentThread().getName() 获取方式（最常用方式） 设置线程的名称 使用Thread类中的方法setName(名字) void setName(String name) 改变线程名称，使之与参数 name 相同。 创建一个带参数的构造方法,参数传递线程的名称;调用父类的带参构造方法,把线程名称传递给父类,让父类(Thread)给子线程起一个名字 Thread(String name) 分配新的 Thread 对象。 线程睡眠public static void sleep(long millis):使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。毫秒数结束之后,线程继续执行 多线程原理程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。在执行到new MyThread(&quot;新线程&quot;).start();时随着调用MyThread的对象的 start方法，另外一个新的线程也启动了，这样，整个应用就在多线程下运行。每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈。再生成新的线程时也就是生成了新的栈空间。 Thread类常用方法public String getName() :获取当前线程名称。public void start() :导致此线程开始执行; Java虚拟机调用此线程的run方法。public void run() :此线程要执行的任务在此处定义代码。public static void sleep(long millis) :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。public static Thread currentThread() :返回对当前正在执行的线程对象的引用。 多线程实现(方式2)创建多线程程序的第二种方式:实现java.lang.Runnable接口。Runnable 接口应该由那些打算通过某一线程执行其实例的类来实现。类必须定义一个称为 run 的无参数方法。java.lang.Thread类的构造方法 Thread(Runnable target) 分配新的 Thread 对象。 Thread(Runnable target, String name) 分配新的 Thread 对象。实现步骤: 创建一个Runnable接口的实现类 在实现类中重写Runnable接口的run方法,设置线程任务 创建一个Runnable接口的实现类对象 创建Thread类对象,构造方法中传递Runnable接口的实现类对象 调用Thread类中的start方法,开启新的线程执行run方法 实现Runnable接口创建多线程程序的好处: 避免了单继承的局限性。 一个类只能继承一个类(一个人只能有一个亲爹),类继承了Thread类就不能继承其他的类。实现了Runnable接口,还可以继承其他的类,实现其他的接口。 增强了程序的扩展性,降低了程序的耦合性(解耦)。实现Runnable接口的方式,把设置线程任务和开启新线程进行了分离(解耦)。 实现类中,重写了run方法:用来设置线程任务。创建Thread类对象,调用start方法:用来开启新线程主类：1234567891011121314public class Main &#123; public static void main(String[] args) &#123; //3.创建一个Runnable接口的实现类对象 RunnableImpl run = new RunnableImpl(); //4.创建Thread类对象,构造方法中传递Runnable接口的实现类对象 Thread t = new Thread(run);//打印线程名称 //5.调用Thread类中的start方法,开启新的线程执行run方法 t.start(); for (int i = 0; i &lt;20 ; i++) &#123; System.out.println(Thread.currentThread().getName()+"--&gt;"+i); &#125; &#125;&#125; 线程类： 12345678910//1.创建一个Runnable接口的实现类public class RunnableImpl implements Runnable&#123; //2.在实现类中重写Runnable接口的run方法,设置线程任务 @Override public void run() &#123; for (int i = 0; i &lt;20 ; i++) &#123; System.out.println(Thread.currentThread().getName()+"--&gt;"+i); &#125; &#125;&#125; runnable实现原理通过实现Runnable接口，使得该类有了多线程类的特征。run()方法是多线程程序的一个执行目标。所有的多线程代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。 在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread 对象的start()方法来运行多线程代码。 Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。 而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法。 Runnable和Thread的区别如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。实现Runnable接口比继承Thread类所具有的优势： 适合多个相同的程序代码的线程去共享同一个资源。 可以避免java中的单继承的局限性。 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。 线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。 匿名内部类方式创建线程使用匿名内部类的方式实现Runnable接口，重新Runnable接口中的run方法：匿名内部类作用:简化代码 把子类继承父类,重写父类的方法,创建子类对象合一步完成 把实现类实现类接口,重写接口中的方法,创建实现类对象合成一步完成 匿名内部类的最终产物:子类/实现类对象,而这个类没有名字123456789101112131415161718192021222324public class Main &#123; public static void main(String[] args) &#123; //第一种方式 继承Thread类 new Thread()&#123; @Override public void run()&#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(Thread.currentThread().getName() + i); &#125; &#125; &#125;.start(); //第二种方式，实现Runnable接口 new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(Thread.currentThread().getName() + i); &#125; &#125; &#125;).start(); &#125;&#125; 线程安全出现原因如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样 的，而且其他的变量的值也和预期的是一样的，就是线程安全的。但是如果同时访问操作同一个数据，就有可能造成线程不安全。 线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写 操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步， 否则的话就可能影响线程安全。 例如：电影院要卖票，我们模拟电影院的卖票过程。假设要播放的电影是 “战狼”，本次电影的座位共100个 (本场电影只能卖100张票)。 我们来模拟电影院的售票窗口，实现多个窗口同时卖 “战狼”这场电影票(多个窗口一起卖这100张票) 需要窗口，采用线程对象来模拟；RunnableImpl类 1234567891011121314151617181920public class RunnableImpl implements Runnable&#123; public int ticket = 10; @Override public void run() &#123; //循环买票 while(true)&#123; if (ticket &gt; 0)&#123; //程序睡眠 买票操作时间 try &#123; Thread.sleep(10); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+ "正在卖第" + ticket-- + "张票"); &#125;else &#123; break; &#125; &#125; &#125;&#125; 主类 12345678910public class Main &#123; public static void main(String[] args) &#123; //创建线程对象 Runnable runnable = new RunnableImpl(); //开启线程,三个窗口同时 new Thread(runnable).start(); new Thread(runnable).start(); new Thread(runnable).start(); &#125;&#125; 就会出现这种多两个线程买同一张票或者卖出不存在的票（0，-1） 12345678Thread-1正在卖第4张票Thread-2正在卖第4张票Thread-0正在卖第3张票Thread-1正在卖第2张票Thread-2正在卖第2张票Thread-0正在卖第1张票Thread-2正在卖第0张票Thread-1正在卖第-1张票 线程同步要解决上述多线程并发访问一个资源的安全性问题:也就是解决重复票与不存在票问题，Java中提供了同步机制 来解决。为了保证每个线程都能正常的执行操作，java引入了线程同步机制，一般有以下三种解决方式。 同步代码块 2. 同步方法 3. 锁机制 同步代码块同步代码块： synchronized 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。同步锁: 可以认为在对象上标记了一个锁. 锁对象 可以是任意类型。 2. 多个线程对象 要使用同一把锁。 在任意时刻，只有一个线程可以占有同步锁，占有同步锁的线程可以执行，知道结束以后别的线程才可以占有同步锁 12345678910111213141516171819202122232425public class RunnableImpl implements Runnable &#123; public int ticket = 10; //创建一个锁对象 Object object = new Object(); @Override public void run() &#123; //循环买票 while(true)&#123; //同步代码块 synchronized (object) &#123; if (ticket &gt; 0) &#123; //程序睡眠 买票操作时间 try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "正在卖第" + ticket-- + "张票"); &#125; else &#123; break; &#125; &#125; &#125; &#125;&#125; 同步方法同步方法:使用synchronized修饰的方法,就叫做同步方法。将会出现线程不安全的代码放在同步方法中，保证A线程执行该方法的时候,其他线程只能在方法外等着。同步方法的锁对象：对于非static的同步方法，锁对象是this对于static的同步方法，锁对象是当前方法的字节码文件（类名.class） 1234567891011121314151617181920212223public class RunnableImpl implements Runnable&#123; public static int ticket = 10; @Override public void run() &#123; //循环买票 while(true)&#123; payTicket(); &#125; &#125; //同步方法 public synchronized void payTicket()&#123; if (ticket &gt; 0)&#123; //程序睡眠 买票操作时间 try &#123; Thread.sleep(10); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+ "正在卖第" + ticket-- + "张票"); &#125; &#125;&#125; lock锁方法java.util.concurrent.locks包中的Lock接口 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作。Lock接口中的方法:void lock()获取锁，void unlock() 释放锁。使用步骤: 在成员位置创建一个lock接口的实现类ReentrantLock对象 在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁 在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁12345678910111213141516171819202122232425262728public class RunnableImpl implements Runnable&#123; public static int ticket = 10; //1.在成员位置创建一个ReentrantLock对象 Lock lock = new ReentrantLock(); @Override public void run() &#123; //循环买票 while(true)&#123; //2.在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁 lock.lock(); if (ticket &gt; 0)&#123; //程序睡眠 买票操作时间 try &#123; Thread.sleep(10); System.out.println(Thread.currentThread().getName()+ "正在卖第" + ticket-- + "张票"); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125;finally &#123; //3.在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁 lock.unlock();//无论程序是否异常,都会把锁释放 &#125; &#125;else &#123; break; &#125; &#125; &#125;&#125; 线程状态线程从被创建到结束，一个生命周期中有六种状态。|线程状态| 导致状态发生条件||—|—||NEW(新建)| 线程刚被创建，但是并未启动。还没调用start方法。||Runnable(可 运行)|线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操 作系统处理器。||Blocked(锁阻 塞)|当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状 态；当该线程持有锁时，该线程将变成Runnable状态。||Waiting(无限 等待)|一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个 状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。||Timed Waiting(计时 等待)|同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态 将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、 Object.wait。||Teminated(被 终止)|因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。| 等待唤醒机制简单等待唤醒机制案例消费者与生产者，等待wait()方法，notify()唤醒方法等待唤醒案例:线程之间的通信 创建一个顾客线程(消费者):告知老板要的包子的种类和数量,调用wait方法,放弃cpu的执行,进入到WAITING状态(无限等待) 创建一个老板线程(生产者):花了5秒做包子,做好包子之后,调用notify方法,唤醒顾客吃包子 注意: 顾客和老板线程必须使用同步代码块包裹起来,保证等待和唤醒只能有一个在执行 同步使用的锁对象必须保证唯一 只有锁对象才能调用wait和notify方法 12345678910111213141516171819202122232425262728293031323334353637383940public class Main &#123; public static void main(String[] args) &#123; //创建锁对象,要解决两个线程调度问题，要使用同一个琐对象 Object object = new Object(); //创建顾客线程（消费者） new Thread()&#123; @Override public void run() &#123; synchronized (object) &#123; System.out.println("告知老板包子种类数量"); //等待包子制作时间(进入无限等待状态) try &#123; object.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("包子做好啦，开吃"); &#125; &#125; &#125;.start(); //创建商家线程（消费者） new Thread()&#123; @Override public void run() &#123; synchronized (object)&#123; //制作包子花费5秒 try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("老板5秒钟之后做好包子,告知顾客,可以吃包子了"); object.notify(); &#125; &#125; &#125;.start(); &#125;&#125; 进入到TimeWaiting(计时等待)有两种方式 使用sleep(long m)方法,在毫秒值结束之后,线程睡醒进入到Runnable/Blocked状态 使用wait(long m)方法,wait方法如果在毫秒值结束之后,还没有被notify唤醒,就会自动醒来,线程睡醒进入到Runnable/Blocked状态唤醒的方法: void notify() 唤醒在此对象监视器上等待的单个线程。 void notifyAll() 唤醒在此对象监视器上等待的所有线程。 当有两个线程时，如果使用notify只会随机唤醒其中一个线程，另一个线程不会唤醒，从而整个程序就会处于无限等待状态。这时应该使用notifyAll方法唤醒所有线程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Main2 &#123; public static void main(String[] args) &#123; //创建锁对象,要解决两个线程调度问题，要使用同一个琐对象 Object object = new Object(); //创建顾客线程（消费者） new Thread()&#123; @Override public void run() &#123; synchronized (object) &#123; System.out.println("顾客1告知老板包子种类数量"); //等待包子制作时间(进入无限等待状态) try &#123; object.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("顾客1包子做好啦，开吃"); &#125; &#125; &#125;.start(); //创建顾客线程（消费者） new Thread()&#123; @Override public void run() &#123; synchronized (object) &#123; System.out.println("顾客2告知老板包子种类数量"); //等待包子制作时间(进入无限等待状态) try &#123; object.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("顾客2包子做好啦，开吃"); &#125; &#125; &#125;.start(); //创建商家线程（消费者） new Thread()&#123; @Override public void run() &#123; synchronized (object)&#123; //制作包子花费5秒 try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("老板5秒钟之后做好包子,告知顾客,可以吃包子了"); object.notifyAll();//唤醒所有等待的线程 &#125; &#125; &#125;.start(); &#125;&#125;]]></content>
      <categories>
        <category>线程</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构--优先队列]]></title>
    <url>%2F2019%2F11%2F14%2F%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[数据结构–优先队列什么是优队列 队列的特点是先进先出，即先入队的元素首先弹出 优先队列不再遵循先入先出的原则，而是分为两种情况： 最大优先队列，无论入队顺序，当前最大的元素优先出队。 最小优先队列，无论入队顺序，当前最小的元素优先出队。 要满足以上需求，利用线性数据结构并非不能实现，但是时间复杂度较高，最坏时间复杂度O（n），并不是最理想的方式。 实现方法我们可以用最大堆来实现最大优先队列，每一次入队操作就是堆的插入操作，每一次出队操作就是删除堆顶节点。 入队操作 插入新节点5 新节点5上浮到合适位置 出队操作 把原堆顶节点10“出队” 最后一个节点1替换到堆顶位置 节点1下沉，节点9成为新堆顶 如此，二叉堆节点上浮下沉时间为longn，则队列操作时间复杂度为longn 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107public class PriorityQueue &#123; private int[] array; private int size; public PriorityQueue() &#123; //初始大小为32位 array = new int[32]; size = 0; &#125; /** * 上浮调整 */ private void upAdjust()&#123; //用于表示当前子节点 int childIndex = array.length - 1; //用于表示当前子节点的父节点 int parentIndex = (childIndex - 1)/2; //将最初始要上浮的叶子节点保存，用于最后赋值 int temp = array[childIndex]; //上浮 while (childIndex &gt; 0 &amp;&amp; temp &lt; array[parentIndex])&#123; //无需交换 直接赋值 array[childIndex] = array[parentIndex]; childIndex = parentIndex; parentIndex = (childIndex - 1)/2; &#125; //此节点最终位置 array[childIndex] = temp; &#125; /** * 下沉调整 */ private void downAdjust()&#123; int parentIndex = 0; int length = size; //temp保存父节点值，用于最后赋值 int temp = array[parentIndex]; int childIndex = 2 * parentIndex + 1; while (childIndex &lt; length)&#123; //如果有右孩子节点 且右孩子节点比左孩子小，则定位到右孩子 if (childIndex + 1 &lt; length &amp;&amp; array[childIndex + 1] &lt; array[childIndex])&#123; childIndex++; &#125; //如果父节点小于任何一个孩子的值，直接跳出 if (temp &lt;= array[childIndex]) &#123; break; &#125; //下沉 array[parentIndex] = array[childIndex]; parentIndex = childIndex; childIndex = parentIndex * 2 + 1; &#125; array[parentIndex] = temp; &#125; /** * 数组扩容 */ private void reSize()&#123; int newSize = this.size * 2; this.array = Arrays.copyOf(this.array, newSize); &#125; /** * 入队操作 * @param key 入队元素 */ private void enQueue(int key)&#123; if (size &gt; array.length)&#123; reSize(); &#125; //在队尾插入元素 array[size++] = key; //上浮到相应位置 upAdjust(); &#125; /** * 出队 * @return 出队元素 */ private int deQueue()&#123; if (size &lt; 0) System.out.println("没有元素"); //获取堆顶元素出队 int key = array[0]; //将堆低元素放入堆顶 array[0] = array[--size]; downAdjust(); return key; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); PriorityQueue priorityQueue = new PriorityQueue(); int l = scanner.nextInt(); for (int i = 0; i &lt; l; i++)&#123; priorityQueue.enQueue(scanner.nextInt()); &#125; //出队 System.out.println(priorityQueue.deQueue()); System.out.println(priorityQueue.deQueue()); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构--二叉堆]]></title>
    <url>%2F2019%2F11%2F14%2F%E4%BA%8C%E5%8F%89%E5%A0%86%2F</url>
    <content type="text"><![CDATA[数据结构–二叉堆什么是二叉堆二叉堆本质上是一种完全二叉树，最大堆和最小堆两个类型 最大堆最大堆任何一个父节点的值，都大于他左右孩子节点的值最大堆的堆顶是堆中最大元素 最小堆最小堆任何一个父节点的值，都小于他左右孩子节点的值最小堆的堆顶是堆中最小元素 堆的创建插入以及删除插入节点 从二叉堆的最后一个位置插入一个新的节点0 让该节点与父节点比5较如果小于5则新节点上浮，和父节点交换位置 继续比较最终上浮到相应位置 删除节点 与插入相反，二叉堆删除的是处于堆顶的节点。 为了未出完全二叉树结构，我们把堆的最后一个节点10补到原来位置 让堆顶节点10与他的左右孩子比较，如有比他小的，那么让10节点下沉到最小的节点位置与该节点交换 继续下沉，与最小的7交换就得到最终调整 构建二叉堆将一颗无序的完全二叉树调整为二叉堆，本质上就是让所有非叶子节点依次下沉。例如下图无序二叉树 从最后一个非叶子节点10开始，如果节点10大于他左右孩子中最小的一个，则节点10下沉 接下来是3节点下沉 接下来是1节点，小于左右孩子节点。则不变。接下来是7节点下沉 堆的存储方式二叉堆虽然是一颗完全二叉树，但是他的存储方式是顺序存储。所有节点都存储在数组当中 我们可以通过数组下标的计算得到节点的孩子节点。假设父节点的下标是p，那么他的左孩子节点是2 * p+1, 右孩子下标是2 * p+2以下是代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class BinaryHeap &#123; /** * 上浮调整 * @param array 待调整的堆 */ public static void upAdjust(int[] array)&#123; //用于表示当前子节点 int childIndex = array.length - 1; //用于表示当前子节点的父节点 int parentIndex = (childIndex - 1)/2; //将最初始要上浮的叶子节点保存，用于最后赋值 int temp = array[childIndex]; //上浮 while (childIndex &gt; 0 &amp;&amp; temp &lt; array[parentIndex])&#123; //无需交换 直接赋值 array[childIndex] = array[parentIndex]; childIndex = parentIndex; parentIndex = (childIndex - 1)/2; &#125; //此节点最终位置 array[childIndex] = temp; &#125; /** * 下沉调整 * @param array 待调整的堆 * @param parentIndex 要下沉的父节点 * @param length 堆的有效大小 */ public static void downAdjust(int[] array, int parentIndex, int length)&#123; //temp保存父节点值，用于最后赋值 int temp = array[parentIndex]; int childIndex = 2 * parentIndex + 1; while (childIndex &lt; length)&#123; //如果有右孩子节点 且右孩子节点比左孩子小，则定位到右孩子 if (childIndex + 1 &lt; length &amp;&amp; array[childIndex + 1] &lt; array[childIndex])&#123; childIndex++; &#125; //如果父节点小于任何一个孩子的值，直接跳出 if (temp &lt;= array[childIndex]) &#123; break; &#125; //下沉 array[parentIndex] = array[childIndex]; parentIndex = childIndex; childIndex = parentIndex * 2 + 1; &#125; array[parentIndex] = temp; &#125; /** * 构建堆 * @param array 待构建的堆 */ public static void buildHeap(int[] array)&#123; //从最后一个非叶子节点开始依次下沉 for (int i = (array.length-2)/2; i &gt;= 0; i--)&#123; downAdjust(array, i, array.length); &#125; &#125; public static void main(String[] args) &#123; //将最后一个新节点0上浮到适当位置 int[] array = new int[] &#123;1,3,2,6,5,7,8,9,10,0&#125;; upAdjust(array); System.out.println(Arrays.toString(array)); //构建一个小根堆 array = new int[] &#123;7,1,3,10,5,2,8,9,6&#125;; buildHeap(array); System.out.println(Arrays.toString(array)); &#125;&#125; 堆排序堆排序原理 接上文，最大堆的堆顶是整个堆中最大的元素，当我们删除最大堆的堆顶后经过自我调整，下一个最大元素会成为新的堆顶。 所以我们可以每次把最大堆的堆顶与堆低交换，调整后的新堆顶就是大小仅次于旧堆顶的节点，如此反复就可得到有序集合。 排序过程删除节点9,8成为新的堆顶。删除节点3,2成为新堆顶到此，原本的最大堆已经变成一个有序的集合。 总结及复杂度 我们可以归纳出堆排序算法的步骤： 把无序数组构建成二叉堆。 循环删除堆顶元素，移到集合尾部，调节堆产生新的堆顶。 空间复杂度O(1) 时间复杂度： 第一步，把无序数组构建成二叉堆，需要进行n/2次循环。每次循环调用一次 downAdjust 方法，所以第一步的计算规模是 n/2 * logn，时间复杂度 O（nlogn）。 第二步，需要进行n-1次循环。每次循环调用一次 downAdjust 方法，所以第二步的计算规模是 （n-1） * logn ，时间复杂度 O（nlogn）。两个步骤是并列关系，所以整体的时间复杂度同样是 O（nlogn）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class HeapSort &#123; /** * 下沉调整 * @param array 待调整的堆 * @param parentIndex 要下沉的父节点 * @param length 堆的有效大小 */ public static void downAdjust(int[] array, int parentIndex, int length)&#123; int temp = array[parentIndex]; int childrenIndex = parentIndex * 2 + 1; while (childrenIndex &lt; length)&#123; if (childrenIndex + 1 &lt; length &amp;&amp; array[childrenIndex] &lt; array[childrenIndex + 1])&#123; childrenIndex++; &#125; if (temp &gt; array[childrenIndex]) break; array[parentIndex] = array[childrenIndex]; parentIndex = childrenIndex; childrenIndex = parentIndex * 2 + 1; &#125; array[parentIndex] = temp; &#125; /** * 堆排序 * @param array 待排序数组 */ public static void heapSort(int[] array)&#123; //构建二叉堆 for (int i = (array.length - 2) / 2; i &gt;= 0; i--)&#123; downAdjust(array, i, array.length); &#125; System.out.println(Arrays.toString(array)); //不断将堆顶元素放到堆低 for (int i = array.length - 1; i &gt; 0; i--) &#123; //最后一个未交换元素和堆顶交换 int temp = array[0]; array[0] = array[i]; array[i] = temp; //往后就不用在调整换下来的堆低元素 downAdjust(array, 0, i); &#125; &#125; public static void main(String[] args) &#123; int[] array = new int[] &#123;1,3,3,6,5,7,8,9,10,0&#125;; heapSort(array); System.out.println(Arrays.toString(array)); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis&Jedis基础]]></title>
    <url>%2F2019%2F11%2F01%2FRedis%26Jedis%2F</url>
    <content type="text"><![CDATA[Redis&amp;Jedis基础基础概念redis是一款高性能的NOSQL系列的非关系型数据库 什么是NOSQLNoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 NOSQL和关系型数据库比较 优点： 成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。 查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。 存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。 扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。 缺点： 维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。 不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。 不提供关系型数据库对事务的处理。 非关系型数据库的优势： 性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。 可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 关系型数据库的优势： 复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。 总结 关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库，让NoSQL数据库对关系型数据库的不足进行弥补。一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据 主流的NOSQL产品键值(Key-Value)存储数据库相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB典型应用： 内容缓存，主要用于处理大量数据的高访问负载。数据模型： 一系列键值对优势： 快速查询劣势： 存储的数据缺少结构化 列存储数据库相关产品：Cassandra, HBase, Riak典型应用：分布式的文件系统数据模型：以列簇式存储，将同一列数据存在一起优势：查找速度快，可扩展性强，更容易进行分布式扩展劣势：功能相对局限 文档型数据库相关产品：CouchDB、MongoDB典型应用：Web应用（与Key-Value类似，Value是结构化的）数据模型： 一系列键值对优势：数据结构要求不严格劣势： 查询性能不高，而且缺乏统一的查询语法 图形(Graph)数据库相关数据库：Neo4J、InfoGrid、Infinite Graph典型应用：社交网络数据模型：图结构优势：利用图结构相关算法。劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 RedisRedis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：1.字符串类型 string 2.哈希类型 hash 3.列表类型 list 4.集合类型 set 5.有序集合类型 sortedset redis的应用场景缓存（数据查询、短连接、新闻内容、商品内容等等）聊天室的在线好友列表任务队列。（秒杀、抢购、12306等等）应用排行榜网站访问统计数据过期处理（可以精确到毫秒分布式集群架构中的session分离 下载安装 官网：https://redis.io 中文网：http://www.redis.net.cn/ 解压直接可以使用： redis.windows.conf：配置文件 redis-cli.exe：redis的客户端 redis-server.exe：redis服务器端命令操作 redis的数据结构： redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构 value的数据结构： 字符串类型 string 哈希类型 hash ： map格式 列表类型 list ： linkedlist格式。支持重复元素 集合类型 set ： 不允许重复元素 有序集合类型 sortedset：不允许重复元素，且元素有顺序 字符串类型 string 存储： set key value 127.0.0.1:6379&gt; set username zhangsan OK 获取： get key 127.0.0.1:6379&gt; get username “zhangsan” 删除： del key 127.0.0.1:6379&gt; del age (integer) 1 哈希类型 hash 存储： hset key field value 127.0.0.1:6379&gt; hset myhash username lisi (integer) 1 127.0.0.1:6379&gt; hset myhash password 123 (integer) 1 获取： hget key field: 获取指定的field对应的值127.0.0.1:6379&gt; hget myhash username“lisi” hgetall key：获取所有的field和value127.0.0.1:6379&gt; hgetall myhash1) “username”2) “lisi”3) “password”4) “123” 删除： hdel key field 127.0.0.1:6379&gt; hdel myhash username (integer) 1 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边） 添加： lpush key value: 将元素加入列表左表 rpush key value：将元素加入列表右边127.0.0.1:6379&gt; lpush myList a(integer) 1127.0.0.1:6379&gt; lpush myList b(integer) 2127.0.0.1:6379&gt; rpush myList c(integer) 3 获取： lrange key start end ：范围获取127.0.0.1:6379&gt; lrange myList 0 -11) “b”2) “a”3) “c” 删除： lpop key： 删除列表最左边的元素，并将元素返回 rpop key： 删除列表最右边的元素，并将元素返回 集合类型 set ： 不允许重复元素 存储：sadd key value 127.0.0.1:6379&gt; sadd myset a (integer) 1 127.0.0.1:6379&gt; sadd myset a (integer) 0 获取：smembers key:获取set集合中所有元素 127.0.0.1:6379&gt; smembers myset 1) “a” 删除：srem key value:删除set集合中的某个元素 127.0.0.1:6379&gt; srem myset a (integer) 1 有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 存储：zadd key score value 127.0.0.1:6379&gt; zadd mysort 60 zhangsan (integer) 1 127.0.0.1:6379&gt; zadd mysort 50 lisi (integer) 1 127.0.0.1:6379&gt; zadd mysort 80 wangwu (integer) 1 获取：zrange key start end [withscores] 127.0.0.1:6379&gt; zrange mysort 0 -1 1) “lisi” 2) “zhangsan” 3) “wangwu” 127.0.0.1:6379&gt; zrange mysort 0 -1 withscores1) “zhangsan”2) “60”3) “wangwu”4) “80”5) “lisi”6) “500” 删除：zrem key value 127.0.0.1:6379&gt; zrem mysort lisi (integer) 1 通用命令 keys * : 查询所有的键 type key ： 获取键对应的value的类型 del key：删除指定的key value 持久化redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。 redis持久化机制： RDB：默认方式，不需要进行配置，默认就使用这种机制在一定的间隔时间中，检测key的变化情况，然后持久化数据 编辑redis.windwos.conf文件 # after 900 sec (15 min) if at least 1 key changed save 900 1 # after 300 sec (5 min) if at least 10 keys changed save 300 10 # after 60 sec if at least 10000 keys changed save 60 10000 重新启动redis服务器，并指定配置文件名称 D:\JavaWeb2018\day23_redis\资料\redis\windows-64\redis-2.8.9&gt;redis-server.exe redis.windows.conf AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据 编辑redis.windwos.conf文件 appendonly no（关闭aof） –&gt; appendonly yes （开启aof）# appendfsync always ： 每一次操作都进行持久化 appendfsync everysec ： 每隔一秒进行一次持久化 # appendfsync no ： 不进行持久化 Java客户端 Jedis基础使用Jedis: 一款java操作redis数据库的工具. 使用步骤： 下载jedis的jar包 使用 //1. 获取连接 Jedis jedis = new Jedis(“localhost”,6379); //2. 操作 jedis.set(“username”,”zhangsan”); //3. 关闭连接 jedis.close(); Jedis操作各种redis中的数据结构1. 字符串类型 string123456789101112131415//1.获取连接Jedis jedis = new Jedis("localhost", 6379);//2.操作//存储jedis.set("username", "lihaobo");jedis.set("username2", "zhanghaohua");//获取System.out.println(jedis.get("username"));//可以使用setex()方法存储可以指定过期时间的 key valuejedis.setex("activeCode", 10, "1345");//将activecode：1345键值对存入redis，并且20秒后自动删除该键值对//关闭jedis.close();/*lihaobo */ 哈希类型 hash ： map格式123456789101112131415161718192021222324252627282930//1. 获取连接Jedis jedis = new Jedis();//如果使用空参构造，默认值 "localhost",6379端口// 2. 操作// 存储hashjedis.hset("lihaobo", "password", "123");jedis.hset("lihaobo", "age", "23");jedis.hset("zhanghaohua", "password", "456");jedis.hset("zhanghaohua", "age", "22");//获取hashSystem.out.println(jedis.hget("lihaobo", "password"));System.out.println(jedis.hget("zhanghaohua", "password"));//获取hash中的map集合Map&lt;String, String&gt; lihaobo = jedis.hgetAll("lihaobo");System.out.println(lihaobo);Set&lt;String&gt; keySet = lihaobo.keySet();for (String key : keySet) &#123; String s = lihaobo.get(key); System.out.println(s);&#125;//关闭jedis.close();/*123456&#123;password=123, age=23&#125;12323 */ 列表类型 list ： linkedlist格式。支持重复元素123456789101112131415161718192021222324252627Jedis jedis = new Jedis("localhost", 6379);//2. 操作// list 存储jedis.lpush("mylist","a","b","c");//从左边存jedis.rpush("mylist","a","b","c");//从右边存//list范围获取List&lt;String&gt; mylist = jedis.lrange("mylist", 0, -1);System.out.println(mylist);//list弹出String mylist1 = jedis.lpop("mylist");String mylist2 = jedis.rpop("mylist");System.out.println(mylist1);System.out.println(mylist2);//list范围获取mylist = jedis.lrange("mylist", 0, -1);System.out.println(mylist);jedis.close();/*[c, b, a, a, b, c]cc[b, a, a, b]*/ 集合类型 set ： 不允许重复元素1234567891011Jedis jedis = new Jedis();jedis.sadd("myset", "java","c/c++", "python");Set&lt;String&gt; myset = jedis.smembers("myset");System.out.println(myset);jedis.close();/*[python, java, c/c++] */ 有序集合类型 sortedset：不允许重复元素，且元素有顺序1234567891011121314Jedis jedis = new Jedis();// sortedset 存储jedis.zadd("mysortedset",3,"亚瑟");jedis.zadd("mysortedset",30,"后裔");jedis.zadd("mysortedset",55,"孙悟空");//获取Set&lt;String&gt; mysortedset = jedis.zrange("mysortedset", 0, -1);System.out.println(mysortedset);jedis.close();/*[亚瑟, 后裔, 孙悟空] */ jedis连接池： JedisPool 创建JedisPool连接池对象 调用方法 getResource()方法获取Jedis连接12345678910111213//创建配置对象JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();jedisPoolConfig.setMaxTotal(50);jedisPoolConfig.setMaxIdle(10);//创建jedis连接对象JedisPool jedisPool = new JedisPool(jedisPoolConfig, "localhost", 6379);//获取连接Jedis jedis = jedisPool.getResource();//使用jedis.set("username", "lihaob");System.out.println(jedis.get("username"));//关闭jedis.close(); 连接池工具类 123456789101112131415161718192021222324252627282930313233343536private static JedisPool jedisPool;static&#123; //读取配置文件 InputStream is = null; try &#123; is = new FileInputStream(JedisPoolUtils.class.getResource("/").getPath() + "/jedis.properties"); //JedisPoolUtils.class.getClassLoader().getResourceAsStream("jedis.properties"); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; //创建Properties对象 Properties pro = new Properties(); //关联文件 try &#123; pro.load(is); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //获取数据，设置到JedisPoolConfig中 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(Integer.parseInt(pro.getProperty("maxTotal"))); config.setMaxIdle(Integer.parseInt(pro.getProperty("maxIdle"))); //初始化JedisPool jedisPool = new JedisPool(config,pro.getProperty("host"),Integer.parseInt(pro.getProperty("port")));&#125;/** * 获取连接方法 */public static Jedis getJedis()&#123; return jedisPool.getResource();&#125;]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>NOSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven基础]]></title>
    <url>%2F2019%2F10%2F28%2Fmaven%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Maven基础一、Maven简介含义Maven 是一个项目管理工具，它包含了一个项目对象模 型 (POM：Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管 理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标 (goal)的逻辑。 Maven能解决的问题 我们需要引用各种 jar 包，尤其是比较大的工程，引用的 jar 包往往有几十个乃至上百个， 每用 到一种 jar 包，都需要手动引入工程目录，而且经常遇到各种让人抓狂的 jar 包冲突，版本冲突。 我们辛辛苦苦写好了 Java 文件，需要将它编译成二 进制字节码。好歹现在这项工作可以由各种集成开发工具帮我们完成，Eclipse、IDEA 等都可以将代 码即时编译。 写完了代码，我们还要写一些单元测试，然后一个个的运行来检验代码质量。 maven就能帮你构建工程，管理 jar 包，编译代码，还能帮你自动运行单元测试，打包，生成报表，甚至能帮你部署项目，生成 Web 站 点. 二、Maven的两个经典作用1. Maven的依赖管理Maven 的一个核心特性就是依赖管理。当我们涉及到多模块的项目（包含成百个模块或者子项目），管理依赖就变成 一项困难的任务。Maven 展示出了它对处理这种情形的高度控制。 传统的 WEB 项目中，我们必须将工程所依赖的 jar 包复制到工程中，导致了工程的变得很大。那么 maven 工程是如何使得工程变得很少呢？maven 工程中不直接将 jar 包导入到工程中，而是通过在 pom.xml 文件中添加所需 jar 包的坐标，这样就很好的避免了 jar 直接引入进来，在需要用到 jar 包的时候，只要查找 pom.xml 文 件，再通过 pom.xml 文件中的坐标，到一个专门用于”存放 jar 包的仓库”(maven 仓库)中根据坐标从 而找到这些 jar 包，再把这些 jar 包拿去运行。 2. 项目的一键构建我们的项目，往往都要经历编译、测试、运行、打包、安装 ，部署等一系列过程。 署整个过程都交给 maven 进行管理， 使用 maven 一个命令可以轻松完成整个工作。 三、Maven的目录及配置Maven的目录结构Maven 下载后，将 Maven 解压到一个没有中文没有空格的路径下，比如 D:\maven 下面。 解压后目录结构如下：bin:存放了 maven 的命令，比如我们前面用到的mvn tomcat:runboot:存放了一些 maven 本身的引导程序，如类加载器等conf:存放了 maven 的一些配置文件，如 setting.xml 文件lib:存放了 maven 本身运行所需的一些 jar 包 Maven工程的目录结构作为一个 maven 工程，它的 src目录和 pom.xml 是必备的。进入 src目录后，我们发现它里面的目录结构如下：src/main/java —— 存放项目的.java 文件src/main/resources —— 存放项目资源文件，如 spring, hibernate 配置文件 src/test/java —— 存放所有单元测试.java 文件，如 JUnit 测试类 src/test/resources —— 测试资源文件 target —— 项目输出位置，编译后的class 文件会输出到此目录 pom.xml——maven 项目核心配置文件 四、Maven仓库Maven仓库分类maven 的工作需要从仓库下载一些 jar 包，如下图所示，本地的项目 A、项目 B 等都会通过 maven 软件从远程仓库（可以理解为互联网上的仓库）下载 jar 包并存在本地仓库，本地仓库就是本地文件夹，当第二次需要此 jar 包时则不再从远程仓库下载，因为本地仓库已经存在了，可以将本地仓库理解为缓存，有了本地仓库就不用每次从远程仓库下载了。 本地仓库 ：用来存储从远程仓库或中央仓库下载的插件和 jar 包，项目使用一些插件或 jar 包， 优先从本地仓库查找 默认本地仓库位置在 ${user.dir}/.m2/repository，${user.dir}表示windows 用户目录。 远程仓库：如果本地需要插件或者 jar 包，本地仓库没有，默认去远程仓库下载。 远程仓库可以在互联网内也可以在局域网内。 中央仓库 ：在 maven 软件中内置一个远程仓库地址 http://repo1.maven.org/maven2 ，它是中 央仓库，服务于整个互联网，它是由 Maven 团队自己维护，里面存储了非常全的 jar 包，它包 含了世界上大部分流行的开源项目构件。 本地库的配置我们可以配置自己的本地库位置例如放在E:\maven_repository目录下后在conf/settings.xml文件中配置本地库位置 12345678910&lt;settings xmlns="http://maven.apache.org/SETTINGS/1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd"&gt; &lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: $&#123;user.home&#125;/.m2/repository &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt; --&gt;&lt;localRepository&gt;E:\maven_repository&lt;/localRepository&gt; Maven概念模型 五、idea开发Maven项目idea的Maven配置 File-&gt;Settings 配置 maven idea 中new一个 maven 的 web 工程 选择 idea提供好的 maven 的web 工程模板 webapp 点击 Next填写项目信息 点击 Next，此处不做改动。 点击 Next选择项目所在目录 点击 Finish后开始创建工程，耐心等待，直到出现如下界面。 第一次要等待很长很长时间，慢慢等待项目配置完毕 手动添加 src/main/java 目录，如下图右键 main 文件夹-&gt;New-&gt;Directory 创建一个新的文件夹命名为 java 点击 OK后，在新的文件夹 java 上右键-&gt;Make Directory as-&gt;Sources Root 创建一个Servlet src/java/main 创建了一个 Servlet，但报错。原因是没有在maven中导入servlet包，则此时就要添加servlet包的坐标。 直接打开工程的 pom.xml 文件，再添加坐标添加 jar 包的坐标时，还可以指定这个 jar 包将来的作用范围。 每个 maven 工程都需要定义本工程的坐标，坐标是 maven 对 jar 包的身份定义，比如：入门程序的 坐标定义如下： 123456789&lt;!--项目名称，定义为组织名+项目名，类似包名--&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;!-- 模块名称 --&gt;&lt;artifactId&gt;hello_maven&lt;/artifactId&gt; &lt;!-- 当前项目版本号，snapshot 为快照版本即非正式版本，release为正式发布版本 --&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging &gt; ：打包类型 jar：执行 package 会打成 jar 包 war：执行 package 会打成 war 包 pom ：用于 maven 工程的继承，通常父工程设置为 pom 例如： 123456789101112131415161718192021&lt;!--放置的都是项目运行所依赖的jar包--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 配置jdk版本 123456789101112131415161718192021&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;port&gt;8888&lt;/port&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 在 src/main/java中创建 ServletTest 123protected void doGet(HttpServletRequest request, HttpServletResponse response) throws javax.servlet.ServletException, IOException &#123; request.getRequestDispatcher("/hello.jsp").forward(request, response); &#125; 编写jsp 123&lt;body&gt; hello maven&lt;/body&gt; 手动输入 tomc7:run 命令运行项目 点击后弹出如下图窗口 ，点击Execute]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Filter-Listener学习]]></title>
    <url>%2F2019%2F10%2F23%2FFilter-Listener%2F</url>
    <content type="text"><![CDATA[Filter：过滤器1. 概念： 生活中的过滤器：净水器,空气净化器 web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。 过滤器的作用：一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤… 快速入门：步骤： 定义一个类，实现接口Filter 复写方法 配置拦截路径 web.xml 注解代码：123456789101112131415@WebFilter("/*")//访问所有资源之前，都会执行该过滤器public class FilterDemo1 implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException&#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println("filterDemo1被执行了...."); //放行 filterChain.doFilter(servletRequest,servletResponse);&#125; @Override public void destroy() &#123; &#125;&#125; 过滤器细节：web.xml配置123456789&lt;filter&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;filter-class&gt;cn.itcast.web.filter.FilterDemo1&lt;/filter-class&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;!-- 拦截路径 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 过滤器执行流程 执行过滤器 执行放行后的资源 回来执行过滤器放行代码下边的代码过滤器生命周期方法 init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源 doFilter:每一次请求被拦截资源时，会执行。执行多次 destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源过滤器配置详解 拦截路径配置： 具体资源路径： /index.jsp 只有访问index.jsp资源时，过滤器才会被执行 拦截目录： /user/* 访问/user下的所有资源时，过滤器都会被执行 后缀名拦截： *.jsp 访问所有后缀名为jsp资源时，过滤器都会被执行 拦截所有资源：/* 访问所有资源时，过滤器都会被执行 拦截方式配置：资源被访问的方式 注解配置：设置dispatcherTypes属性 REQUEST：默认值。浏览器直接请求资源 FORWARD：转发访问资源 INCLUDE：包含访问资源 ERROR：错误跳转资源 ASYNC：异步访问资源 web.xml配置 设置&lt; dispatcher&gt;&lt; /dispatcher&gt;标签即可 过滤器链(配置多个过滤器) 执行顺序：如果有两个过滤器：过滤器1和过滤器2 过滤器1 过滤器2 资源执行 过滤器2 过滤器1 过滤器先后顺序问题： 注解配置：按照类名的字符串比较规则比较，值小的先执行 如： AFilter 和 BFilter，AFilter就先执行了。 web.xml配置： &lt; filter-mapping&gt;谁定义在上边，谁先执行 增强对象的功能：设计模式：一些通用的解决固定问题的方式 装饰模式 代理模式实现方式： 静态代理：有一个类文件描述代理模式 动态代理：在内存中形成代理类实现步骤： 代理对象和真实对象实现相同的接口 代理对象 = Proxy.newProxyInstance(); 使用代理对象调用方法。 增强方法增强方式： 增强参数列表 增强返回值类型 增强方法体执行逻辑例如过滤敏感词1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//存放敏感词集合 private List&lt;String&gt; list = new ArrayList&lt;&gt;(); public void destroy() &#123; &#125; public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123; //1.创建代理对象 ServletRequest proxy_req = (ServletRequest) Proxy.newProxyInstance(req.getClass().getClassLoader(), req.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //2.增强getParameter方法 //判断是否为getParameter方法 if (method.getName().equals("getParameter"))&#123; //增强返回值 //获取返回值 String value = (String)method.invoke(req, args); if (value != null)&#123; for ( String str: list) &#123; if (value.contains(str))&#123; value = value.replaceAll(str, "**"); &#125; &#125; &#125; return value; &#125; return method.invoke(req,args); &#125; &#125;); chain.doFilter(req, resp); &#125; public void init(FilterConfig config) throws ServletException &#123; try &#123; //获取文件真实路径 ServletContext servletContext = config.getServletContext(); String realPath = servletContext.getRealPath("/WEB-INF/classes/敏感词汇.txt"); //读取文件 BufferedReader br = new BufferedReader(new FileReader(realPath)); //将文件每一行加载到list中 String line = null; while ((line = br.readLine()) != null)&#123; list.add(line); &#125; System.out.println(list); br.close(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; Listener：监听器概念： web的三大组件之一。 事件监听机制 事件：一件事情 事件源 ：事件发生的地方 监听器 ：一个对象 注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码ServletContextListener:监听ServletContext对象的创建和销毁 方法： void contextDestroyed(ServletContextEvent sce) ：ServletContext对象被销毁之前会调用该方法 void contextInitialized(ServletContextEvent sce) ：ServletContext对象创建后会调用该方法 步骤： 定义一个类，实现ServletContextListener接口 复写方法 配置 指定初始化参数&lt; context-param&gt; 注解: @WebListener1234&lt;!--web.xml--&gt;&lt;listener&gt; &lt;listener-class&gt;cn.itcast.web.listener.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Filter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP-EL-JSTL学习]]></title>
    <url>%2F2019%2F10%2F18%2FEL-JSTL%2F</url>
    <content type="text"><![CDATA[JSP1. 基本使用 作用：用于配置JSP页面，导入资源文件 格式： &lt; %@ 指令名称 属性名1=属性值1 属性名2=属性值2 … %&gt;2. 分类： page ： 配置JSP页面的 contentType：等同于response.setContentType() 设置响应体的mime类型以及字符集 设置当前jsp页面的编码（只能是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集） import：导包 errorPage：当前页面发生异常后，会自动跳转到指定的错误页面 isErrorPage：标识当前也是是否是错误页面。 true：是，可以使用内置对象exception false：否。默认值。不可以使用内置对象exception include ： 页面包含的。导入页面的资源文件 &lt; %@include file=”top.jsp”%&gt; taglib ： 导入资源 &lt; %@ taglib prefix=”c” uri=”http://java.sun.com/jsp/jstl/core&quot; %&gt; 注释: html注释： &lt; !– –&gt;:只能注释html代码片段 jsp注释：推荐使用 &lt;%– –%&gt;：可以注释所有3. 内置对象在jsp页面中不需要创建，直接使用的对象一共有9个： 变量名 真实类型 作用 pageContext PageContext 当前页面共享数据，还可以获取其他八个内置对象 request HttpServletRequest 一次请求访问的多个资源(转发) session HttpSession 一次会话的多个请求间 application ServletContext 所有用户间共享数据 response HttpServletResponse 响应对象 page Object 当前页面(Servlet)的对象 this out JspWriter 输出对象，数据输出到页面上 config ServletConfig Servlet的配置对象 exception Throwable 异常对象 MVC：开发模式1. jsp演变历史 早期只有servlet，只能使用response输出标签数据，非常麻烦 后来又jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中即写大量的java代码，有写html表，造成难于维护，难于分工协作 再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性 2. MVC： M：Model，模型。JavaBean 完成具体的业务操作，如：查询数据库，封装对象 V：View，视图。JSP 展示数据 C：Controller，控制器。Servlet 获取用户的输入 调用模型 将数据交给视图进行展示 优缺点： 优点： 耦合性低，方便维护，可以利于分工协作 重用性高 缺点： 使得项目架构变得复杂，对开发人员要求高 EL表达式基本概念 概念：Expression Language 表达式语言 作用：替换和简化jsp页面中java代码的编写 语法：${表达式} 注意： jsp默认支持el表达式的。如果要忽略el表达式 设置jsp中page指令中：isELIgnored=”true” 忽略当前jsp页面中所有的el表达式 ${表达式} ：忽略当前这个el表达式基本使用 算数运算符： + - * /(div) %(mod) 比较运算符： &gt; &lt; &gt;= &lt;= == != 逻辑运算符： &amp;&amp;(and) ||(or) !(not) 空运算符： empty 功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0 ${empty list}:判断字符串、集合、数组对象是否为null或者长度为0 ${not empty str}:表示判断字符串、集合、数组对象是否不为null 并且 长度&gt;0el表达式只能从域对象中获取值 ${域名称.键名}：从指定域中获取指定键的值 域名称： pageScope –&gt; pageContext requestScope –&gt; request sessionScope –&gt; session applicationScope –&gt; application（ServletContext） 举例：在request域中存储了name=张三获取：${requestScope.name} ${键名}：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。 获取对象、List集合、Map集合的值 对象：${域名称.键名.属性名}本质上会去调用对象的getter方法 List集合：${域名称.键名[索引]} Map集合： ${域名称.键名.key名称} ${域名称.键名[“key名称”]} 隐式对象：el表达式中有11个隐式对象pageContext：获取jsp其他八个内置对象${pageContext.request.contextPath}：动态获取虚拟目录 JSTL基本概念 概念：JavaServer Pages Tag Library JSP标准标签库 是由Apache组织提供的开源的免费的jsp标签 &lt;标签&gt; 作用：用于简化和替换jsp页面上的java代码 使用步骤： 导入jstl相关jar包 引入标签库：taglib指令： &lt; %@ taglib %&gt; 使用标签常用的JSTL标签 if:相当于java代码的if语句 属性： test 必须属性，接受boolean表达式 如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容 一般情况下，test属性值会结合el表达式一起使用 注意： c:if标签没有else情况，想要else情况，则可以在定义一个c:if标签 choose:相当于java代码的switch语句 使用choose标签声明 相当于switch声明 使用when标签做判断 相当于case 使用otherwise标签做其他情况的声明 相当于default foreach:相当于java代码的for语句]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie-Session]]></title>
    <url>%2F2019%2F10%2F12%2FCookie-Session%2F</url>
    <content type="text"><![CDATA[会话技术 会话：一次会话中包含多次请求和响应。 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止 功能：在一次会话的范围内的多次请求间，共享数据 方式： 客户端会话技术：Cookie 服务器端会话技术：SessionCookie：基本原理及操作 概念：客户端会话技术，将数据保存到客户端 快速入门： 创建Cookie对象，绑定数据 new Cookie(String name, String value) 发送Cookie对象 response.addCookie(Cookie cookie) 获取Cookie，拿到数据 Cookie[] request.getCookies() 实现原理 基于响应头set-cookie和请求头cookie实现 cookie的细节 一次可不可以发送多个cookie? 可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。 cookie在浏览器中保存多长时间？ 默认情况下，当浏览器关闭后，Cookie数据被销毁 持久化存储： setMaxAge(int seconds) seconds正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效 seconds负数：默认值 seconds零：删除cookie信息 cookie能不能存中文？ 在tomcat 8 之前 cookie中不能直接存储中文数据。 需要将中文数据转码—一般采用URL编码(%E3) 在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析 cookie共享问题 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？ 默认情况下cookie不能共享 setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录 如果要共享，则可以将path设置为”/“ 不同的tomcat服务器间cookie共享问题？ setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享 setDomain(“.baidu.com”),那么tieba.baidu.com和news.baidu.com中cookie可以共享 Cookie的特点和作用 cookie存储数据在客户端浏览器 浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个) cookie一般用于存出少量的不太敏感的数据 在不登录的情况下，完成服务器对客户端的身份识别 Session概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession 基本使用 获取HttpSession对象： HttpSession session = request.getSession(); 使用HttpSession对象： Object getAttribute(String name) void setAttribute(String name, Object value) void removeAttribute(String name) 原理 Session的实现是依赖于Cookie的。 细节： 当客户端关闭后，服务器不关闭，两次获取session是否为同一个？默认情况下。不是。 如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。 Cookie c = new Cookie(“JSESSIONID”,session.getId());c.setMaxAge(60*60);response.addCookie(c); 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？ 不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作 session的钝化： 在服务器正常关闭之前，将session对象系列化到硬盘上 session的活化： 在服务器启动后，将session文件转化为内存中的session对象即可。 session什么时候被销毁？ 服务器关闭 session对象调用invalidate() 。 session默认失效时间 30分钟 选择性配置修改 30 session的特点 session用于存储一次会话的多次请求的数据，存在服务器端 session可以存储任意类型，任意大小的数据 session与Cookie的区别： session存储数据在服务器端，Cookie在客户端 session没有数据大小限制，Cookie有 session数据安全，Cookie相对于不安全]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet学习(response)]]></title>
    <url>%2F2019%2F10%2F08%2FServlet--response%2F</url>
    <content type="text"><![CDATA[Servlet学习(response)response响应消息1. 数据格式： 响应行 组成：协议/版本 响应状态码 状态码描述 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。状态码都是3位数字 。 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码 2xx：成功。代表：200 3xx：重定向。代表：302(重定向)，304(访问缓存) 4xx：客户端错误。 404 （请求路径没有对应的资源） 405：请求方式没有对应的doXxx方法 5xx：服务器端错误。代表：500(服务器内部出现异常) 响应头： 格式：头名称： 值 常见的响应头： Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式 Content-disposition：服务器告诉客户端以什么格式打开响应体数据值：in-line:默认值,在当前页面内打开：attachment;filename=xxx：以附件形式打开响应体。文件下载 响应空行 响应体:传输的数据 1234567891011121314响应字符串格式HTTP/1.1 200 OKContent-Type: text/html;charset=UTF-8Content-Length: 101Date: Wed, 06 Jun 2018 07:08:42 GMT&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello , response &lt;/body&gt;&lt;/html&gt; 2. Response对象1. 设置响应行 格式：HTTP/1.1 200 ok 设置状态码：setStatus(int sc) 2. 设置响应头：setHeader(String name, String value) 3. 设置响应体： 获取输出流 字符输出流：PrintWriter getWriter() 字节输出流：ServletOutputStream getOutputStream() 使用输出流，将数据输出到客户端浏览器 重定向的特点:redirect（ResponseDemo1，ResponseDemo2） response.sendRedirect(contextPath+”/responseDemo2”); 地址栏发生变化 重定向可以访问其他站点(服务器)的资源 重定向是两次请求。不能使用request对象来共享数据 转发的特点：forward 转发地址栏路径不变 转发只能访问当前服务器下的资源 转发是一次请求，可以使用request对象来共享数据 路径写法： 相对路径：通过相对路径不可以确定唯一资源 如：./index.html 规则：找到当前资源和目标资源之间的相对位置关系 ./：当前目录 ../:后退一级目录 绝对路径：通过绝对路径可以确定唯一资源 如：http://localhost/day15/responseDemo2 /day15/responseDemo2 规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出 给客户端浏览器使用：需要加虚拟目录(项目的访问路径) 建议虚拟目录动态获取：request.getContextPath() 如 , 重定向… 给服务器使用：不需要加虚拟目录 如：转发路径 服务器输出字符数据到浏览器 获取字符输出流 PrintWriter pw = response.getWriter(); 输出数据 pw.write(“response”); 乱码问题： PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1 设置该流的默认编码 告诉浏览器响应体使用的编码12//简单的形式，设置编码，是在获取流之前设置response.setContentType("text/html;charset=utf-8"); 服务器输出字节数据到浏览器 获取字节输出流 ServletOutputStream sos = response.getOutputStream(); 输出数据 sos.write(“你好”.getBytes(“utf-8”)); 验证码 本质：图片 目的：防止恶意表单注册 3. ServletContext对象：1. 概念：代表整个web应用，可以和程序的容器(服务器)来通信 2. 获取： 通过request对象获取 request.getServletContext(); 通过HttpServlet获取 this.getServletContext();3. 功能： 获取MIME类型： MIME类型:在互联网通信过程中定义的一种文件数据类型 格式： 大类型/小类型 text/html image/jpeg 获取：String getMimeType(String file) 域对象：共享数据 setAttribute(String name,Object value) getAttribute(String name) removeAttribute(String name) ServletContext对象范围：所有用户所有请求的数据 获取文件的真实(服务器)路径 方法：String getRealPath(String path) String b = context.getRealPath(“/b.txt”);//web目录下资源访问 String c = context.getRealPath(“/WEB-INF/c.txt”);//WEB-INF目录下的资源访问 String a = context.getRealPath(“/WEB-INF/classes/a.txt”);//src目录下的资源访问]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet学习(request)]]></title>
    <url>%2F2019%2F10%2F08%2FServlet--request%2F</url>
    <content type="text"><![CDATA[Servlet学习(request)1. 概念 servlet 是一个接口，定义了java类被浏览器访问到（tomcat）的规则 要定义一个类实现Servlet接口，覆写方法 2. 简单实现 创建javawbe项目 定义一个类，实现Servlet接口 实现接口中的抽象方法 12345678910111213141516171819202122232425262728public class FirstServlet implements Servlet &#123; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; //提供服务的方法 @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; System.out.println("hello Servlet"); &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; &#125;&#125; 配置Servlet 在web目录下的 web.xml中 123456789&lt;!--配置Servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;demol1&lt;/servlet-name&gt; &lt;servlet-class&gt;com.servlet.FirstServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;demol1&lt;/servlet-name&gt; &lt;url-pattern&gt;/demol1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 支持注解配置，可以不需要web.xml 定义一个类，实现servlet 复写方法 在Servlet文件配置(Servletdome1)@WebServlet(“/demo1”) 3. Servlet方法，生命周期 被创建：执行init方法，一次 默认情况下第一次访问时被创建可以配置Servlet创建时机，在web.xml中 123&lt;!-- 1.第一次访问时创建 参数为负数（默认）--&gt;&lt;!-- 2.在服务器启动时创建 参数为正数--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; Servlet 的init方法只执行一次，说明一个servlet在内存中只存在一个对象，多个用户访问时就会存在线程安全问题解决：尽量不要在Servlet中定义成员变量，不要对其修改值 提供服务：执行service方法，可以多次 被销毁：服务器关闭时执行 destroy方法，只执行一次 4. servlet体系结构Servlet –接口 |GenericServlet –抽象类 |HttpServlet –抽象类 GenericServlet（ServletDemo2）将Servlet接口中的方法做了空实现，只将service（）方法作为抽象，不用强制复写其他方法。 HttpServlet（ServletDemo3）对http协议的分装和描述。内部可以判断请求方式是git还是post定义了doGit，doPost方法。 5. Servlet相关配置 urlpartten:Servlet 访问路径（ServletDemo4） 一个servlet可以定义多个访问路径：@WebServlet({“/d1”,”/d2”,”/d3”}) 路径定义规则： /xxx /xx/xx 可以写多层路径，目录结构。也可以 ”/*“ *.do 可以任意.do demo3.do HTTP1. 概念Hyper Text Transfer Protocol 超文本传输协议 传输协议定义了客户端和服务端通信时发送数据的格式2. 特点： 基于TCP/IP的高级协议 默认端口号80 基于请求响应模型的：一次请求对应一次响应 无状态的：每次请求时间相互独立，不能通信数据3. 历史版本 1.0版本：每次请求响应都建立新的连接 1.1版本：每次请求复用连接 4. 请求消息数据格式 请求行 字符串格式 请求方式 请求url 请求协议/版本 GET /hello.html HTTP/1.1 请求头 请求头名称:请求头值 User-Agent: 浏览器告诉服务器，使用的浏览器版本信息，可以在服务器端获取头信息解决兼容问题。 Accept:可以响应格式 Referer:告诉服务器，当前请求从哪里来。可以防止倒链，也可以做统计工作。 请求空行 空行 分隔请求头和请求体 请求体 username = lihaobo 封装POST请求消息的请参数的 整体字符串格式：GET /hello.html HTTP/1.1Host: localhost:8080User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: keep-aliveCookie: JSESSIONID=25666E7EBC25C248EA50AF9412E95EBBUpgrade-Insecure-Requests: 1If-Modified-Since: Thu, 03 Oct 2019 15:24:18 GMTIf-None-Match: W/“243-1570116258304”Cache-Control: max-age=0 username = lihaobo 5. 请求方式Get： 请求参数在请求行中，url中 请求的url长度有限制 不太安全 post： 请求参数在请求体中 url长度无限制 相对安全 6. 请求响应原理 tomcat服务器会更具请求中url路径创建对应的ServletDemo对象。 tomcat会创建request和response对象，request对象中封装请求消息数据。 tomcat将request和response两个对象传递给service方法并且调用service方法。 我们可以操纵request对象获取请求数据消息，通过request对象设置响应消息数据。 服务器给浏览器作出响应之前会从response获取响应消息。 request和response是有服务器创建的 7. request继承体系ServletRequest –接口 | 继承HttpServletRequest –接口 | 实现org.apache.catalina.connector.RequestFacade 类（tomcat） 8. 获取请求数据1. 获取请求行数据 GET /hello.html HTTP/1.1 获取请求方式 ： Get String getMethod() 获取虚拟目录：/ String getContextPath() 获取Servlet路径：/demo2 String getServletPath() 获取 get方式的请求参数 String getQueryString() 获取请求URL： String getRequestURI() /demo2 StringBuffer getRequestURL() HTTP://localhost/demo2 UIL：统一资源定位符 HTTP://localhost/demo2 URI：统一资源标识符 /demo2 获取协议及版本 HTTP/1.1 String getProtocol() 获取客户机的ip地址 String getRemoteAddr()2. 获取请求头数据 String getHeader(String name)通过请求头的名称获取值Enumeration &lt; String&gt; getHeaderNames() 获取请求头名称 123456789//获取所有请求头Enumeration&lt;String&gt; headerNames = request.getHeaderNames() ;//遍历while(headerNames.hasMoreElements())&#123; String name = headerNames.nextElement(); //根据名称访问请求头的值 String valus = request.getHeader(name); System.out.println(name + "--" + value);&#125; 3. 获取请求体数据只有POST请求方式才有请求体 获取流对象 BufferdReader gitReader(): 获取字符输入流 SerletInputStream getInputStream(): 获取字节输入流，可操作性所有类型数据。 从流数据中取数据 4. 其他功能（重要） 获取请求参数（通用方式） （ServletDemo5） String getParameter(String name) 根据参数名称获取参数值例如：username = lihaob 传递username就可返回 lihaob String getParametervalues(String name) 更具请求参数名获取参数值的数组例如：hobby=xx&amp;hobby=game,则可以将这两个值封装为数组 Enumeration&lt; String &gt; getParameterNames() :获取所有请求的参数名 Map&lt; String, String[]&gt; getParameterMap(): 获取所有参数的map集合 解决中文乱码问题get方式：已经解决了乱码问题post方式：在获取参数前要设置编码 req.setCharacterEncoding(“utf-8”); 请求转发(ServletDemo6,7) 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path) 使用RequestDispatcher对象进行转发：forward(ServletRequest req, ServletResponse resp) 特点： 1.1 浏览器地址栏路径不变化 1.2 只能转发到服务器内部资源中 1.3 只是发送了一个请求，访问了多个资源 共享数据 域对象：一个有作用范围的对象，可以在范围内共享数据。 request域：一次请求的范围，刚才的转发就是一次请求，一般用于请求转发的多个资源中共享数据。 方法： void setAttribute(String name， Object obj);存储数据 object getAttribute(String name); 通过建获取值 void removeAttribute(String name);通过建移除对 获取servletContext： servletContext getservletContext();]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC连接池与Template]]></title>
    <url>%2F2019%2F10%2F05%2FJDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%B8%8ETemplate%2F</url>
    <content type="text"><![CDATA[jdbc连接池与Template数据库连接池 概念：其实就是一个容器(集合)，存放数据库连接的容器。当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。 好处：1. 节约资源 2. 用户访问高效 C3P0：数据库连接池技术。Druid：数据库连接池实现技术，由阿里巴巴提供。 c3p0数据库连接池 导入jar包 c3p0-0.9.5.2.jar 2. mchange-commons-java-0.2.12.jar 定义配置文件c3p0-cnfig.xml 在定义配置文件时，也要注意版本问题，可直接放在src目录下 创建数据库连接池对象ComboPooledDataSource() DataSource ds = new ComboPooledDataSource(); 获取连接gitConnection Connection conn = ds.getConnection(); Druid数据库连接池 导入jar包 druid-1.0.9.jar 定义配置文件： 是properties形式的 可以叫任意名称，可以放在任意目录下 加载配置文件。Properties 123InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream("druid.properties");Properties pro = new Properties();pro.load(is); 获取数据库连接池对象：通过工厂来来获取 DruidDataSourceFactory并 1DataSource ds = DruidDataSourceFactory.createDataSource(pro); 获取连接：getConnection 1Connection conn = ds.getConnection(); 定义Druid数据库连接池工具类JDBCUtils 提供静态代码块加载配置文件，初始化连接池对象 获取连接方法：通过数据库连接池获取连接 释放资源 获取连接池的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class JDBCUtils &#123; //定义一个成员变量 private static DataSource ds = null;; static &#123; try &#123; //1.加载配置文件 Properties pro = new Properties(); pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream("Druid.properties")); //获取获取数据库连接池对象dataSource ds = DruidDataSourceFactory.createDataSource(pro); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取连接 */ public static Connection getConnection() throws SQLException &#123; return ds.getConnection(); &#125; /** * 释放资源 */ public static void close(Statement statement, Connection connection) &#123; close(null,statement,connection); &#125; public static void close(ResultSet resultSet, Statement statement, Connection connection)&#123; if (resultSet != null)&#123; try &#123; resultSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (statement != null)&#123; try &#123; statement.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (connection != null)&#123; try &#123; connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 获取连接池方法 */ public static DataSource getDataSource()&#123; return ds; &#125;&#125; Spring JDBC是Spring框架对jdbc的简单封装，提供了JDBCTemplate对象简化jdbc开发 导入jar包 创建JDBCTemplate对象，依赖于数据源DataSource JDBCTemplate template = new JDBCTemplate（ds）； 调用JDBCTemplate方法操作 update() 方法，执行增删改语句 queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合，查询的结果集长度只能是1。 123456public void test4()&#123; String sql = "select * from emp where id = ? or id = ?"; Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002); System.out.println(map); //&#123;id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20&#125;&#125; queryForList():查询结果将结果集封装为list集合 将每一条记录封装为一个Map集合，再将Map集合装载到List集合中12345678public void test5()&#123; String sql = "select * from emp"; List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql); for (Map&lt;String, Object&gt; stringObjectMap : list) &#123; System.out.println(stringObjectMap); &#125;&#125; query():查询结果，将结果封装为JavaBean对象,emp为自定义的对象有成员变量，getset函数以及tostring方法。 12345678910111213141516171819202122232425262728293031323334public void test6()&#123; String sql = "select * from emp"; List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() &#123; @Override public Emp mapRow(ResultSet rs, int i) throws SQLException &#123; Emp emp = new Emp(); int id = rs.getInt("id"); String ename = rs.getString("ename"); int job_id = rs.getInt("job_id"); int mgr = rs.getInt("mgr"); Date joindate = rs.getDate("joindate"); double salary = rs.getDouble("salary"); double bonus = rs.getDouble("bonus"); int dept_id = rs.getInt("dept_id"); emp.setId(id); emp.setEname(ename); emp.setJob_id(job_id); emp.setMgr(mgr); emp.setJoindate(joindate); emp.setSalary(salary); emp.setBonus(bonus); emp.setDept_id(dept_id); return emp; &#125; &#125;); for (Emp emp : list) &#123; System.out.println(emp); &#125; &#125; query的参数：RowMapper 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装 new BeanPropertyRowMapper&lt;类型&gt;(类型.class)，如果类型.class中的参数和数据库匹配，那么就会自动封装。1234567public void test6_2()&#123; String sql = "select * from emp"; List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class)); for (Emp emp : list) &#123; System.out.println(emp); &#125; &#125; queryForObject：查询结果，将结果封装为对象，一般用于聚合函数查询 12345public void test7()&#123; String sql = "select count(id) from emp"; Long total = template.queryForObject(sql, Long.class); System.out.println(total);&#125;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC基本概念与操作]]></title>
    <url>%2F2019%2F10%2F05%2FJDBC%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[jdbc基本概念与操作jdbc：Java DataBase Connectivity Java 数据库连接本质：其实是官方定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。 1. 导入驱动jar包2. 注册驱动在注册驱动时，新版jdbc注册驱动的语句要在中间加上cj。 1Class.forName("com.mysql.cj.jdbc.Driver"); 3. 获取数据库连接对象 Connection1Connection connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/workstation?characterEncoding=UTF-8&amp;serverTimezone=UTC&amp;useSSL=false", "root", "123456"); DriverManager：驱动管理对象 注册驱动功能：告诉程序该使用那个数据库驱动jar包 Class.forName(“com.mysql.jdbc.Driver”); 获取数据库连接： static Connection getConnection(String url, String user, String password) url配置：jdbc:mysql://ip地址(域名):端口号/数据库名称 jdbc:mysql://localhost:3306/workstation?characterEncoding=UTF-8&amp;serverTimezone=UTC&amp;useSSL=false Connection：数据库连接对象 可以获取执行sql的对象Statement Statement createStatement() PreparedStatement prepareStatement(String sql) 管理事务 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 提交事务：commit() 回滚事务：rollback() 在获取数据库连接对象时，应为使用了最新版mysql的jdbc驱动，在看视频时按照原本的配置方法配置url值，不断报下面的错，在百度了半下午以后才找到问题所在，旧版本可以“jdbc:mysql://localhost:3306/db3”但新版本必须配置为上面的内容。 1Exception in thread &quot;main&quot; java.sql.SQLException: The server time zone value is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support. 4. 获取执行sql语句的对象 Statement1Statement statement = connection.createStatement(); Statement: 执行sql的对象 boolean execute(String sql) ：可以执行任意的sql int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句。返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。 ResultSet executeQuery(String sql) ：执行DQL（select)语句 5. 定义sql并执行sql，接受返回结果12String sql = "update users set Upasswords = '123345567' where number = 2";int i = statement.executeUpdate(sql); 6. 处理结果并释放资源123System.out.println(i);statement.close();connection.close(); 7. ResultSet: 结果集对象,封装查询结果 boolean next(): 游标向下移动一行（默认指向表头行），判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true getXxx(参数):获取数据 Xxx：代表数据类型 如： int getInt() ，String getString() 参数： int：代表列的编号,从1开始 如： getString(1) String：代表列名称。 如： getDouble(“balance”) 12345678//循环判断游标是否是最后一行末尾。while(rs.next())&#123;、//获取数据int id = rs.getInt(1);//当前行第一列String name = rs.getString("name");//当前行“name”列double balance = rs.getDouble(3);System.out.println(id + "---" + name + "---" + balance);&#125; 8. PreparedStatement：执行sql的对象 SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题 解决sql注入问题：使用PreparedStatement对象来解决 使用： sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?; 获取执行sql语句的对象 PreparedStatement Connection.prepareStatement(String sql) 给？赋值：setXxx(参数1,参数2) 执行sql，接受返回结果，不需要传递sql语句123456789//定义SQLString sql = "update users set Upasswords = ? where number = ?";//获取pstmt对象preparedStatement = conn.prepareStatement(sql);//给SQL赋值preparedStatement.setInt(1, 123);preparedStatement.setInt(2, 2);//执行int cont = preparedStatement.executeUpdate();]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构--链表（静态链表）]]></title>
    <url>%2F2019%2F10%2F02%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E9%93%BE%E8%A1%A8%EF%BC%88%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据结构–链表（静态链表） 静态链表中，应为没有指针使用，所以我们用一个结构体数组来存放节点，用cur来代替指针，存放下一个元素在结构体数组中的位置。 在建立链表时，我们把这个结构体数组看成两个链，一个是没有存放内容的备用链，一个是存放了内容的使用链，同样的我们确定一个头结点data不存放数据，cur存放的是下一个可插入元素的节点位置，初始化为1，为备用链的头，确定一个尾节点，data也不存放数据，cur存放的是第一个存放了数据的节点的位置，为使用链的头。 这样定义的好处是：其一，当链表中间有元素被删除时，备用链头cur值存放中间被删节点的位置，这样下次插入就可以直接在此插入。所以删除节点时可以不移动其他元素，下次插入只需要在备用链依次取就好。 其二，用最后一个位置存放使用链的头，是防止当结构体数组中第一个节点被删去，会丢失头节点位置，通过这个保存则可以随意删除。 静态链表中存放的数据彼此之间是非线性不连续的，是通过cur代替指针将其联系起来。 优点：再插入和删除时候，只需要修改游标，不需要移动元素，从而改进了顺序存储结构中插入和删除操作需要移动大量元素的缺点。 缺点：没有解决连续存储分配带来的表长难以确定的问题；失去了顺序存储结构随机存取的特性。下面是具体实现过程 1. 结构体定义123456#define MAXSIZE 7//定义结构typedef struct&#123; int data;//数据域 int cur;//下一个节点的下标&#125;StaticList[MAXSIZE]; 2. 初始化静态链表123456789101112//初始化静态链表,主要任务是让每一个节点cur指向下一个节点void InitList(StaticList l)&#123; for (int i = 0; i &lt; MAXSIZE - 1; i++) &#123; l[i].cur = i + 1; &#125; //备用链表的最后一个空元素的cur指向0，这样才可以再分配节点时判断是否已经存满 l[MAXSIZE - 2].cur = 0; //最后一个节点是使用链的头结点，初始化为0； l[MAXSIZE - 1].cur = 0;&#125; 3. 寻找可用空间1234567891011//在插入元素时，为带插入元素寻找一个空间下标int Malloc(StaticList l)&#123; //l[0].cur代表下一个可以插入的位置 int i = l[0].cur; if (i)&#123;//如果位置是0则不能插入 //位置不是0，则在此位置插入，并且将其下一个位置赋给头 l[0].cur = l[i].cur; &#125; return i;&#125; 4. 删除元素释放空间12345678//删除元素时，将其位置保存，方便下次插入void Free(StaticList l, int k)&#123; //将头中保存的下个可插入节点的位置赋给此待删除节点 l[k].cur = l[0].cur; //将次待删除节点位置赋给头，通过这两部操作将此节点放入了待插入链 l[0].cur = k;&#125; 5. 静态链表中元素个数1234567891011121314//求静态链表中元素个数，不包括头尾节点int ListLength(StaticList L)&#123; //L[MAXSIZE - 1]是已用链的头结点，.cur是已用链第一个节点位置 int i = L[MAXSIZE - 1].cur; int j = 0; while (i) &#123; j++; //不断查找到下一个已用链，最后一个已用链cur值为0 i = L[i].cur; &#125; return j;&#125; 6. 在i位置插入元素12345678910111213141516171819202122232425//静态链表中i位置插入一个元素void lnsertList(StaticList L, int i, int data)&#123; //判断插入点是否合理,要按照顺序插入不能跳跃插入 if (i&lt;1 || i&gt;ListLength(L) + 1) &#123; printf("插入点不合理"); return; &#125; int j = Malloc(L);//分配到插入位置 int k = MAXSIZE - 1;//k表示已用链头结点 if (j) &#123; //循环让k指向待插入位置i的已用链中前一个位置 for (int l = 1; l &lt;= i - 1; l++) &#123; k = L[k].cur; &#125; L[j].data = data; //将新节点与上一个节点连接 L[j].cur = L[k].cur; //将新节点与下一个节点连接 L[k].cur = j; &#125;&#125; 7. 删除第i个元素123456789101112131415161718192021222324//删除第i个元素，将值放入data中void DeleteList(StaticList L, int i, int *data)&#123; if (i &lt; 1 || i &gt;= ListLength(L)) &#123; printf("删除位置不合法"); return; &#125; //k指向已用链头结点 int k = MAXSIZE - 1; //循环让k指向已用链中k待删除节点的上一个节点 for (int l = 1; l &lt;= i - 1; l++) &#123; k = L[k].cur; &#125; //j指向待删除节点 int j = L[k].cur; *data = L[j].data; //将上一个节点与下一个节点相连 L[k].cur = L[j].cur; //将本节点置空加入备用链 Free(L, j);&#125; 8. 输出链表12345678910111213//输出链表void printList(StaticList L)&#123; //k指向已用链头结点 int k = MAXSIZE - 1; //已用链的cur不为0时输出 while (L[k].cur) &#123; k = L[k].cur; printf("%d ", L[k].data); &#125; printf("\n");&#125; 9. 主函数1234567891011121314151617181920212223242526int main(void)&#123; StaticList L; int j = 0; int data; InitList(L); printf("输入元素，以-1结尾\n"); while (1) &#123; scanf("%d", &amp;data); if (data != -1) &#123; j++; lnsertList(L, j, data); &#125; else &#123; break; &#125; &#125; printList(L); DeleteList(L, 2, &amp;data); printf("删除的元素值为 %d\n", data); printList(L); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构--链表（循环链表和双向链表）]]></title>
    <url>%2F2019%2F09%2F27%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E9%93%BE%E8%A1%A8%EF%BC%88%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E5%92%8C%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据结构–链表（循环链表和双向链表）一、循环链表 循环链表和单链表不同的是，他的尾节点的指针指向了头节点，这样在一些很多操作中，就不怕丢失头节点，即使指针指向的是中间节点，也可以通过移动找到头节点以及此节点以前的节点。 在建立循环链表时，可以使用一个空余的节点做头节点，不存储数据，这样会使增删操作方便的多，不用考虑删除的或者增加的是第一个节点而要改变尾指针。以下是具体实现操作1. 循环链表定义12345678/*定义循环链表结构* 其中结构体变量Node 用来定义链表节点* 结构体指针LinkList 用来定义头结点*/typedef struct Node&#123; int data; struct Node * next;&#125;Node, *LinkList; 2. 循环链表初始化1234567//初始化void InitList(LinkList * l)&#123; *l = (LinkList)malloc(sizeof(Node)); (*l)-&gt;next = *l;//将尾节点的指针域指向头结点 (*l)-&gt;data = NULL;//将头结点的Data域赋为空，借此区分头结点和其他节点&#125; 3. 循环链表尾插法建立12345678910111213141516171819202122//尾插法建立新链表，当输入值为-1时停止输入void creatList(LinkList l)&#123; int data; Node * s;//申明一个新建节点 Node * r = l;//申明一个移动节点 while (true) &#123; scanf("%d", &amp;data); if (data != -1) &#123; s = (Node *)malloc(sizeof(Node)); s-&gt;data = data; r-&gt;next = s; //修改指针 s-&gt;next = l; r = r-&gt;next; &#125; else&#123;//判断当输入值为-1时停止输入 break; &#125; &#125;&#125; 4. 循环链表插入节点123456789101112131415161718192021222324252627282930//在i位置插入值为Data的节点void InsertNode(LinkList l, int i, int data)&#123; Node * r = l;//查找指向待插入位置 Node * p = l;//指向待插入节点前的节点 Node * s;//指向新建的节点 int j = 0; if (i &lt;= 0)//判断插入位置 &#123; printf("插入位置小于1"); return; &#125; //移动p节点，p节点是待删除节点的前一个节点 while (p-&gt;next-&gt;next != l &amp;&amp; j != i - 1) &#123; p = p-&gt;next; j++; &#125; r = p-&gt;next; if (r == l)//插入位置大于链表长度 &#123; printf("找不到待插入位置"); return; &#125; //新建节点并插入 s = (Node *)malloc(sizeof(Node)); s-&gt;data = data; p-&gt;next = s; s-&gt;next = r;&#125; 5. 循环链表删除节点123456789101112131415161718192021222324252627void deleteList(LinkList l, int i)&#123; Node * r = l;//查找指向待删除节点 Node * p = l;//指向待节点节点前的节点 int j = 0; if (i &lt;= 0)//判断删除位置 &#123; printf("删除位置小于1"); return ; &#125; //移动p节点，p节点是待删除节点的前一个节点 while (p-&gt;next-&gt;next != l &amp;&amp; j != i - 1) &#123; p = p-&gt;next; j++; &#125; r = p-&gt;next; if (r == l)//删除位置大于链表长度 &#123; printf("找不到待删除节点"); return; &#125; //应为有头结点，位置为0，不在删除范围之内所以可以直接删除， //不会影响头结点和尾指针 p-&gt;next = r-&gt;next; free(r);&#125; 6. 循环链表查找12345678910111213141516171819202122//查找节点，查找第i个节点Node * gitNode(LinkList l, int i)&#123; Node * r = l;//指向待查找节点 int j = 0; if (i &lt;= 0)//判断插入位置 &#123; printf("查找位置小于1"); return NULL; &#125; while (r-&gt;next != l &amp;&amp; j != i) &#123; r = r-&gt;next; j++; &#125; if (r == l)//插入位置大于链表长度 &#123; printf("找不到待查找节点"); return NULL; &#125; return r;//将查找到了节点返回&#125; 7. 循环链表输出123456789101112131415/*输出链表* 应为是循环链表，所以不用担心丢失头结点，* 且在定义头结点时将其data域赋值为NULL做了标记* 所以在循环时可以直接循环头指针l，*/void printList(LinkList l)&#123; l = l-&gt;next;//直接开始移动l指针 while (l-&gt;data != NULL)//判断是否循环一圈回到头结点 &#123; printf("%d ", l-&gt;data); l = l-&gt;next; &#125; printf("\n");&#125; 8. 主函数123456789101112131415int main(void)&#123; LinkList l; Node * s; InitList(&amp;l);//初始化链表 creatList(l);//建立新链表 printList(l); InsertNode(l, 3, 5);//在3位置插入值5 printList(l); deleteList(l, 2);//删除2节点 printList(l); s = gitNode(l, 4);//查找4节点 printf("%d", s-&gt;data); return 0;&#125; 二、双向链表双向链表相比于普通链表，每个节点增加了一个指向前一个节点的指针，如此则可以很方便的找到一个节点的前驱节点，在进行修改指针操作时，不再需要一个指向前驱节点的指针。同样的在双向链表中，为了算法方便，也使用一个空余的节点作为头结点,在初始化时定义。 1.双向链表结构体定义1234567//双向链表结构体//定义结构体类型Node，和结构体指针类型LinkListtypedef struct Node&#123; int data;//数据域 struct Node * piror;//指向前节点指针 struct Node * next;//指向后节点指针&#125;Node, *LinkList; 2.双向链表初始化123456789//双向链表初始化，传入的是头指针l的地址void initList(LinkList * l)&#123; (*l) = (Node *)malloc(sizeof(Node)); //一定要将尾节点指针域赋空，在以后移动指针判断操作才不会出现空指针异常 (*l)-&gt;next = NULL;//后指针指空 (*l)-&gt;piror = NULL;//前指针指空 (*l)-&gt;data = NULL;//将其data域赋为空，可区分头结点&#125; 3.建立新的双向链表12345678910111213141516171819202122232425//建立新链表，输入要插入的内容，以-1结束void creatFormTail(LinkList l)&#123; Node * r = l;//移动的指针 Node * s;//指向新建的节点 int c;//新节点data域 int flag = 1; while (flag) &#123; scanf("%d", &amp;c); if (c != -1) &#123; s = (Node*)malloc(sizeof(Node)); s-&gt;data = c; s-&gt;next = r-&gt;next;//新节点的后指针赋空 s-&gt;piror = r; r-&gt;next = s; r = r-&gt;next; &#125; else &#123; flag = 0; &#125; &#125;&#125; 4.双向链表插入操作在插入操作时，就可以体现出双向链表的优势，只需要一个指针指向待插入位置，通过r-&gt;piror就可以完成插入操作 1234567891011121314151617181920212223242526272829303132//在循环链表l的第i个元素前插入一个节点void lnslist(LinkList l, int i, int data)&#123; Node * r, *s; int j = 0; r = l; //首先判断插入位置是否合法 if (i &lt;= 0) &#123; //插入位置小于1 printf("查找序号不合法"); return NULL; &#125; //寻找插入位置 while ((r != NULL) &amp;&amp; j&lt;i) &#123; r = r-&gt;next; j++; &#125; if (r == NULL) &#123; //插入位置大于链表长度 printf("查找序号不合法"); return NULL; &#125; s = (Node *)malloc(sizeof(Node)); s-&gt;data = data; s-&gt;piror = r-&gt;piror;//插入节点前指针指向前一节点 r-&gt;piror-&gt;next = s;//插入节点前一节点后指针指向插入节点 s-&gt;next = r;//插入节点与后节点双向联通 r-&gt;piror = s;&#125; 5. 删除双向链表节点同样在删除中，也只需要一个指针就可以完成操作 1234567891011121314151617181920212223242526272829//删除第i个元素，并将该元素内容存入data中void deleteList(LinkList l, int i, int * data)&#123; Node * r = l; int j = 0; if (i &lt;= 0) &#123; //删除位置小于1 printf("查找序号不合法"); return NULL; &#125; //寻找删除位置 while (r != NULL &amp;&amp; j &lt; i) &#123; r = r-&gt;next; j++; &#125; if (r == NULL) &#123; //删除位置大于链表长度 printf("查找序号不合法"); return NULL; &#125; //修改指针删除 r-&gt;piror-&gt;next = r-&gt;next;//使前一个节点尾指针指向后一个节点 r-&gt;next-&gt;piror = r-&gt;piror;//使后一个节点的头指针指向前一个节点 *data = r-&gt;data; free(r);&#125; 6. 复制链表1234567891011121314151617181920//链表复制,返回复制后链表LinkList cloneList(LinkList l)&#123; Node * r = l-&gt;next;//定义一个指向原链表的移动指针 Node * p;//定义一个指向新链表的移动指针 LinkList s, l2;//s指向是新建立的节点，l2为新链表的头指针 initList(&amp;l2); p = l2;//将p指向头，方便尾插法建表 while (r != NULL) &#123; s = (Node *)malloc(sizeof(Node)); s-&gt;data = r-&gt;data;//给新节点复制值 r = r-&gt;next;//指向原链表下一个待复制位置 s-&gt;next = p-&gt;next;//新节点的后指针赋空 s-&gt;piror = p; p-&gt;next = s; p = p-&gt;next;//p指向新最新节点 &#125; return l2;&#125; 7. 链表输出及主函数1234567891011121314151617181920212223242526//链表输出void printList(LinkList l)&#123; Node * r = l-&gt;next; while (r != NULL) &#123; printf("%d ", r-&gt;data); r = r-&gt;next; &#125; printf("\n");&#125;//主函数int main(void)&#123; LinkList l; Node * s; int data; initList(&amp;l); creatFormTail(l);//建立链表 printList(l); deleteList(l, 2, &amp;data);//删除链表元素 printList(l); s = cloneList(l);//复制l链表 printList(s); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构--链表（单链表）]]></title>
    <url>%2F2019%2F09%2F26%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E9%93%BE%E8%A1%A8%EF%BC%88%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据结构–链表（单链表）从今天开始，工作室统一开始复习算法，明年蓝桥杯都进国赛哈哈哈。去年蓝桥杯的国赛还是有些遗憾，今年一定要好好学学，拿个国二。 链表是数据结构中最基础的存储结构。相比于数组，他是动态的，不论从存储内容还是存储长度来说都是动态的。可以借此延伸出其他很多数据结构。 对以下程序的变量说明：Node 结构体变量，一般用来定义节点；LinkList结构体指针，一般用来定义头节点；l一般用来指向头结点，引导整个链表；s，r一般用于操作过程中用来移动的指针。 1. 链表基本结构体的定义：123456//定义结构体typedef struct Node&#123; int data; struct Node * next;&#125;Node, *LinkList;//一个结构体类型的Node，一个指向结构体类型的指针变量 LinkList~ 其中定义两个变量，一个结构体类型的Node，一个指向结构体类型的指针变量 LinkList,在后续的算法中，这两者作用基本相同，LinkList用来申明头指针，Node * 用来申明节点指针，方便区分。 2. 链表初始化1234567//初始化InitList(LinkList * l)&#123; //分配头结点 *l = (LinkList)malloc(sizeof(Node)); (*l)-&gt;next = NULL; //让头节点next域为空&#125; 初始化链表的操作使用了二重指针，应为要头结点l是在主函数申明好的，在初始化函数中要改变指针的值，就需要二重指针，用LinkList * 申明。 3. 头插法建立新链表123456789101112131415161718192021222324//头插法建表，依次输入想要插入的值，以-1结束void CreatFormHead(LinkList l)&#123; Node * s; int c; int flag = 1; while (flag)//循环标记 &#123; scanf("%d", &amp;c); if (c != -1) &#123; //建立一个新节点 s = (Node*)malloc(sizeof(Node)); //修改指针 s-&gt;data = c; s-&gt;next = l-&gt;next; l-&gt;next = s; &#125; else &#123; flag = 0; &#125; &#125;&#125; 此方法在建立链表时，始终从头结点后面插入新的节点，所以插入以后可以将输入逆序。修改指针顺序为先修改新增节点的指针指向头结点的下一个节点，再让头结点指向新增节点。 4.尾插法建立新链表12345678910111213141516171819202122232425//尾插法建表,与头插法类似，不过此方法建表为正序void CreatFormTail(LinkList l)&#123; Node * s; //尾插需要有一个移动的指针，为了不丢失头结点则新定义一个指针r Node * r = l; int c; int flag = 1; while (flag) &#123; scanf("%d", &amp;c); if (c != -1) &#123; s = (Node*)malloc(sizeof(Node)); s-&gt;data = c; r-&gt;next = s; r = r-&gt;next; &#125; else &#123; flag = 0; &#125; r-&gt;next = NULL; &#125;&#125; 此方法建立新链表时，是从链表节点的尾部新增节点，所以插入的顺序是正序。应为要保留头结点，所以尾插法还需借用一个行的指针变量r为移动的指针。 5.查找操作5.1 按照元素值key查找123456789101112131415161718192021222324252627282930//按数值key查找节点，将查找到的节点返回Node * locate(LinkList l, int key)&#123; //定义一个可以移动的指针 Node * r = l; while (r-&gt;data != key) &#123; r = r-&gt;next; if (r == NULL) &#123; //key值不存在链表中 printf("查找不到相应值"); return NULL; &#125; &#125; return r;&#125;Node * locate(LinkList l, int key)&#123; Node * r = l; while (r-&gt;data != key) &#123; r = r-&gt;next; if (r == NULL) &#123; printf("查找不到相应值"); return NULL; &#125; &#125; return r;&#125; 5.1 按照顺序查找第i个12345678910111213141516171819202122232425//按序号i(第i个)查找，将查找到的节点返回Node * getNode(LinkList l, int i)&#123; Node * r = l; int j = 0; if (i &lt;= 0) &#123; //查找位置小于1 printf("查找序号不合法"); return NULL; &#125; while (r != NULL || j &lt;= i) &#123; r = r-&gt;next; j++; &#125; if (r == NULL) &#123; //查找位置大于链表长度 printf("查找值不合理"); return NULL; &#125; else return r;&#125; 查找操作时要注意查找位置是否合法，则要进行多次判断 6.删除节点删除第i个元素，并将该元素内容存入 data中 123456789101112131415161718192021222324252627282930//删除第i个元素，并将该元素内容存入data中void DeleteList(LinkList l, int i, int * data)&#123; Node * r = l; Node * p = l; int j = 0; if (i &lt;= 0) &#123; //删除位置小于1 printf("查找序号不合法"); return NULL; &#125; //寻找删除位置 while (p != NULL &amp;&amp; j &lt; i - 1) &#123; p = p-&gt;next; j++; &#125; if (p == NULL) &#123; //删除位置大于链表长度 printf("查找序号不合法"); return NULL; &#125; //修改指针删除 r = p-&gt;next; p-&gt;next = r-&gt;next; data = &amp;(r-&gt;data); free(r);&#125; 删除操作时，先按照查找操作找到相应位置，再移动指针，删除以后要将空间free掉。值得注意的是次过程需要两个指针，一个（p指针）指向待删除节点前的节点，另一个（r)指针指向待删除元素。 7. 在链表第i个元素前插入一个元素123456789101112131415161718192021222324252627282930//在单链表l的第i个元素前插入一个节点void lnslist(LinkList l, int i, int idata)&#123; Node * pre, *s; int j = 0; pre = l; //首先判断插入位置是否合法 if (i &lt;= 0) &#123; //插入位置小于1 printf("查找序号不合法"); return NULL; &#125; //寻找插入位置 while ((pre != NULL) &amp;&amp; (j&lt;i - 1)) &#123; pre = pre-&gt;next; j++; &#125; if (pre == NULL) &#123; //插入位置大于链表长度 printf("查找序号不合法"); return NULL; &#125; s = (Node *)malloc(sizeof(Node)); s-&gt;data = idata; s-&gt;next = pre-&gt;next; pre-&gt;next = s;&#125; 此操作是将查找与头插法相结合的应用。 8.计算链表长度并输出123456789101112131415161718192021222324//计算链表长度int listlength(LinkList l)&#123; Node * p; int j = 0; p = l-&gt;next; while (p != NULL) &#123; p = p-&gt;next; j++; &#125; return j;&#125;//链表输出void PrintList(LinkList l)&#123; Node * r = l-&gt;next; while (r-&gt;next != NULL) &#123; printf("%d ", r-&gt;data); r = r-&gt;next; &#125; printf("%d", r-&gt;data);&#125; 9.链表合并9.1将两个增有序的链表合成一个减有序的链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//链表合并,将两个增有序的链表合成一个减有序的链表LinkList MergeList(LinkList l1, LinkList l2)&#123; Node * s; Node * temp; //首先用其中一个链表头结点作为新链表头结点 s = l1; l1 = l1-&gt;next; s-&gt;next = NULL; //定义一个临时节点，以便头插法建表时移动链表 temp = l2; l2 = l2-&gt;next; free(temp); //l1，l2都指向待比较的节点 while (l1 != NULL &amp;&amp; l2 != NULL) &#123; //选择两者中小的进行插入 if (l1-&gt;data &lt;= l2-&gt;data)&#123; //要先保留l1指针并移动，然后再修改指针 temp = l1; l1 = l1-&gt;next; temp-&gt;next = s-&gt;next; s-&gt;next = temp; &#125; else &#123; temp = l2; l2 = l2-&gt;next; temp-&gt;next = s-&gt;next; s-&gt;next = temp; &#125; &#125; //当一个链表插入结束后，将另一个链表继续使用头插法逐一插入， //以保证建表顺序 if (l1 == NULL) &#123; while (l2 != NULL) &#123; temp = l2; l2 = l2-&gt;next; temp-&gt;next = s-&gt;next; s-&gt;next = temp; &#125; &#125; else &#123; while (l1 != NULL) &#123; temp = l1; l1 = l1-&gt;next; temp-&gt;next = s-&gt;next; s-&gt;next = temp; &#125; &#125; return s;&#125; 此过程中，值得注意的就是（1）在合并过程中，应为一开始将头结点指向了空，且在合并指针变化过程中会使当前节点指针域改变，所以要先有一个temp指针为当前节点修改，l1指针直接指向下一个节点。（2）还有一点就是合并过程中，当一个链表先结束时，另一个链表也要继续头插法插入不能直接插在后面。 9.2 将两个增有序的链表合成一个增有序的链表1234567891011121314151617181920212223242526272829303132333435//将两个增有序的链表合成一个增有序的链表LinkList mergelinklist(LinkList la, LinkList lb)&#123; Node * r, *p, *s; LinkList lc; //与上一个插入类似，先建立头结点 r = la-&gt;next; p = lb-&gt;next; lc = la; lc-&gt;next = NULL; s = lc; while (r-&gt;next != NULL || p-&gt;next != NULL) &#123; //应为是尾插，本来就有移动临时节点，所以和标准尾插一样 if (r-&gt;data &lt;= p-&gt;data) &#123; s-&gt;next = r; s = r; r = r-&gt;next; &#125; else &#123; s-&gt;next = p; s = p; p = p-&gt;next; &#125; &#125; //一方插入结束后，应为用尾插法，所以可以将另一方直接接到新节点后面 if (r-&gt;next != NULL) s-&gt;next = r; else s-&gt;next = p; free(lb); return(lc);&#125; 10.主函数123456789101112131415161718192021222324252627282930int main(void)&#123; LinkList l1; LinkList l2; LinkList s; int data = 0; InitList(&amp;l1); InitList(&amp;l2); printf("请输入第一个链表"); CreatFormTail(l1);//尾插法建表1 PrintList(l1); printf("请输入第二个链表"); CreatFormHead(l2);//头差法建表2 PrintList(l2); printf("\n"); lnslist(l1, 2, 5);//在l1链表第2个位置插入5 PrintList(l1); printf("\n"); DeleteList(l2, 2, &amp;data);//删除元素 printf("%d", data);//输出删除元素 printf("\n"); PrintList(l2); printf("\n"); s = locate(l2, 3);//查找值为3的节点 printf("%d",s-&gt;data); printf("\n"); s = MergeList(l1, l2);//两链表合并 PrintList(s); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-动态规划]]></title>
    <url>%2F2019%2F09%2F25%2F%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[算法篇——动态规划在我看来，动态规划是一种思想，一种解决问题的手段。总的来说就是找到基于当前状态的最优决策。一般通过递归来实现，但与递归不同的，递归有些问题被反复计算多次，但动态规划对每个子问题只计算一次，然后将其保存起来，以后在遇到同样的问题就直接引用，不必直接求解。其重点就是保存以前的状态，通过以前状态推得现有最优态。 例: 数字三角形73 88 1 02 7 4 44 5 2 6 5在上面的数字三角形中寻找一条从顶部到底边的路径，使得路径上所经过的数字之和最大。路径上的每一步都只能往左下或 右下走。只需要求出这个最大和即可，不必给出具体路径。 1. 纯递归解法 单纯用递归很简答就能解决这个问题只用用一个数组 d(i,j)来存储这个数字三角形，用max(i,j)表示从d(i,j)到底边各条路径中最佳数字之和。从d(i,j)出发，下一步只能走d(r+1,j)或者d(r+1,j+1)代码如下 123456789101112131415161718192021222324252627import java.util.Scanner;public class triangle &#123; static int[][] a = new int[100][100]; static int n; public static void main(String[] arge)&#123; Scanner input = new Scanner(System.in); n = input.nextInt(); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; a[i][j] = input.nextInt(); &#125; &#125; System.out.println(sum(0,0)); &#125; static int sum(int i, int j)&#123; int m; if(i == n)&#123; return a[i][j]; &#125; else &#123; int x = sum(i + 1, j); int y = sum(i + 1, j + 1); m = x&gt;y?x:y; return m + a[i][j]; &#125; &#125;&#125; 2. 用记忆递归型的动态规划 如果用上面的单纯递归，一旦数据稍微过大，则会运行超时。应为其中出现了大量的重复计算。此时就需要用到递归的第一个思路，保存每次的值，则可以避免过多的重复。则在每次算出MaxSum值的时候将其保存起来则可以免去重复计算。 1234567891011121314151617181920212223242526272829public class triangle1 &#123; static int[][] a = new int[100][100]; static int n; static int[][] max = new int[100][100]; public static void main(String[] arge)&#123; Scanner input = new Scanner(System.in); n = input.nextInt(); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; a[i][j] = input.nextInt(); max[i][j] = -1; &#125; &#125; System.out.println(sum(0,0)); &#125; static int sum(int i, int j)&#123; if (max[i][j] != -1) return max[i][j]; if(i == n)&#123; return a[i][j]; &#125; else &#123; int x = sum(i + 1, j); int y = sum(i + 1, j + 1); max[i][j] = (x&gt;y?x:y) + a[i][j]; &#125; return max[i][j]; &#125;&#125; 3.递推类型动态规划 上面的方法，虽然可以有效的降低实践复杂度，但是其递归调用要占用大量的堆栈空间，容易早场栈溢出，所以就需要把递归思想转变为递推思想。从最后开始，如下表，倒数第二行的2可以和最后一行的4,5相加，但是和5相加较大，则将7保存下来，以此类推。 30 23 21 20 13 10 7 12 10 10 4 5 2 6 5 12345678910111213141516171819202122public class triangle2 &#123; static int[][] a = new int[100][100]; static int n; static int[][] max = new int[100][100]; public static void main(String[] arge)&#123; Scanner input = new Scanner(System.in); n = input.nextInt(); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; a[i][j] = input.nextInt(); &#125; &#125; for (int i = n-2; i &gt;= 0; i--) &#123; for (int j = 0; j &lt;= i; j++) &#123; int x = a[i+1][j+1] + a[i][j]; int y = a[i+1][j] + a[i][j]; a[i][j] = x&gt;y?x:y; &#125; &#125; System.out.println(a[0][0]); &#125;&#125; 则不难总结出递归到动态规划的一般转化方法：构造一个数组，数组元素的值是递归函数返回值，数组下标值是递归函数参数。从边界开始填充数组。 总结：动态规划的一般解题思路 将原问题分解为若干小问题，将子问题求出后保存，每个子问题只求解一次 保存状态，一般通过一个数组作为状态空间 确定初始状态 确定状态转移方程例如数字三角形12MaxSum[i][j] = a[i][j] (i=n)MaxSum[i][j] = max(MaxSum[i+1][j] + MaxSum[i+1][j+1]) (i!=n)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github学习]]></title>
    <url>%2F2019%2F09%2F19%2Fgithub%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[github基本操作 初始化 git init 状态查看 git status 添加到暂存区 git add 提交到本地库 git commit -m 查看历史 git log / git –online / git reflog 版本前进或后退 git reset –hard &lt;索引值&gt; / git reset –hard HEAD~2 比较工作区与暂存区文件差异 git diff [文件名] 将工作区与本地库文件比较 git diff [本地库历史版本（HEAD）] [文件名] 分支管理 创建分支 git branch [分支名] 查看分支 git branch -v 切换分支 git checkout [分支名] 合并分支 git merge [分支名] 解决冲突 git add git commit -m 远程库操作 创建远程库地址别名 git remote add [远程库地址]git remote add origin git@github.com:xiasf/github-note.git 查看别名 git remote -v 推送 git push [远程库地址名] [分支名] 克隆 git clone [远程库地址名] 拉取 git pull [远程库地址名] [远程库分支] 抓取 git fetch [远程库地址名] [远程库分支] 合并 git merge [远程库地址名/远程库分支] 跨团队合作 团队2进入团队1项目目录,点击fork。 团队2 git clone &lt;远程地址&gt;，修改并commit，git push 提交到远程库。 团队2进入页面，点击 pull requests、 new pull requests， Create pull requests 然后发消息给团队1。 团队1点击pull requests，Commits 、files changed 代码审核。 如果没有问题 则点击 merge pull request 并添加-m信息，结束远程库修改。 团队1将远程库拉取到本地 git pull origin master。]]></content>
      <categories>
        <category>基础知识学习</category>
      </categories>
      <tags>
        <tag>git学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客搭建]]></title>
    <url>%2F2019%2F09%2F19%2Fhexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[hexo博客搭建一、博客基本操作 博客部署到本地 hexo clean 清楚缓存hexo g 生成静态网页hexo s 本地启动预览查看 http://localhost:4000 部署到git服务器上 hexo deploy https://foreverxwwl.github.io/ next主题安装 git clone https://github.com/iissnan/hexo-theme-next themes/next 进入配置文件_config.yml 找到 theme 设置为 theme: next 二、next主题设置 增加标签页等页面 进入next主题的配置文件 _config.yml 找到menu: 将要添加的页面注释删掉 在blog页面 hexo n page tags 增加标签tags页面 hexo n page categories 增加分类categories页面 修改头像姓名等信息 主要参考文档在主题的_config文件中修改 头像 avatar: 修改地址主题 scheme: 设置大的标题、姓名在全局的_config.yml中的 title: 新建一篇博客 hexo n hexo博客搭建 用markdowm编写博客 启用功能 （1）启用侧边栏社交链接 进入主题的_config.yml文件 将social: 一栏的注释取消 （2）启用打赏功能 进入主题的_config.yml文件 将reward项目注释删除 comment：加上用语 也可在后面添加图片 （3）设置头像样式 进入目录 \blog\themes\next\source\css_common\components\sidebar 修改sidebar-author.styl文件中的样式 12345678910111213&gt; &gt; .site-author-image &#123;&gt; &gt; display: block;&gt; &gt; margin: 0 auto;&gt; &gt; padding: $site-author-image-padding;&gt; &gt; max-width: $site-author-image-width;&gt; &gt; height: $site-author-image-height;&gt; &gt; border: $site-author-image-border-width solid $site-author-image-border-color;&gt; &gt; border-radius: 50%;&gt; &gt; transition: 3s all;&gt; &gt; &#125;&gt; &gt; .site-author-image:hover&#123;&gt; &gt; transform: rotate(360deg);&gt; &gt; &#125; （3）设置首页阅读全文 在主题配置文件中找到auto_excerpt:选项 将false 改为true 并设置可看长度 也可在博客编辑时在相应位置添加;此代码以下的点击查看 （4）添加动态背景 在主题配置文件找到canvas 默认都是关闭的 将需要的设置为true （5）修改文章内链接样式 进入F:\blog\themes\next\source\css_common\components\post\post.sty 在尾部添加样式 123456789.post-body p a&#123; color: #345; border-bottom: none; font-size: 13px;/*字体大小*/ font-weight: 500; /*字体粗细*/ &amp;:hover&#123; color: #fcfcfc; &#125;&#125; （6）修改文章底部标签 进入F:\blog\themes\next\layout_macro\post.swig 修改 tag.path 可将这行的 # 替换成别的 1&lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt; &lt;i class="fa fa-tag"&gt;&lt;/i&gt; （7）Valine评论系统 进入主题配置文件 打开 valine https://leancloud.cn/ 网站配置appid并在配置文件中使用 （8）搜索，统计功能 都是进入next主题官网 开启第三方服务 三、一个小问题 再部署的时候 提示 ERROR Deployer not found: git按照晚上提示安装插件总是报错 npm install hexo-deployer-git –save然后用淘宝NPM镜像的“hexo-deployer-git”试了一下，成功了指令：$ cnpm install hexo-deployer-git –save]]></content>
      <categories>
        <category>基础知识学习</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java的反射与注解]]></title>
    <url>%2F2019%2F01%2F13%2F%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[反射反射是框架设计的灵魂。它就是将类的各个组成部分（成员变量，构造函数，成员函数）封装为其他对象。优点： 可以在程序运行过程中，操作这些对象。（在new之前） 可以解耦，提高程序的可扩展性 java代码在计算机中经历的三个阶段。 类编写好后进行javac编译，生成字节码.class文件 通过类加载器，classLoader将字节码文件加载进内存 在内存中有一个class类对象来封装这些class文件。 成员变量 Field[ ]对象数组 构造方法 Constructor[ ]对象数组 成员方法 Method[ ]对象数组 在运行阶段创建对象 获取class对象方式 Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象 多用于配置文件，将类名定义在配置文件中。读取文件，加载类1Class name1 = Class.forName("domain.Person"); 类名.class：通过类名的属性class获取 多用于参数的传递1Class name2 = Person.class; 对象.getClass()：getClass()方法在Object类中定义着 多用于对象的获取字节码的方式12Person person = new Person();Class name3 = person.getClass(); 同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。这三种方法获取的class对象，所代表的都是同一个Person对象所以用==比较三者是true 123456789101112131415161718public static void main(String[] args) throws Exception &#123; //1. Class.forName("全类名")：将字节码文件加载进内存，返回Class对象 Class name1 = Class.forName("domain.Person"); System.out.println(name1); //2. 类名.class：通过类名的属性class获取 Class name2 = Person.class; System.out.println(name2); //3.对象.getClass()：getClass()方法在Object类中定义着。 Person person = new Person(); Class name3 = person.getClass(); System.out.println(name3); //比较三个对象 System.out.println(name1 == name2); System.out.println(name1 == name3); &#125; class对象的方法使用Class对象功能： 获取成员变量们 Field[] getFields() Field getField(String name) Field[] getDeclaredFields() Field getDeclaredField(String name) 获取构造方法们 Constructor&lt;?&gt;[] getConstructors() Constructor getConstructor(类&lt;?&gt;… parameterTypes) Constructor&lt; T&gt; getDeclaredConstructor(类&lt;?&gt;… parameterTypes) Constructor&lt;?&gt;[] getDeclaredConstructors() 获取成员方法们： Method[] getMethods() Method getMethod(String name, 类&lt;?&gt;… parameterTypes) Method[] getDeclaredMethods() Method getDeclaredMethod(String name, 类&lt;?&gt;… parameterTypes) 获取类名 String getName(） 获取成员变量们获取成员变量首先要获取class对象，通过兑现获取成员变量获取成员变量以后，用途有三 设置值 void set(Object obj, Object value) 获取值 get(Object obj) 忽略访问权限修饰符的安全检查 setAccessible(true):暴力反射123456789101112131415161718192021222324//获取class对象 Class personClass = Person.class; //获取成员变量 只能获取public的成员变量 Field[] fields = personClass.getFields(); for (Field filed : fields) &#123; System.out.println(filed); &#125; Person person = new Person(); //设置成员变量id的值 Field id = personClass.getField("id"); id.set(person, 12341); //获取id的值 Object value = id.get(person); System.out.println(value); System.out.println("-------------------------------------"); //Field[] getDeclaredFields()获取所有成员变量 不考虑修饰符 Field[] declaredFields = personClass.getDeclaredFields(); for (Field declaredField : declaredFields) &#123; System.out.println(declaredField); &#125; 获取构造方法获取构造方法的用途是创建对象 创建对象： T newInstance(Object… initargs) 如果使用空参数构造方法创建对象，操作可以简化： Class对象的newInstance方法 12345678910111213141516171819//获取class类对象 Class personClass = Person.class; //通过class类对象获取构造方法 Constructor personClassConstructor = personClass.getConstructor(String.class, int.class); System.out.println(personClassConstructor); //Constructor对象主要功能是创建对象 Object person = personClassConstructor.newInstance("张三",23); System.out.println(person); System.out.println("---------------"); //获取无参构造方法 Constructor constructor = personClass.getConstructor(); Object person1 = constructor.newInstance(); System.out.println(person1); Object person2 = constructor.newInstance(); System.out.println(person2); //如果使用无参构造，则可以直接使用class对象的方法 Object person3 = personClass.newInstance(); System.out.println(person3); 获取方法对象以及类名获取方法对象的目的 执行方法： Object invoke(Object obj, Object… args) 获取方法名称： String getName:获取方法名1234567891011121314151617181920212223242526//获取class类对象 Class personClass = Person.class; //获取方法（传入方法名） Method eat = personClass.getMethod("eat"); //执行方法（执行方法需要传入一个对象，执行该对象的方法） Person person = new Person(); eat.invoke(person); //获取有参方法(要传入参数的class文件) Method eat1 = personClass.getMethod("eat", String.class); eat1.invoke(person, "苹果"); System.out.println("-----------------"); //获取所有public方法 Method[] methods = personClass.getMethods(); for (Method method : methods) &#123; System.out.println(method); System.out.println(method.getName()); &#125; /* 获取类名 */ String className = personClass.getName(); System.out.println(className); 注解 定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。 JDK1.5之后的新特性说明程序的使用注解：@注解名称 作用分类： 编写文档：通过代码里标识的注解生成文档【生成文档doc文档】 代码分析：通过代码里标识的注解对代码进行分析【使用反射】 编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】JDK中预定义的一些注解@Override ：检测被该注解标注的方法是否是继承自父类(接口)的@Deprecated：该注解标注的内容，表示已过时@SuppressWarnings：压制警告, 一般传递参数all @SuppressWarnings(“all”) 自定义注解 格式：元注解public @interface 注解名称{属性列表;} 本质：注解本质上就是一个接口，该接口默认继承Annotation接口public interface MyAnno extends java.lang.annotation.Annotation {} 属性：接口中的抽象方法： 属性的返回值类型有下列取值 基本数据类型String枚举注解以上类型的数组 定义了属性，在使用时需要给属性赋值 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。 数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略元注解：用于描述注解的注解 @Target：描述注解能够作用的位置 ElementType取值： TYPE：可以作用于类上 METHOD：可以作用于方法上 FIELD：可以作用于成员变量上 @Retention：描述注解被保留的阶段 @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到 @Documented：描述注解是否被抽取到api文档中 @Inherited：描述注解是否被子类继承]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
</search>
