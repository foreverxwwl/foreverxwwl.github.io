<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[动态规划]]></title>
    <url>%2F2019%2F09%2F22%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[算法篇——动态规划在我看来，动态规划是一种思想，一种解决问题的手段。总的来说就是找到基于当前状态的最优决策。一般通过递归来实现，但与递归不同的，递归有些问题被反复计算多次，但动态规划对每个子问题只计算一次，然后将其保存起来，以后在遇到同样的问题就直接引用，不必直接求解。其重点就是保存以前的状态，通过以前状态推得现有最优态。 例: 数字三角形73 88 1 02 7 4 44 5 2 6 5在上面的数字三角形中寻找一条从顶部到底边的路径，使得路径上所经过的数字之和最大。路径上的每一步都只能往左下或 右下走。只需要求出这个最大和即可，不必给出具体路径。 1. 纯递归解法 单纯用递归很简答就能解决这个问题只用用一个数组 d(i,j)来存储这个数字三角形，用max(i,j)表示从d(i,j)到底边各条路径中最佳数字之和。从d(i,j)出发，下一步只能走d(r+1,j)或者d(r+1,j+1)代码如下 123456789101112131415161718192021222324252627import java.util.Scanner;public class triangle &#123; static int[][] a = new int[100][100]; static int n; public static void main(String[] arge)&#123; Scanner input = new Scanner(System.in); n = input.nextInt(); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; a[i][j] = input.nextInt(); &#125; &#125; System.out.println(sum(0,0)); &#125; static int sum(int i, int j)&#123; int m; if(i == n)&#123; return a[i][j]; &#125; else &#123; int x = sum(i + 1, j); int y = sum(i + 1, j + 1); m = x&gt;y?x:y; return m + a[i][j]; &#125; &#125;&#125; 2. 用记忆递归型的动态规划 如果用上面的单纯递归，一旦数据稍微过大，则会运行超时。应为其中出现了大量的重复计算。此时就需要用到递归的第一个思路，保存每次的值，则可以避免过多的重复。则在每次算出MaxSum值的时候将其保存起来则可以免去重复计算。 1234567891011121314151617181920212223242526272829public class triangle1 &#123; static int[][] a = new int[100][100]; static int n; static int[][] max = new int[100][100]; public static void main(String[] arge)&#123; Scanner input = new Scanner(System.in); n = input.nextInt(); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; a[i][j] = input.nextInt(); max[i][j] = -1; &#125; &#125; System.out.println(sum(0,0)); &#125; static int sum(int i, int j)&#123; if (max[i][j] != -1) return max[i][j]; if(i == n)&#123; return a[i][j]; &#125; else &#123; int x = sum(i + 1, j); int y = sum(i + 1, j + 1); max[i][j] = (x&gt;y?x:y) + a[i][j]; &#125; return max[i][j]; &#125;&#125; 3.递推类型动态规划 上面的方法，虽然可以有效的降低实践复杂度，但是其递归调用要占用大量的堆栈空间，容易早场栈溢出，所以就需要把递归思想转变为递推思想。从最后开始，如下表，倒数第二行的2可以和最后一行的4,5相加，但是和5相加较大，则将7保存下来，以此类推。 30 23 21 20 13 10 7 12 10 10 4 5 2 6 5 12345678910111213141516171819202122public class triangle2 &#123; static int[][] a = new int[100][100]; static int n; static int[][] max = new int[100][100]; public static void main(String[] arge)&#123; Scanner input = new Scanner(System.in); n = input.nextInt(); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; a[i][j] = input.nextInt(); &#125; &#125; for (int i = n-2; i &gt;= 0; i--) &#123; for (int j = 0; j &lt;= i; j++) &#123; int x = a[i+1][j+1] + a[i][j]; int y = a[i+1][j] + a[i][j]; a[i][j] = x&gt;y?x:y; &#125; &#125; System.out.println(a[0][0]); &#125;&#125; 则不难总结出递归到动态规划的一般转化方法：构造一个数组，数组元素的值是递归函数返回值，数组下标值是递归函数参数。从边界开始填充数组。 总结：动态规划的一般解题思路 将原问题分解为若干小问题，将子问题求出后保存，每个子问题只求解一次 保存状态，一般通过一个数组作为状态空间 确定初始状态 确定状态转移方程例如数字三角形12MaxSum[i][j] = a[i][j] (i=n)MaxSum[i][j] = max(MaxSum[i+1][j] + MaxSum[i+1][j+1]) (i!=n)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github学习]]></title>
    <url>%2F2019%2F09%2F19%2Fgithub%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[github基本操作 初始化 git init 状态查看 git status 添加到暂存区 git add 提交到本地库 git commit -m 查看历史 git log / git –online / git reflog 版本前进或后退 git reset –hard &lt;索引值&gt; / git reset –hard HEAD~2 比较工作区与暂存区文件差异 git diff [文件名] 将工作区与本地库文件比较 git diff [本地库历史版本（HEAD）] [文件名] 分支管理 创建分支 git branch [分支名] 查看分支 git branch -v 切换分支 git checkout [分支名] 合并分支 git merge [分支名] 解决冲突 git add git commit -m 远程库操作 创建远程库地址别名 git remote add [远程库地址] 查看别名 git remote -v 推送 git push [远程库地址名] [分支名] 克隆 git clone [远程库地址名] 拉取 git pull [远程库地址名] [远程库分支] 抓取 git fetch [远程库地址名] [远程库分支] 合并 git merge [远程库地址名/远程库分支] 跨团队合作 团队2进入团队1项目目录,点击fork。 团队2 git clone &lt;远程地址&gt;，修改并commit，git push 提交到远程库。 团队2进入页面，点击 pull requests、 new pull requests， Create pull requests 然后发消息给团队1。 团队1点击pull requests，Commits 、files changed 代码审核。 如果没有问题 则点击 merge pull request 并添加-m信息，结束远程库修改。 团队1将远程库拉取到本地 git pull origin master。]]></content>
      <categories>
        <category>基础知识学习</category>
      </categories>
      <tags>
        <tag>git学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客搭建]]></title>
    <url>%2F2019%2F09%2F19%2Fhexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[hexo博客搭建一、博客基本操作 博客部署到本地 hexo clean 清楚缓存hexo g 生成静态网页hexo s 本地启动预览查看 http://localhost:4000 部署到git服务器上 hexo deploy https://foreverxwwl.github.io/ next主题安装 git clone https://github.com/iissnan/hexo-theme-next themes/next 进入配置文件_config.yml 找到 theme 设置为 theme: next 二、next主题设置 增加标签页等页面 进入next主题的配置文件 _config.yml 找到menu: 将要添加的页面注释删掉 在blog页面 hexo n page tags 增加标签tags页面 hexo n page categories 增加分类categories页面 修改头像姓名等信息 主要参考文档在主题的_config文件中修改 头像 avatar: 修改地址主题 scheme: 设置大的标题、姓名在全局的_config.yml中的 title: 新建一篇博客 hexo n hexo博客搭建 用markdowm编写博客 启用功能 （1）启用侧边栏社交链接 进入主题的_config.yml文件 将social: 一栏的注释取消 （2）启用打赏功能 进入主题的_config.yml文件 将reward项目注释删除 comment：加上用语 也可在后面添加图片 （3）设置头像样式 进入目录 \blog\themes\next\source\css_common\components\sidebar 修改sidebar-author.styl文件中的样式 12345678910111213&gt; &gt; .site-author-image &#123;&gt; &gt; display: block;&gt; &gt; margin: 0 auto;&gt; &gt; padding: $site-author-image-padding;&gt; &gt; max-width: $site-author-image-width;&gt; &gt; height: $site-author-image-height;&gt; &gt; border: $site-author-image-border-width solid $site-author-image-border-color;&gt; &gt; border-radius: 50%;&gt; &gt; transition: 3s all;&gt; &gt; &#125;&gt; &gt; .site-author-image:hover&#123;&gt; &gt; transform: rotate(360deg);&gt; &gt; &#125; （3）设置首页阅读全文 在主题配置文件中找到auto_excerpt:选项 将false 改为true 并设置可看长度 也可在博客编辑时在相应位置添加;此代码以下的点击查看 （4）添加动态背景 在主题配置文件找到canvas 默认都是关闭的 将需要的设置为true （5）修改文章内链接样式 进入F:\blog\themes\next\source\css_common\components\post\post.sty 在尾部添加样式 123456789.post-body p a&#123; color: #345; border-bottom: none; font-size: 13px;/*字体大小*/ font-weight: 500; /*字体粗细*/ &amp;:hover&#123; color: #fcfcfc; &#125;&#125; （6）修改文章底部标签 进入F:\blog\themes\next\layout_macro\post.swig 修改 tag.path 可将这行的 # 替换成别的 1&lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt; &lt;i class="fa fa-tag"&gt;&lt;/i&gt; （7）Valine评论系统 进入主题配置文件 打开 valine https://leancloud.cn/ 网站配置appid并在配置文件中使用 （8）搜索，统计功能 都是进入next主题官网 开启第三方服务 三、一个小问题 再部署的时候 提示 ERROR Deployer not found: git按照晚上提示安装插件总是报错 npm install hexo-deployer-git –save然后用淘宝NPM镜像的“hexo-deployer-git”试了一下，成功了指令：$ cnpm install hexo-deployer-git –save]]></content>
      <categories>
        <category>基础知识学习</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
</search>
