<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[maven基础]]></title>
    <url>%2F2019%2F10%2F27%2Fmaven%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[maven基础一、maven简介含义Maven 是一个项目管理工具，它包含了一个项目对象模 型 (POM：Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管 理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标 (goal)的逻辑。 maven能解决的问题 我们需要引用各种 jar 包，尤其是比较大的工程，引用的 jar 包往往有几十个乃至上百个， 每用 到一种 jar 包，都需要手动引入工程目录，而且经常遇到各种让人抓狂的 jar 包冲突，版本冲突。 我们辛辛苦苦写好了 Java 文件，需要将它编译成二 进制字节码。好歹现在这项工作可以由各种集成开发工具帮我们完成，Eclipse、IDEA 等都可以将代 码即时编译。 写完了代码，我们还要写一些单元测试，然后一个个的运行来检验代码质量。 maven就能帮你构建工程，管理 jar 包，编译代码，还能帮你自动运行单元测试，打包，生成报表，甚至能帮你部署项目，生成 Web 站 点. 二、maven的两个经典作用1. maven的依赖管理Maven 的一个核心特性就是依赖管理。当我们涉及到多模块的项目（包含成百个模块或者子项目），管理依赖就变成 一项困难的任务。Maven 展示出了它对处理这种情形的高度控制。 传统的 WEB 项目中，我们必须将工程所依赖的 jar 包复制到工程中，导致了工程的变得很大。那么 maven 工程是如何使得工程变得很少呢？maven 工程中不直接将 jar 包导入到工程中，而是通过在 pom.xml 文件中添加所需 jar 包的坐标，这样就很好的避免了 jar 直接引入进来，在需要用到 jar 包的时候，只要查找 pom.xml 文 件，再通过 pom.xml 文件中的坐标，到一个专门用于”存放 jar 包的仓库”(maven 仓库)中根据坐标从 而找到这些 jar 包，再把这些 jar 包拿去运行。 2. 项目的一键构建]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Filter-Listener学习]]></title>
    <url>%2F2019%2F10%2F23%2FFilter-Listener%2F</url>
    <content type="text"><![CDATA[Filter：过滤器1. 概念： 生活中的过滤器：净水器,空气净化器 web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。 过滤器的作用：一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤… 快速入门：步骤： 定义一个类，实现接口Filter 复写方法 配置拦截路径 web.xml 注解代码：123456789101112131415@WebFilter("/*")//访问所有资源之前，都会执行该过滤器public class FilterDemo1 implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException&#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println("filterDemo1被执行了...."); //放行 filterChain.doFilter(servletRequest,servletResponse);&#125; @Override public void destroy() &#123; &#125;&#125; 过滤器细节：web.xml配置123456789&lt;filter&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;filter-class&gt;cn.itcast.web.filter.FilterDemo1&lt;/filter-class&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;!-- 拦截路径 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 过滤器执行流程 执行过滤器 执行放行后的资源 回来执行过滤器放行代码下边的代码过滤器生命周期方法 init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源 doFilter:每一次请求被拦截资源时，会执行。执行多次 destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源过滤器配置详解 拦截路径配置： 具体资源路径： /index.jsp 只有访问index.jsp资源时，过滤器才会被执行 拦截目录： /user/* 访问/user下的所有资源时，过滤器都会被执行 后缀名拦截： *.jsp 访问所有后缀名为jsp资源时，过滤器都会被执行 拦截所有资源：/* 访问所有资源时，过滤器都会被执行 拦截方式配置：资源被访问的方式 注解配置：设置dispatcherTypes属性 REQUEST：默认值。浏览器直接请求资源 FORWARD：转发访问资源 INCLUDE：包含访问资源 ERROR：错误跳转资源 ASYNC：异步访问资源 web.xml配置 设置&lt; dispatcher&gt;&lt; /dispatcher&gt;标签即可 过滤器链(配置多个过滤器) 执行顺序：如果有两个过滤器：过滤器1和过滤器2 过滤器1 过滤器2 资源执行 过滤器2 过滤器1 过滤器先后顺序问题： 注解配置：按照类名的字符串比较规则比较，值小的先执行 如： AFilter 和 BFilter，AFilter就先执行了。 web.xml配置： &lt; filter-mapping&gt;谁定义在上边，谁先执行 增强对象的功能： * 设计模式：一些通用的解决固定问题的方式 1. 装饰模式 2. 代理模式 * 概念： 1. 真实对象：被代理的对象 2. 代理对象： 3. 代理模式：代理对象代理真实对象，达到增强真实对象功能的目的 * 实现方式： 1. 静态代理：有一个类文件描述代理模式 2. 动态代理：在内存中形成代理类 * 实现步骤： 1. 代理对象和真实对象实现相同的接口 2. 代理对象 = Proxy.newProxyInstance(); 3. 使用代理对象调用方法。 4. 增强方法 * 增强方式： 1. 增强参数列表 2. 增强返回值类型 3. 增强方法体执行逻辑 Listener：监听器* 概念：web的三大组件之一。 * 事件监听机制 * 事件 ：一件事情 * 事件源 ：事件发生的地方 * 监听器 ：一个对象 * 注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码 * ServletContextListener:监听ServletContext对象的创建和销毁 * 方法： * void contextDestroyed(ServletContextEvent sce) ：ServletContext对象被销毁之前会调用该方法 * void contextInitialized(ServletContextEvent sce) ：ServletContext对象创建后会调用该方法 * 步骤： 1. 定义一个类，实现ServletContextListener接口 2. 复写方法 3. 配置 1. web.xml &lt;listener&gt; &lt;listener-class&gt;cn.itcast.web.listener.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; * 指定初始化参数&lt;context-param&gt; 2. 注解： * @WebListener]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Filter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP-EL-JSTL学习]]></title>
    <url>%2F2019%2F10%2F18%2FEL-JSTL%2F</url>
    <content type="text"><![CDATA[JSP1. 基本使用 作用：用于配置JSP页面，导入资源文件 格式： &lt; %@ 指令名称 属性名1=属性值1 属性名2=属性值2 … %&gt;2. 分类： page ： 配置JSP页面的 contentType：等同于response.setContentType() 设置响应体的mime类型以及字符集 设置当前jsp页面的编码（只能是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集） import：导包 errorPage：当前页面发生异常后，会自动跳转到指定的错误页面 isErrorPage：标识当前也是是否是错误页面。 true：是，可以使用内置对象exception false：否。默认值。不可以使用内置对象exception include ： 页面包含的。导入页面的资源文件 &lt; %@include file=”top.jsp”%&gt; taglib ： 导入资源 &lt; %@ taglib prefix=”c” uri=”http://java.sun.com/jsp/jstl/core&quot; %&gt; 注释: html注释： &lt; !– –&gt;:只能注释html代码片段 jsp注释：推荐使用 &lt;%– –%&gt;：可以注释所有3. 内置对象在jsp页面中不需要创建，直接使用的对象一共有9个： 变量名 真实类型 作用 pageContext PageContext 当前页面共享数据，还可以获取其他八个内置对象 request HttpServletRequest 一次请求访问的多个资源(转发) session HttpSession 一次会话的多个请求间 application ServletContext 所有用户间共享数据 response HttpServletResponse 响应对象 page Object 当前页面(Servlet)的对象 this out JspWriter 输出对象，数据输出到页面上 config ServletConfig Servlet的配置对象 exception Throwable 异常对象 MVC：开发模式1. jsp演变历史 早期只有servlet，只能使用response输出标签数据，非常麻烦 后来又jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中即写大量的java代码，有写html表，造成难于维护，难于分工协作 再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性 2. MVC： M：Model，模型。JavaBean 完成具体的业务操作，如：查询数据库，封装对象 V：View，视图。JSP 展示数据 C：Controller，控制器。Servlet 获取用户的输入 调用模型 将数据交给视图进行展示 优缺点： 优点： 耦合性低，方便维护，可以利于分工协作 重用性高 缺点： 使得项目架构变得复杂，对开发人员要求高 EL表达式基本概念 概念：Expression Language 表达式语言 作用：替换和简化jsp页面中java代码的编写 语法：${表达式} 注意： jsp默认支持el表达式的。如果要忽略el表达式 设置jsp中page指令中：isELIgnored=”true” 忽略当前jsp页面中所有的el表达式 ${表达式} ：忽略当前这个el表达式基本使用 算数运算符： + - * /(div) %(mod) 比较运算符： &gt; &lt; &gt;= &lt;= == != 逻辑运算符： &amp;&amp;(and) ||(or) !(not) 空运算符： empty 功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0 ${empty list}:判断字符串、集合、数组对象是否为null或者长度为0 ${not empty str}:表示判断字符串、集合、数组对象是否不为null 并且 长度&gt;0el表达式只能从域对象中获取值 ${域名称.键名}：从指定域中获取指定键的值 域名称： pageScope –&gt; pageContext requestScope –&gt; request sessionScope –&gt; session applicationScope –&gt; application（ServletContext） 举例：在request域中存储了name=张三获取：${requestScope.name} ${键名}：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。 获取对象、List集合、Map集合的值 对象：${域名称.键名.属性名}本质上会去调用对象的getter方法 List集合：${域名称.键名[索引]} Map集合： ${域名称.键名.key名称} ${域名称.键名[“key名称”]} 隐式对象：el表达式中有11个隐式对象pageContext：获取jsp其他八个内置对象${pageContext.request.contextPath}：动态获取虚拟目录 JSTL基本概念 概念：JavaServer Pages Tag Library JSP标准标签库 是由Apache组织提供的开源的免费的jsp标签 &lt;标签&gt; 作用：用于简化和替换jsp页面上的java代码 使用步骤： 导入jstl相关jar包 引入标签库：taglib指令： &lt; %@ taglib %&gt; 使用标签常用的JSTL标签 if:相当于java代码的if语句 属性： test 必须属性，接受boolean表达式 如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容 一般情况下，test属性值会结合el表达式一起使用 注意： c:if标签没有else情况，想要else情况，则可以在定义一个c:if标签 choose:相当于java代码的switch语句 使用choose标签声明 相当于switch声明 使用when标签做判断 相当于case 使用otherwise标签做其他情况的声明 相当于default foreach:相当于java代码的for语句]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie-Session]]></title>
    <url>%2F2019%2F10%2F12%2FCookie-Session%2F</url>
    <content type="text"><![CDATA[会话技术 会话：一次会话中包含多次请求和响应。 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止 功能：在一次会话的范围内的多次请求间，共享数据 方式： 客户端会话技术：Cookie 服务器端会话技术：SessionCookie：基本原理及操作 概念：客户端会话技术，将数据保存到客户端 快速入门： 创建Cookie对象，绑定数据 new Cookie(String name, String value) 发送Cookie对象 response.addCookie(Cookie cookie) 获取Cookie，拿到数据 Cookie[] request.getCookies() 实现原理 基于响应头set-cookie和请求头cookie实现 cookie的细节 一次可不可以发送多个cookie? 可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。 cookie在浏览器中保存多长时间？ 默认情况下，当浏览器关闭后，Cookie数据被销毁 持久化存储： setMaxAge(int seconds) seconds正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效 seconds负数：默认值 seconds零：删除cookie信息 cookie能不能存中文？ 在tomcat 8 之前 cookie中不能直接存储中文数据。 需要将中文数据转码—一般采用URL编码(%E3) 在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析 cookie共享问题 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？ 默认情况下cookie不能共享 setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录 如果要共享，则可以将path设置为”/“ 不同的tomcat服务器间cookie共享问题？ setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享 setDomain(“.baidu.com”),那么tieba.baidu.com和news.baidu.com中cookie可以共享 Cookie的特点和作用 cookie存储数据在客户端浏览器 浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个) cookie一般用于存出少量的不太敏感的数据 在不登录的情况下，完成服务器对客户端的身份识别 Session概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession 基本使用 获取HttpSession对象： HttpSession session = request.getSession(); 使用HttpSession对象： Object getAttribute(String name) void setAttribute(String name, Object value) void removeAttribute(String name) 原理 Session的实现是依赖于Cookie的。 细节： 当客户端关闭后，服务器不关闭，两次获取session是否为同一个？默认情况下。不是。 如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。 Cookie c = new Cookie(“JSESSIONID”,session.getId());c.setMaxAge(60*60);response.addCookie(c); 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？ 不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作 session的钝化： 在服务器正常关闭之前，将session对象系列化到硬盘上 session的活化： 在服务器启动后，将session文件转化为内存中的session对象即可。 session什么时候被销毁？ 服务器关闭 session对象调用invalidate() 。 session默认失效时间 30分钟 选择性配置修改 30 session的特点 session用于存储一次会话的多次请求的数据，存在服务器端 session可以存储任意类型，任意大小的数据 session与Cookie的区别： session存储数据在服务器端，Cookie在客户端 session没有数据大小限制，Cookie有 session数据安全，Cookie相对于不安全]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet学习(request)]]></title>
    <url>%2F2019%2F10%2F08%2FServlet--request%2F</url>
    <content type="text"><![CDATA[Servlet学习(request)1. 概念 servlet 是一个接口，定义了java类被浏览器访问到（tomcat）的规则 要定义一个类实现Servlet接口，覆写方法 2. 简单实现 创建javawbe项目 定义一个类，实现Servlet接口 实现接口中的抽象方法 12345678910111213141516171819202122232425262728public class FirstServlet implements Servlet &#123; @Override public void init(ServletConfig servletConfig) throws ServletException &#123; &#125; @Override public ServletConfig getServletConfig() &#123; return null; &#125; //提供服务的方法 @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; System.out.println("hello Servlet"); &#125; @Override public String getServletInfo() &#123; return null; &#125; @Override public void destroy() &#123; &#125;&#125; 配置Servlet 在web目录下的 web.xml中 123456789&lt;!--配置Servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;demol1&lt;/servlet-name&gt; &lt;servlet-class&gt;com.servlet.FirstServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;demol1&lt;/servlet-name&gt; &lt;url-pattern&gt;/demol1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 支持注解配置，可以不需要web.xml 定义一个类，实现servlet 复写方法 在Servlet文件配置(Servletdome1)@WebServlet(“/demo1”) 3. Servlet方法，生命周期 被创建：执行init方法，一次 默认情况下第一次访问时被创建可以配置Servlet创建时机，在web.xml中 123&lt;!-- 1.第一次访问时创建 参数为负数（默认）--&gt;&lt;!-- 2.在服务器启动时创建 参数为正数--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; Servlet 的init方法只执行一次，说明一个servlet在内存中只存在一个对象，多个用户访问时就会存在线程安全问题解决：尽量不要在Servlet中定义成员变量，不要对其修改值 提供服务：执行service方法，可以多次 被销毁：服务器关闭时执行 destroy方法，只执行一次 4. servlet体系结构Servlet –接口 |GenericServlet –抽象类 |HttpServlet –抽象类 GenericServlet（ServletDemo2）将Servlet接口中的方法做了空实现，只将service（）方法作为抽象，不用强制复写其他方法。 HttpServlet（ServletDemo3）对http协议的分装和描述。内部可以判断请求方式是git还是post定义了doGit，doPost方法。 5. Servlet相关配置 urlpartten:Servlet 访问路径（ServletDemo4） 一个servlet可以定义多个访问路径：@WebServlet({“/d1”,”/d2”,”/d3”}) 路径定义规则： /xxx /xx/xx 可以写多层路径，目录结构。也可以 ”/*“ *.do 可以任意.do demo3.do HTTP1. 概念Hyper Text Transfer Protocol 超文本传输协议 传输协议定义了客户端和服务端通信时发送数据的格式2. 特点： 基于TCP/IP的高级协议 默认端口号80 基于请求响应模型的：一次请求对应一次响应 无状态的：每次请求时间相互独立，不能通信数据3. 历史版本 1.0版本：每次请求响应都建立新的连接 1.1版本：每次请求复用连接 4. 请求消息数据格式 请求行 字符串格式 请求方式 请求url 请求协议/版本 GET /hello.html HTTP/1.1 请求头 请求头名称:请求头值 User-Agent: 浏览器告诉服务器，使用的浏览器版本信息，可以在服务器端获取头信息解决兼容问题。 Accept:可以响应格式 Referer:告诉服务器，当前请求从哪里来。可以防止倒链，也可以做统计工作。 请求空行 空行 分隔请求头和请求体 请求体 username = lihaobo 封装POST请求消息的请参数的 整体字符串格式：GET /hello.html HTTP/1.1Host: localhost:8080User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: keep-aliveCookie: JSESSIONID=25666E7EBC25C248EA50AF9412E95EBBUpgrade-Insecure-Requests: 1If-Modified-Since: Thu, 03 Oct 2019 15:24:18 GMTIf-None-Match: W/“243-1570116258304”Cache-Control: max-age=0 username = lihaobo 5. 请求方式Get： 请求参数在请求行中，url中 请求的url长度有限制 不太安全 post： 请求参数在请求体中 url长度无限制 相对安全 6. 请求响应原理 tomcat服务器会更具请求中url路径创建对应的ServletDemo对象。 tomcat会创建request和response对象，request对象中封装请求消息数据。 tomcat将request和response两个对象传递给service方法并且调用service方法。 我们可以操纵request对象获取请求数据消息，通过request对象设置响应消息数据。 服务器给浏览器作出响应之前会从response获取响应消息。 request和response是有服务器创建的 7. request继承体系ServletRequest –接口 | 继承HttpServletRequest –接口 | 实现org.apache.catalina.connector.RequestFacade 类（tomcat） 8. 获取请求数据1. 获取请求行数据 GET /hello.html HTTP/1.1 获取请求方式 ： Get String getMethod() 获取虚拟目录：/ String getContextPath() 获取Servlet路径：/demo2 String getServletPath() 获取 get方式的请求参数 String getQueryString() 获取请求URL： String getRequestURI() /demo2 StringBuffer getRequestURL() HTTP://localhost/demo2 UIL：统一资源定位符 HTTP://localhost/demo2 URI：统一资源标识符 /demo2 获取协议及版本 HTTP/1.1 String getProtocol() 获取客户机的ip地址 String getRemoteAddr()2. 获取请求头数据 String getHeader(String name)通过请求头的名称获取值Enumeration &lt; String&gt; getHeaderNames() 获取请求头名称 123456789//获取所有请求头Enumeration&lt;String&gt; headerNames = request.getHeaderNames() ;//遍历while(headerNames.hasMoreElements())&#123; String name = headerNames.nextElement(); //根据名称访问请求头的值 String valus = request.getHeader(name); System.out.println(name + "--" + value);&#125; 3. 获取请求体数据只有POST请求方式才有请求体 获取流对象 BufferdReader gitReader(): 获取字符输入流 SerletInputStream getInputStream(): 获取字节输入流，可操作性所有类型数据。 从流数据中取数据 4. 其他功能（重要） 获取请求参数（通用方式） （ServletDemo5） String getParameter(String name) 根据参数名称获取参数值例如：username = lihaob 传递username就可返回 lihaob String getParametervalues(String name) 更具请求参数名获取参数值的数组例如：hobby=xx&amp;hobby=game,则可以将这两个值封装为数组 Enumeration&lt; String &gt; getParameterNames() :获取所有请求的参数名 Map&lt; String, String[]&gt; getParameterMap(): 获取所有参数的map集合 解决中文乱码问题get方式：已经解决了乱码问题post方式：在获取参数前要设置编码 req.setCharacterEncoding(“utf-8”); 请求转发(ServletDemo6,7) 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path) 使用RequestDispatcher对象进行转发：forward(ServletRequest req, ServletResponse resp) 特点： 1.1 浏览器地址栏路径不变化 1.2 只能转发到服务器内部资源中 1.3 只是发送了一个请求，访问了多个资源 共享数据 域对象：一个有作用范围的对象，可以在范围内共享数据。 request域：一次请求的范围，刚才的转发就是一次请求，一般用于请求转发的多个资源中共享数据。 方法： void setAttribute(String name， Object obj);存储数据 object getAttribute(String name); 通过建获取值 void removeAttribute(String name);通过建移除对 获取servletContext： servletContext getservletContext();]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet学习(response)]]></title>
    <url>%2F2019%2F10%2F08%2FServlet--response%2F</url>
    <content type="text"><![CDATA[Servlet学习(response)response响应消息1. 数据格式： 响应行 组成：协议/版本 响应状态码 状态码描述 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。状态码都是3位数字 。 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码 2xx：成功。代表：200 3xx：重定向。代表：302(重定向)，304(访问缓存) 4xx：客户端错误。 404 （请求路径没有对应的资源） 405：请求方式没有对应的doXxx方法 5xx：服务器端错误。代表：500(服务器内部出现异常) 响应头： 格式：头名称： 值 常见的响应头： Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式 Content-disposition：服务器告诉客户端以什么格式打开响应体数据值：in-line:默认值,在当前页面内打开：attachment;filename=xxx：以附件形式打开响应体。文件下载 响应空行 响应体:传输的数据 1234567891011121314响应字符串格式HTTP/1.1 200 OKContent-Type: text/html;charset=UTF-8Content-Length: 101Date: Wed, 06 Jun 2018 07:08:42 GMT&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello , response &lt;/body&gt;&lt;/html&gt; 2. Response对象1. 设置响应行 格式：HTTP/1.1 200 ok 设置状态码：setStatus(int sc) 2. 设置响应头：setHeader(String name, String value) 3. 设置响应体： 获取输出流 字符输出流：PrintWriter getWriter() 字节输出流：ServletOutputStream getOutputStream() 使用输出流，将数据输出到客户端浏览器 重定向的特点:redirect（ResponseDemo1，ResponseDemo2） response.sendRedirect(contextPath+”/responseDemo2”); 地址栏发生变化 重定向可以访问其他站点(服务器)的资源 重定向是两次请求。不能使用request对象来共享数据 转发的特点：forward 转发地址栏路径不变 转发只能访问当前服务器下的资源 转发是一次请求，可以使用request对象来共享数据 路径写法： 相对路径：通过相对路径不可以确定唯一资源 如：./index.html 规则：找到当前资源和目标资源之间的相对位置关系 ./：当前目录 ../:后退一级目录 绝对路径：通过绝对路径可以确定唯一资源 如：http://localhost/day15/responseDemo2 /day15/responseDemo2 规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出 给客户端浏览器使用：需要加虚拟目录(项目的访问路径) 建议虚拟目录动态获取：request.getContextPath() 如 , 重定向… 给服务器使用：不需要加虚拟目录 如：转发路径 服务器输出字符数据到浏览器 获取字符输出流 PrintWriter pw = response.getWriter(); 输出数据 pw.write(“response”); 乱码问题： PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1 设置该流的默认编码 告诉浏览器响应体使用的编码12//简单的形式，设置编码，是在获取流之前设置response.setContentType("text/html;charset=utf-8"); 服务器输出字节数据到浏览器 获取字节输出流 ServletOutputStream sos = response.getOutputStream(); 输出数据 sos.write(“你好”.getBytes(“utf-8”)); 验证码 本质：图片 目的：防止恶意表单注册 3. ServletContext对象：1. 概念：代表整个web应用，可以和程序的容器(服务器)来通信 2. 获取： 通过request对象获取 request.getServletContext(); 通过HttpServlet获取 this.getServletContext();3. 功能： 获取MIME类型： MIME类型:在互联网通信过程中定义的一种文件数据类型 格式： 大类型/小类型 text/html image/jpeg 获取：String getMimeType(String file) 域对象：共享数据 setAttribute(String name,Object value) getAttribute(String name) removeAttribute(String name) ServletContext对象范围：所有用户所有请求的数据 获取文件的真实(服务器)路径 方法：String getRealPath(String path) String b = context.getRealPath(“/b.txt”);//web目录下资源访问 String c = context.getRealPath(“/WEB-INF/c.txt”);//WEB-INF目录下的资源访问 String a = context.getRealPath(“/WEB-INF/classes/a.txt”);//src目录下的资源访问]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC连接池与Template]]></title>
    <url>%2F2019%2F10%2F05%2FJDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%B8%8ETemplate%2F</url>
    <content type="text"><![CDATA[jdbc连接池与Template数据库连接池 概念：其实就是一个容器(集合)，存放数据库连接的容器。当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。 好处：1. 节约资源 2. 用户访问高效 C3P0：数据库连接池技术。Druid：数据库连接池实现技术，由阿里巴巴提供。 c3p0数据库连接池 导入jar包 c3p0-0.9.5.2.jar 2. mchange-commons-java-0.2.12.jar 定义配置文件c3p0-cnfig.xml 在定义配置文件时，也要注意版本问题，可直接放在src目录下 创建数据库连接池对象ComboPooledDataSource() DataSource ds = new ComboPooledDataSource(); 获取连接gitConnection Connection conn = ds.getConnection(); Druid数据库连接池 导入jar包 druid-1.0.9.jar 定义配置文件： 是properties形式的 可以叫任意名称，可以放在任意目录下 加载配置文件。Properties 123InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream("druid.properties");Properties pro = new Properties();pro.load(is); 获取数据库连接池对象：通过工厂来来获取 DruidDataSourceFactory并 1DataSource ds = DruidDataSourceFactory.createDataSource(pro); 获取连接：getConnection 1Connection conn = ds.getConnection(); 定义Druid数据库连接池工具类JDBCUtils 提供静态代码块加载配置文件，初始化连接池对象 获取连接方法：通过数据库连接池获取连接 释放资源 获取连接池的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class JDBCUtils &#123; //定义一个成员变量 private static DataSource ds = null;; static &#123; try &#123; //1.加载配置文件 Properties pro = new Properties(); pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream("Druid.properties")); //获取获取数据库连接池对象dataSource ds = DruidDataSourceFactory.createDataSource(pro); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取连接 */ public static Connection getConnection() throws SQLException &#123; return ds.getConnection(); &#125; /** * 释放资源 */ public static void close(Statement statement, Connection connection) &#123; close(null,statement,connection); &#125; public static void close(ResultSet resultSet, Statement statement, Connection connection)&#123; if (resultSet != null)&#123; try &#123; resultSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (statement != null)&#123; try &#123; statement.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (connection != null)&#123; try &#123; connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 获取连接池方法 */ public static DataSource getDataSource()&#123; return ds; &#125;&#125; Spring JDBC是Spring框架对jdbc的简单封装，提供了JDBCTemplate对象简化jdbc开发 导入jar包 创建JDBCTemplate对象，依赖于数据源DataSource JDBCTemplate template = new JDBCTemplate（ds）； 调用JDBCTemplate方法操作 update() 方法，执行增删改语句 queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合，查询的结果集长度只能是1。 123456public void test4()&#123; String sql = "select * from emp where id = ? or id = ?"; Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002); System.out.println(map); //&#123;id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20&#125;&#125; queryForList():查询结果将结果集封装为list集合 将每一条记录封装为一个Map集合，再将Map集合装载到List集合中12345678public void test5()&#123; String sql = "select * from emp"; List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql); for (Map&lt;String, Object&gt; stringObjectMap : list) &#123; System.out.println(stringObjectMap); &#125;&#125; query():查询结果，将结果封装为JavaBean对象,emp为自定义的对象有成员变量，getset函数以及tostring方法。 12345678910111213141516171819202122232425262728293031323334public void test6()&#123; String sql = "select * from emp"; List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() &#123; @Override public Emp mapRow(ResultSet rs, int i) throws SQLException &#123; Emp emp = new Emp(); int id = rs.getInt("id"); String ename = rs.getString("ename"); int job_id = rs.getInt("job_id"); int mgr = rs.getInt("mgr"); Date joindate = rs.getDate("joindate"); double salary = rs.getDouble("salary"); double bonus = rs.getDouble("bonus"); int dept_id = rs.getInt("dept_id"); emp.setId(id); emp.setEname(ename); emp.setJob_id(job_id); emp.setMgr(mgr); emp.setJoindate(joindate); emp.setSalary(salary); emp.setBonus(bonus); emp.setDept_id(dept_id); return emp; &#125; &#125;); for (Emp emp : list) &#123; System.out.println(emp); &#125; &#125; query的参数：RowMapper 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装 new BeanPropertyRowMapper&lt;类型&gt;(类型.class)，如果类型.class中的参数和数据库匹配，那么就会自动封装。1234567public void test6_2()&#123; String sql = "select * from emp"; List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class)); for (Emp emp : list) &#123; System.out.println(emp); &#125; &#125; queryForObject：查询结果，将结果封装为对象，一般用于聚合函数查询 12345public void test7()&#123; String sql = "select count(id) from emp"; Long total = template.queryForObject(sql, Long.class); System.out.println(total);&#125;]]></content>
      <categories>
        <category>javaWeb</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC基本概念与操作]]></title>
    <url>%2F2019%2F10%2F05%2FJDBC%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[jdbc基本概念与操作jdbc：Java DataBase Connectivity Java 数据库连接本质：其实是官方定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。 1. 导入驱动jar包2. 注册驱动在注册驱动时，新版jdbc注册驱动的语句要在中间加上cj。 1Class.forName("com.mysql.cj.jdbc.Driver"); 3. 获取数据库连接对象 Connection1Connection connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/workstation?characterEncoding=UTF-8&amp;serverTimezone=UTC&amp;useSSL=false", "root", "123456"); DriverManager：驱动管理对象 注册驱动功能：告诉程序该使用那个数据库驱动jar包 Class.forName(“com.mysql.jdbc.Driver”); 获取数据库连接： static Connection getConnection(String url, String user, String password) url配置：jdbc:mysql://ip地址(域名):端口号/数据库名称 jdbc:mysql://localhost:3306/workstation?characterEncoding=UTF-8&amp;serverTimezone=UTC&amp;useSSL=false Connection：数据库连接对象 可以获取执行sql的对象Statement Statement createStatement() PreparedStatement prepareStatement(String sql) 管理事务 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 提交事务：commit() 回滚事务：rollback() 在获取数据库连接对象时，应为使用了最新版mysql的jdbc驱动，在看视频时按照原本的配置方法配置url值，不断报下面的错，在百度了半下午以后才找到问题所在，旧版本可以“jdbc:mysql://localhost:3306/db3”但新版本必须配置为上面的内容。 1Exception in thread &quot;main&quot; java.sql.SQLException: The server time zone value is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support. 4. 获取执行sql语句的对象 Statement1Statement statement = connection.createStatement(); Statement: 执行sql的对象 boolean execute(String sql) ：可以执行任意的sql int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句。返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。 ResultSet executeQuery(String sql) ：执行DQL（select)语句 5. 定义sql并执行sql，接受返回结果12String sql = "update users set Upasswords = '123345567' where number = 2";int i = statement.executeUpdate(sql); 6. 处理结果并释放资源123System.out.println(i);statement.close();connection.close(); 7. ResultSet: 结果集对象,封装查询结果 boolean next(): 游标向下移动一行（默认指向表头行），判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true getXxx(参数):获取数据 Xxx：代表数据类型 如： int getInt() ，String getString() 参数： int：代表列的编号,从1开始 如： getString(1) String：代表列名称。 如： getDouble(“balance”) 12345678//循环判断游标是否是最后一行末尾。while(rs.next())&#123;、//获取数据int id = rs.getInt(1);//当前行第一列String name = rs.getString("name");//当前行“name”列double balance = rs.getDouble(3);System.out.println(id + "---" + name + "---" + balance);&#125; 8. PreparedStatement：执行sql的对象 SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题 解决sql注入问题：使用PreparedStatement对象来解决 使用： sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?; 获取执行sql语句的对象 PreparedStatement Connection.prepareStatement(String sql) 给？赋值：setXxx(参数1,参数2) 执行sql，接受返回结果，不需要传递sql语句123456789//定义SQLString sql = "update users set Upasswords = ? where number = ?";//获取pstmt对象preparedStatement = conn.prepareStatement(sql);//给SQL赋值preparedStatement.setInt(1, 123);preparedStatement.setInt(2, 2);//执行int cont = preparedStatement.executeUpdate();]]></content>
      <categories>
        <category>javaWeb</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构--链表（静态链表）]]></title>
    <url>%2F2019%2F10%2F02%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E9%93%BE%E8%A1%A8%EF%BC%88%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据结构–链表（静态链表） 静态链表中，应为没有指针使用，所以我们用一个结构体数组来存放节点，用cur来代替指针，存放下一个元素在结构体数组中的位置。 在建立链表时，我们把这个结构体数组看成两个链，一个是没有存放内容的备用链，一个是存放了内容的使用链，同样的我们确定一个头结点data不存放数据，cur存放的是下一个可插入元素的节点位置，初始化为1，为备用链的头，确定一个尾节点，data也不存放数据，cur存放的是第一个存放了数据的节点的位置，为使用链的头。 这样定义的好处是：其一，当链表中间有元素被删除时，备用链头cur值存放中间被删节点的位置，这样下次插入就可以直接在此插入。所以删除节点时可以不移动其他元素，下次插入只需要在备用链依次取就好。 其二，用最后一个位置存放使用链的头，是防止当结构体数组中第一个节点被删去，会丢失头节点位置，通过这个保存则可以随意删除。 静态链表中存放的数据彼此之间是非线性不连续的，是通过cur代替指针将其联系起来。 优点：再插入和删除时候，只需要修改游标，不需要移动元素，从而改进了顺序存储结构中插入和删除操作需要移动大量元素的缺点。 缺点：没有解决连续存储分配带来的表长难以确定的问题；失去了顺序存储结构随机存取的特性。下面是具体实现过程 1. 结构体定义123456#define MAXSIZE 7//定义结构typedef struct&#123; int data;//数据域 int cur;//下一个节点的下标&#125;StaticList[MAXSIZE]; 2. 初始化静态链表123456789101112//初始化静态链表,主要任务是让每一个节点cur指向下一个节点void InitList(StaticList l)&#123; for (int i = 0; i &lt; MAXSIZE - 1; i++) &#123; l[i].cur = i + 1; &#125; //备用链表的最后一个空元素的cur指向0，这样才可以再分配节点时判断是否已经存满 l[MAXSIZE - 2].cur = 0; //最后一个节点是使用链的头结点，初始化为0； l[MAXSIZE - 1].cur = 0;&#125; 3. 寻找可用空间1234567891011//在插入元素时，为带插入元素寻找一个空间下标int Malloc(StaticList l)&#123; //l[0].cur代表下一个可以插入的位置 int i = l[0].cur; if (i)&#123;//如果位置是0则不能插入 //位置不是0，则在此位置插入，并且将其下一个位置赋给头 l[0].cur = l[i].cur; &#125; return i;&#125; 4. 删除元素释放空间12345678//删除元素时，将其位置保存，方便下次插入void Free(StaticList l, int k)&#123; //将头中保存的下个可插入节点的位置赋给此待删除节点 l[k].cur = l[0].cur; //将次待删除节点位置赋给头，通过这两部操作将此节点放入了待插入链 l[0].cur = k;&#125; 5. 静态链表中元素个数1234567891011121314//求静态链表中元素个数，不包括头尾节点int ListLength(StaticList L)&#123; //L[MAXSIZE - 1]是已用链的头结点，.cur是已用链第一个节点位置 int i = L[MAXSIZE - 1].cur; int j = 0; while (i) &#123; j++; //不断查找到下一个已用链，最后一个已用链cur值为0 i = L[i].cur; &#125; return j;&#125; 6. 在i位置插入元素12345678910111213141516171819202122232425//静态链表中i位置插入一个元素void lnsertList(StaticList L, int i, int data)&#123; //判断插入点是否合理,要按照顺序插入不能跳跃插入 if (i&lt;1 || i&gt;ListLength(L) + 1) &#123; printf("插入点不合理"); return; &#125; int j = Malloc(L);//分配到插入位置 int k = MAXSIZE - 1;//k表示已用链头结点 if (j) &#123; //循环让k指向待插入位置i的已用链中前一个位置 for (int l = 1; l &lt;= i - 1; l++) &#123; k = L[k].cur; &#125; L[j].data = data; //将新节点与上一个节点连接 L[j].cur = L[k].cur; //将新节点与下一个节点连接 L[k].cur = j; &#125;&#125; 7. 删除第i个元素123456789101112131415161718192021222324//删除第i个元素，将值放入data中void DeleteList(StaticList L, int i, int *data)&#123; if (i &lt; 1 || i &gt;= ListLength(L)) &#123; printf("删除位置不合法"); return; &#125; //k指向已用链头结点 int k = MAXSIZE - 1; //循环让k指向已用链中k待删除节点的上一个节点 for (int l = 1; l &lt;= i - 1; l++) &#123; k = L[k].cur; &#125; //j指向待删除节点 int j = L[k].cur; *data = L[j].data; //将上一个节点与下一个节点相连 L[k].cur = L[j].cur; //将本节点置空加入备用链 Free(L, j);&#125; 8. 输出链表12345678910111213//输出链表void printList(StaticList L)&#123; //k指向已用链头结点 int k = MAXSIZE - 1; //已用链的cur不为0时输出 while (L[k].cur) &#123; k = L[k].cur; printf("%d ", L[k].data); &#125; printf("\n");&#125; 9. 主函数1234567891011121314151617181920212223242526int main(void)&#123; StaticList L; int j = 0; int data; InitList(L); printf("输入元素，以-1结尾\n"); while (1) &#123; scanf("%d", &amp;data); if (data != -1) &#123; j++; lnsertList(L, j, data); &#125; else &#123; break; &#125; &#125; printList(L); DeleteList(L, 2, &amp;data); printf("删除的元素值为 %d\n", data); printList(L); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构--链表（循环链表和双向链表）]]></title>
    <url>%2F2019%2F09%2F27%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E9%93%BE%E8%A1%A8%EF%BC%88%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E5%92%8C%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据结构–链表（循环链表和双向链表）一、循环链表 循环链表和单链表不同的是，他的尾节点的指针指向了头节点，这样在一些很多操作中，就不怕丢失头节点，即使指针指向的是中间节点，也可以通过移动找到头节点以及此节点以前的节点。 在建立循环链表时，可以使用一个空余的节点做头节点，不存储数据，这样会使增删操作方便的多，不用考虑删除的或者增加的是第一个节点而要改变尾指针。以下是具体实现操作1. 循环链表定义12345678/*定义循环链表结构* 其中结构体变量Node 用来定义链表节点* 结构体指针LinkList 用来定义头结点*/typedef struct Node&#123; int data; struct Node * next;&#125;Node, *LinkList; 2. 循环链表初始化1234567//初始化void InitList(LinkList * l)&#123; *l = (LinkList)malloc(sizeof(Node)); (*l)-&gt;next = *l;//将尾节点的指针域指向头结点 (*l)-&gt;data = NULL;//将头结点的Data域赋为空，借此区分头结点和其他节点&#125; 3. 循环链表尾插法建立12345678910111213141516171819202122//尾插法建立新链表，当输入值为-1时停止输入void creatList(LinkList l)&#123; int data; Node * s;//申明一个新建节点 Node * r = l;//申明一个移动节点 while (true) &#123; scanf("%d", &amp;data); if (data != -1) &#123; s = (Node *)malloc(sizeof(Node)); s-&gt;data = data; r-&gt;next = s; //修改指针 s-&gt;next = l; r = r-&gt;next; &#125; else&#123;//判断当输入值为-1时停止输入 break; &#125; &#125;&#125; 4. 循环链表插入节点123456789101112131415161718192021222324252627282930//在i位置插入值为Data的节点void InsertNode(LinkList l, int i, int data)&#123; Node * r = l;//查找指向待插入位置 Node * p = l;//指向待插入节点前的节点 Node * s;//指向新建的节点 int j = 0; if (i &lt;= 0)//判断插入位置 &#123; printf("插入位置小于1"); return; &#125; //移动p节点，p节点是待删除节点的前一个节点 while (p-&gt;next-&gt;next != l &amp;&amp; j != i - 1) &#123; p = p-&gt;next; j++; &#125; r = p-&gt;next; if (r == l)//插入位置大于链表长度 &#123; printf("找不到待插入位置"); return; &#125; //新建节点并插入 s = (Node *)malloc(sizeof(Node)); s-&gt;data = data; p-&gt;next = s; s-&gt;next = r;&#125; 5. 循环链表删除节点123456789101112131415161718192021222324252627void deleteList(LinkList l, int i)&#123; Node * r = l;//查找指向待删除节点 Node * p = l;//指向待节点节点前的节点 int j = 0; if (i &lt;= 0)//判断删除位置 &#123; printf("删除位置小于1"); return ; &#125; //移动p节点，p节点是待删除节点的前一个节点 while (p-&gt;next-&gt;next != l &amp;&amp; j != i - 1) &#123; p = p-&gt;next; j++; &#125; r = p-&gt;next; if (r == l)//删除位置大于链表长度 &#123; printf("找不到待删除节点"); return; &#125; //应为有头结点，位置为0，不在删除范围之内所以可以直接删除， //不会影响头结点和尾指针 p-&gt;next = r-&gt;next; free(r);&#125; 6. 循环链表查找12345678910111213141516171819202122//查找节点，查找第i个节点Node * gitNode(LinkList l, int i)&#123; Node * r = l;//指向待查找节点 int j = 0; if (i &lt;= 0)//判断插入位置 &#123; printf("查找位置小于1"); return NULL; &#125; while (r-&gt;next != l &amp;&amp; j != i) &#123; r = r-&gt;next; j++; &#125; if (r == l)//插入位置大于链表长度 &#123; printf("找不到待查找节点"); return NULL; &#125; return r;//将查找到了节点返回&#125; 7. 循环链表输出123456789101112131415/*输出链表* 应为是循环链表，所以不用担心丢失头结点，* 且在定义头结点时将其data域赋值为NULL做了标记* 所以在循环时可以直接循环头指针l，*/void printList(LinkList l)&#123; l = l-&gt;next;//直接开始移动l指针 while (l-&gt;data != NULL)//判断是否循环一圈回到头结点 &#123; printf("%d ", l-&gt;data); l = l-&gt;next; &#125; printf("\n");&#125; 8. 主函数123456789101112131415int main(void)&#123; LinkList l; Node * s; InitList(&amp;l);//初始化链表 creatList(l);//建立新链表 printList(l); InsertNode(l, 3, 5);//在3位置插入值5 printList(l); deleteList(l, 2);//删除2节点 printList(l); s = gitNode(l, 4);//查找4节点 printf("%d", s-&gt;data); return 0;&#125; 二、双向链表双向链表相比于普通链表，每个节点增加了一个指向前一个节点的指针，如此则可以很方便的找到一个节点的前驱节点，在进行修改指针操作时，不再需要一个指向前驱节点的指针。同样的在双向链表中，为了算法方便，也使用一个空余的节点作为头结点,在初始化时定义。 1.双向链表结构体定义1234567//双向链表结构体//定义结构体类型Node，和结构体指针类型LinkListtypedef struct Node&#123; int data;//数据域 struct Node * piror;//指向前节点指针 struct Node * next;//指向后节点指针&#125;Node, *LinkList; 2.双向链表初始化123456789//双向链表初始化，传入的是头指针l的地址void initList(LinkList * l)&#123; (*l) = (Node *)malloc(sizeof(Node)); //一定要将尾节点指针域赋空，在以后移动指针判断操作才不会出现空指针异常 (*l)-&gt;next = NULL;//后指针指空 (*l)-&gt;piror = NULL;//前指针指空 (*l)-&gt;data = NULL;//将其data域赋为空，可区分头结点&#125; 3.建立新的双向链表12345678910111213141516171819202122232425//建立新链表，输入要插入的内容，以-1结束void creatFormTail(LinkList l)&#123; Node * r = l;//移动的指针 Node * s;//指向新建的节点 int c;//新节点data域 int flag = 1; while (flag) &#123; scanf("%d", &amp;c); if (c != -1) &#123; s = (Node*)malloc(sizeof(Node)); s-&gt;data = c; s-&gt;next = r-&gt;next;//新节点的后指针赋空 s-&gt;piror = r; r-&gt;next = s; r = r-&gt;next; &#125; else &#123; flag = 0; &#125; &#125;&#125; 4.双向链表插入操作在插入操作时，就可以体现出双向链表的优势，只需要一个指针指向待插入位置，通过r-&gt;piror就可以完成插入操作 1234567891011121314151617181920212223242526272829303132//在循环链表l的第i个元素前插入一个节点void lnslist(LinkList l, int i, int data)&#123; Node * r, *s; int j = 0; r = l; //首先判断插入位置是否合法 if (i &lt;= 0) &#123; //插入位置小于1 printf("查找序号不合法"); return NULL; &#125; //寻找插入位置 while ((r != NULL) &amp;&amp; j&lt;i) &#123; r = r-&gt;next; j++; &#125; if (r == NULL) &#123; //插入位置大于链表长度 printf("查找序号不合法"); return NULL; &#125; s = (Node *)malloc(sizeof(Node)); s-&gt;data = data; s-&gt;piror = r-&gt;piror;//插入节点前指针指向前一节点 r-&gt;piror-&gt;next = s;//插入节点前一节点后指针指向插入节点 s-&gt;next = r;//插入节点与后节点双向联通 r-&gt;piror = s;&#125; 5. 删除双向链表节点同样在删除中，也只需要一个指针就可以完成操作 1234567891011121314151617181920212223242526272829//删除第i个元素，并将该元素内容存入data中void deleteList(LinkList l, int i, int * data)&#123; Node * r = l; int j = 0; if (i &lt;= 0) &#123; //删除位置小于1 printf("查找序号不合法"); return NULL; &#125; //寻找删除位置 while (r != NULL &amp;&amp; j &lt; i) &#123; r = r-&gt;next; j++; &#125; if (r == NULL) &#123; //删除位置大于链表长度 printf("查找序号不合法"); return NULL; &#125; //修改指针删除 r-&gt;piror-&gt;next = r-&gt;next;//使前一个节点尾指针指向后一个节点 r-&gt;next-&gt;piror = r-&gt;piror;//使后一个节点的头指针指向前一个节点 *data = r-&gt;data; free(r);&#125; 6. 复制链表1234567891011121314151617181920//链表复制,返回复制后链表LinkList cloneList(LinkList l)&#123; Node * r = l-&gt;next;//定义一个指向原链表的移动指针 Node * p;//定义一个指向新链表的移动指针 LinkList s, l2;//s指向是新建立的节点，l2为新链表的头指针 initList(&amp;l2); p = l2;//将p指向头，方便尾插法建表 while (r != NULL) &#123; s = (Node *)malloc(sizeof(Node)); s-&gt;data = r-&gt;data;//给新节点复制值 r = r-&gt;next;//指向原链表下一个待复制位置 s-&gt;next = p-&gt;next;//新节点的后指针赋空 s-&gt;piror = p; p-&gt;next = s; p = p-&gt;next;//p指向新最新节点 &#125; return l2;&#125; 7. 链表输出及主函数1234567891011121314151617181920212223242526//链表输出void printList(LinkList l)&#123; Node * r = l-&gt;next; while (r != NULL) &#123; printf("%d ", r-&gt;data); r = r-&gt;next; &#125; printf("\n");&#125;//主函数int main(void)&#123; LinkList l; Node * s; int data; initList(&amp;l); creatFormTail(l);//建立链表 printList(l); deleteList(l, 2, &amp;data);//删除链表元素 printList(l); s = cloneList(l);//复制l链表 printList(s); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构--链表（单链表）]]></title>
    <url>%2F2019%2F09%2F26%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E9%93%BE%E8%A1%A8%EF%BC%88%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据结构–链表（单链表）从今天开始，工作室统一开始复习算法，明年蓝桥杯都进国赛哈哈哈。去年蓝桥杯的国赛还是有些遗憾，今年一定要好好学学，拿个国二。 链表是数据结构中最基础的存储结构。相比于数组，他是动态的，不论从存储内容还是存储长度来说都是动态的。可以借此延伸出其他很多数据结构。 对以下程序的变量说明：Node 结构体变量，一般用来定义节点；LinkList结构体指针，一般用来定义头节点；l一般用来指向头结点，引导整个链表；s，r一般用于操作过程中用来移动的指针。 1. 链表基本结构体的定义：123456//定义结构体typedef struct Node&#123; int data; struct Node * next;&#125;Node, *LinkList;//一个结构体类型的Node，一个指向结构体类型的指针变量 LinkList~ 其中定义两个变量，一个结构体类型的Node，一个指向结构体类型的指针变量 LinkList,在后续的算法中，这两者作用基本相同，LinkList用来申明头指针，Node * 用来申明节点指针，方便区分。 2. 链表初始化1234567//初始化InitList(LinkList * l)&#123; //分配头结点 *l = (LinkList)malloc(sizeof(Node)); (*l)-&gt;next = NULL; //让头节点next域为空&#125; 初始化链表的操作使用了二重指针，应为要头结点l是在主函数申明好的，在初始化函数中要改变指针的值，就需要二重指针，用LinkList * 申明。 3. 头插法建立新链表123456789101112131415161718192021222324//头插法建表，依次输入想要插入的值，以-1结束void CreatFormHead(LinkList l)&#123; Node * s; int c; int flag = 1; while (flag)//循环标记 &#123; scanf("%d", &amp;c); if (c != -1) &#123; //建立一个新节点 s = (Node*)malloc(sizeof(Node)); //修改指针 s-&gt;data = c; s-&gt;next = l-&gt;next; l-&gt;next = s; &#125; else &#123; flag = 0; &#125; &#125;&#125; 此方法在建立链表时，始终从头结点后面插入新的节点，所以插入以后可以将输入逆序。修改指针顺序为先修改新增节点的指针指向头结点的下一个节点，再让头结点指向新增节点。 4.尾插法建立新链表12345678910111213141516171819202122232425//尾插法建表,与头插法类似，不过此方法建表为正序void CreatFormTail(LinkList l)&#123; Node * s; //尾插需要有一个移动的指针，为了不丢失头结点则新定义一个指针r Node * r = l; int c; int flag = 1; while (flag) &#123; scanf("%d", &amp;c); if (c != -1) &#123; s = (Node*)malloc(sizeof(Node)); s-&gt;data = c; r-&gt;next = s; r = r-&gt;next; &#125; else &#123; flag = 0; &#125; r-&gt;next = NULL; &#125;&#125; 此方法建立新链表时，是从链表节点的尾部新增节点，所以插入的顺序是正序。应为要保留头结点，所以尾插法还需借用一个行的指针变量r为移动的指针。 5.查找操作5.1 按照元素值key查找123456789101112131415161718192021222324252627282930//按数值key查找节点，将查找到的节点返回Node * locate(LinkList l, int key)&#123; //定义一个可以移动的指针 Node * r = l; while (r-&gt;data != key) &#123; r = r-&gt;next; if (r == NULL) &#123; //key值不存在链表中 printf("查找不到相应值"); return NULL; &#125; &#125; return r;&#125;Node * locate(LinkList l, int key)&#123; Node * r = l; while (r-&gt;data != key) &#123; r = r-&gt;next; if (r == NULL) &#123; printf("查找不到相应值"); return NULL; &#125; &#125; return r;&#125; 5.1 按照顺序查找第i个12345678910111213141516171819202122232425//按序号i(第i个)查找，将查找到的节点返回Node * getNode(LinkList l, int i)&#123; Node * r = l; int j = 0; if (i &lt;= 0) &#123; //查找位置小于1 printf("查找序号不合法"); return NULL; &#125; while (r != NULL || j &lt;= i) &#123; r = r-&gt;next; j++; &#125; if (r == NULL) &#123; //查找位置大于链表长度 printf("查找值不合理"); return NULL; &#125; else return r;&#125; 查找操作时要注意查找位置是否合法，则要进行多次判断 6.删除节点删除第i个元素，并将该元素内容存入 data中 123456789101112131415161718192021222324252627282930//删除第i个元素，并将该元素内容存入data中void DeleteList(LinkList l, int i, int * data)&#123; Node * r = l; Node * p = l; int j = 0; if (i &lt;= 0) &#123; //删除位置小于1 printf("查找序号不合法"); return NULL; &#125; //寻找删除位置 while (p != NULL &amp;&amp; j &lt; i - 1) &#123; p = p-&gt;next; j++; &#125; if (p == NULL) &#123; //删除位置大于链表长度 printf("查找序号不合法"); return NULL; &#125; //修改指针删除 r = p-&gt;next; p-&gt;next = r-&gt;next; data = &amp;(r-&gt;data); free(r);&#125; 删除操作时，先按照查找操作找到相应位置，再移动指针，删除以后要将空间free掉。值得注意的是次过程需要两个指针，一个（p指针）指向待删除节点前的节点，另一个（r)指针指向待删除元素。 7. 在链表第i个元素前插入一个元素123456789101112131415161718192021222324252627282930//在单链表l的第i个元素前插入一个节点void lnslist(LinkList l, int i, int idata)&#123; Node * pre, *s; int j = 0; pre = l; //首先判断插入位置是否合法 if (i &lt;= 0) &#123; //插入位置小于1 printf("查找序号不合法"); return NULL; &#125; //寻找插入位置 while ((pre != NULL) &amp;&amp; (j&lt;i - 1)) &#123; pre = pre-&gt;next; j++; &#125; if (pre == NULL) &#123; //插入位置大于链表长度 printf("查找序号不合法"); return NULL; &#125; s = (Node *)malloc(sizeof(Node)); s-&gt;data = idata; s-&gt;next = pre-&gt;next; pre-&gt;next = s;&#125; 此操作是将查找与头插法相结合的应用。 8.计算链表长度并输出123456789101112131415161718192021222324//计算链表长度int listlength(LinkList l)&#123; Node * p; int j = 0; p = l-&gt;next; while (p != NULL) &#123; p = p-&gt;next; j++; &#125; return j;&#125;//链表输出void PrintList(LinkList l)&#123; Node * r = l-&gt;next; while (r-&gt;next != NULL) &#123; printf("%d ", r-&gt;data); r = r-&gt;next; &#125; printf("%d", r-&gt;data);&#125; 9.链表合并9.1将两个增有序的链表合成一个减有序的链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//链表合并,将两个增有序的链表合成一个减有序的链表LinkList MergeList(LinkList l1, LinkList l2)&#123; Node * s; Node * temp; //首先用其中一个链表头结点作为新链表头结点 s = l1; l1 = l1-&gt;next; s-&gt;next = NULL; //定义一个临时节点，以便头插法建表时移动链表 temp = l2; l2 = l2-&gt;next; free(temp); //l1，l2都指向待比较的节点 while (l1 != NULL &amp;&amp; l2 != NULL) &#123; //选择两者中小的进行插入 if (l1-&gt;data &lt;= l2-&gt;data)&#123; //要先保留l1指针并移动，然后再修改指针 temp = l1; l1 = l1-&gt;next; temp-&gt;next = s-&gt;next; s-&gt;next = temp; &#125; else &#123; temp = l2; l2 = l2-&gt;next; temp-&gt;next = s-&gt;next; s-&gt;next = temp; &#125; &#125; //当一个链表插入结束后，将另一个链表继续使用头插法逐一插入， //以保证建表顺序 if (l1 == NULL) &#123; while (l2 != NULL) &#123; temp = l2; l2 = l2-&gt;next; temp-&gt;next = s-&gt;next; s-&gt;next = temp; &#125; &#125; else &#123; while (l1 != NULL) &#123; temp = l1; l1 = l1-&gt;next; temp-&gt;next = s-&gt;next; s-&gt;next = temp; &#125; &#125; return s;&#125; 此过程中，值得注意的就是（1）在合并过程中，应为一开始将头结点指向了空，且在合并指针变化过程中会使当前节点指针域改变，所以要先有一个temp指针为当前节点修改，l1指针直接指向下一个节点。（2）还有一点就是合并过程中，当一个链表先结束时，另一个链表也要继续头插法插入不能直接插在后面。 9.2 将两个增有序的链表合成一个增有序的链表1234567891011121314151617181920212223242526272829303132333435//将两个增有序的链表合成一个增有序的链表LinkList mergelinklist(LinkList la, LinkList lb)&#123; Node * r, *p, *s; LinkList lc; //与上一个插入类似，先建立头结点 r = la-&gt;next; p = lb-&gt;next; lc = la; lc-&gt;next = NULL; s = lc; while (r-&gt;next != NULL || p-&gt;next != NULL) &#123; //应为是尾插，本来就有移动临时节点，所以和标准尾插一样 if (r-&gt;data &lt;= p-&gt;data) &#123; s-&gt;next = r; s = r; r = r-&gt;next; &#125; else &#123; s-&gt;next = p; s = p; p = p-&gt;next; &#125; &#125; //一方插入结束后，应为用尾插法，所以可以将另一方直接接到新节点后面 if (r-&gt;next != NULL) s-&gt;next = r; else s-&gt;next = p; free(lb); return(lc);&#125; 10.主函数123456789101112131415161718192021222324252627282930int main(void)&#123; LinkList l1; LinkList l2; LinkList s; int data = 0; InitList(&amp;l1); InitList(&amp;l2); printf("请输入第一个链表"); CreatFormTail(l1);//尾插法建表1 PrintList(l1); printf("请输入第二个链表"); CreatFormHead(l2);//头差法建表2 PrintList(l2); printf("\n"); lnslist(l1, 2, 5);//在l1链表第2个位置插入5 PrintList(l1); printf("\n"); DeleteList(l2, 2, &amp;data);//删除元素 printf("%d", data);//输出删除元素 printf("\n"); PrintList(l2); printf("\n"); s = locate(l2, 3);//查找值为3的节点 printf("%d",s-&gt;data); printf("\n"); s = MergeList(l1, l2);//两链表合并 PrintList(s); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-动态规划]]></title>
    <url>%2F2019%2F09%2F25%2F%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[算法篇——动态规划在我看来，动态规划是一种思想，一种解决问题的手段。总的来说就是找到基于当前状态的最优决策。一般通过递归来实现，但与递归不同的，递归有些问题被反复计算多次，但动态规划对每个子问题只计算一次，然后将其保存起来，以后在遇到同样的问题就直接引用，不必直接求解。其重点就是保存以前的状态，通过以前状态推得现有最优态。 例: 数字三角形73 88 1 02 7 4 44 5 2 6 5在上面的数字三角形中寻找一条从顶部到底边的路径，使得路径上所经过的数字之和最大。路径上的每一步都只能往左下或 右下走。只需要求出这个最大和即可，不必给出具体路径。 1. 纯递归解法 单纯用递归很简答就能解决这个问题只用用一个数组 d(i,j)来存储这个数字三角形，用max(i,j)表示从d(i,j)到底边各条路径中最佳数字之和。从d(i,j)出发，下一步只能走d(r+1,j)或者d(r+1,j+1)代码如下 123456789101112131415161718192021222324252627import java.util.Scanner;public class triangle &#123; static int[][] a = new int[100][100]; static int n; public static void main(String[] arge)&#123; Scanner input = new Scanner(System.in); n = input.nextInt(); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; a[i][j] = input.nextInt(); &#125; &#125; System.out.println(sum(0,0)); &#125; static int sum(int i, int j)&#123; int m; if(i == n)&#123; return a[i][j]; &#125; else &#123; int x = sum(i + 1, j); int y = sum(i + 1, j + 1); m = x&gt;y?x:y; return m + a[i][j]; &#125; &#125;&#125; 2. 用记忆递归型的动态规划 如果用上面的单纯递归，一旦数据稍微过大，则会运行超时。应为其中出现了大量的重复计算。此时就需要用到递归的第一个思路，保存每次的值，则可以避免过多的重复。则在每次算出MaxSum值的时候将其保存起来则可以免去重复计算。 1234567891011121314151617181920212223242526272829public class triangle1 &#123; static int[][] a = new int[100][100]; static int n; static int[][] max = new int[100][100]; public static void main(String[] arge)&#123; Scanner input = new Scanner(System.in); n = input.nextInt(); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; a[i][j] = input.nextInt(); max[i][j] = -1; &#125; &#125; System.out.println(sum(0,0)); &#125; static int sum(int i, int j)&#123; if (max[i][j] != -1) return max[i][j]; if(i == n)&#123; return a[i][j]; &#125; else &#123; int x = sum(i + 1, j); int y = sum(i + 1, j + 1); max[i][j] = (x&gt;y?x:y) + a[i][j]; &#125; return max[i][j]; &#125;&#125; 3.递推类型动态规划 上面的方法，虽然可以有效的降低实践复杂度，但是其递归调用要占用大量的堆栈空间，容易早场栈溢出，所以就需要把递归思想转变为递推思想。从最后开始，如下表，倒数第二行的2可以和最后一行的4,5相加，但是和5相加较大，则将7保存下来，以此类推。 30 23 21 20 13 10 7 12 10 10 4 5 2 6 5 12345678910111213141516171819202122public class triangle2 &#123; static int[][] a = new int[100][100]; static int n; static int[][] max = new int[100][100]; public static void main(String[] arge)&#123; Scanner input = new Scanner(System.in); n = input.nextInt(); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; a[i][j] = input.nextInt(); &#125; &#125; for (int i = n-2; i &gt;= 0; i--) &#123; for (int j = 0; j &lt;= i; j++) &#123; int x = a[i+1][j+1] + a[i][j]; int y = a[i+1][j] + a[i][j]; a[i][j] = x&gt;y?x:y; &#125; &#125; System.out.println(a[0][0]); &#125;&#125; 则不难总结出递归到动态规划的一般转化方法：构造一个数组，数组元素的值是递归函数返回值，数组下标值是递归函数参数。从边界开始填充数组。 总结：动态规划的一般解题思路 将原问题分解为若干小问题，将子问题求出后保存，每个子问题只求解一次 保存状态，一般通过一个数组作为状态空间 确定初始状态 确定状态转移方程例如数字三角形12MaxSum[i][j] = a[i][j] (i=n)MaxSum[i][j] = max(MaxSum[i+1][j] + MaxSum[i+1][j+1]) (i!=n)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github学习]]></title>
    <url>%2F2019%2F09%2F19%2Fgithub%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[github基本操作 初始化 git init 状态查看 git status 添加到暂存区 git add 提交到本地库 git commit -m 查看历史 git log / git –online / git reflog 版本前进或后退 git reset –hard &lt;索引值&gt; / git reset –hard HEAD~2 比较工作区与暂存区文件差异 git diff [文件名] 将工作区与本地库文件比较 git diff [本地库历史版本（HEAD）] [文件名] 分支管理 创建分支 git branch [分支名] 查看分支 git branch -v 切换分支 git checkout [分支名] 合并分支 git merge [分支名] 解决冲突 git add git commit -m 远程库操作 创建远程库地址别名 git remote add [远程库地址]git remote add origin git@github.com:xiasf/github-note.git 查看别名 git remote -v 推送 git push [远程库地址名] [分支名] 克隆 git clone [远程库地址名] 拉取 git pull [远程库地址名] [远程库分支] 抓取 git fetch [远程库地址名] [远程库分支] 合并 git merge [远程库地址名/远程库分支] 跨团队合作 团队2进入团队1项目目录,点击fork。 团队2 git clone &lt;远程地址&gt;，修改并commit，git push 提交到远程库。 团队2进入页面，点击 pull requests、 new pull requests， Create pull requests 然后发消息给团队1。 团队1点击pull requests，Commits 、files changed 代码审核。 如果没有问题 则点击 merge pull request 并添加-m信息，结束远程库修改。 团队1将远程库拉取到本地 git pull origin master。]]></content>
      <categories>
        <category>基础知识学习</category>
      </categories>
      <tags>
        <tag>git学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客搭建]]></title>
    <url>%2F2019%2F09%2F19%2Fhexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[hexo博客搭建一、博客基本操作 博客部署到本地 hexo clean 清楚缓存hexo g 生成静态网页hexo s 本地启动预览查看 http://localhost:4000 部署到git服务器上 hexo deploy https://foreverxwwl.github.io/ next主题安装 git clone https://github.com/iissnan/hexo-theme-next themes/next 进入配置文件_config.yml 找到 theme 设置为 theme: next 二、next主题设置 增加标签页等页面 进入next主题的配置文件 _config.yml 找到menu: 将要添加的页面注释删掉 在blog页面 hexo n page tags 增加标签tags页面 hexo n page categories 增加分类categories页面 修改头像姓名等信息 主要参考文档在主题的_config文件中修改 头像 avatar: 修改地址主题 scheme: 设置大的标题、姓名在全局的_config.yml中的 title: 新建一篇博客 hexo n hexo博客搭建 用markdowm编写博客 启用功能 （1）启用侧边栏社交链接 进入主题的_config.yml文件 将social: 一栏的注释取消 （2）启用打赏功能 进入主题的_config.yml文件 将reward项目注释删除 comment：加上用语 也可在后面添加图片 （3）设置头像样式 进入目录 \blog\themes\next\source\css_common\components\sidebar 修改sidebar-author.styl文件中的样式 12345678910111213&gt; &gt; .site-author-image &#123;&gt; &gt; display: block;&gt; &gt; margin: 0 auto;&gt; &gt; padding: $site-author-image-padding;&gt; &gt; max-width: $site-author-image-width;&gt; &gt; height: $site-author-image-height;&gt; &gt; border: $site-author-image-border-width solid $site-author-image-border-color;&gt; &gt; border-radius: 50%;&gt; &gt; transition: 3s all;&gt; &gt; &#125;&gt; &gt; .site-author-image:hover&#123;&gt; &gt; transform: rotate(360deg);&gt; &gt; &#125; （3）设置首页阅读全文 在主题配置文件中找到auto_excerpt:选项 将false 改为true 并设置可看长度 也可在博客编辑时在相应位置添加;此代码以下的点击查看 （4）添加动态背景 在主题配置文件找到canvas 默认都是关闭的 将需要的设置为true （5）修改文章内链接样式 进入F:\blog\themes\next\source\css_common\components\post\post.sty 在尾部添加样式 123456789.post-body p a&#123; color: #345; border-bottom: none; font-size: 13px;/*字体大小*/ font-weight: 500; /*字体粗细*/ &amp;:hover&#123; color: #fcfcfc; &#125;&#125; （6）修改文章底部标签 进入F:\blog\themes\next\layout_macro\post.swig 修改 tag.path 可将这行的 # 替换成别的 1&lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt; &lt;i class="fa fa-tag"&gt;&lt;/i&gt; （7）Valine评论系统 进入主题配置文件 打开 valine https://leancloud.cn/ 网站配置appid并在配置文件中使用 （8）搜索，统计功能 都是进入next主题官网 开启第三方服务 三、一个小问题 再部署的时候 提示 ERROR Deployer not found: git按照晚上提示安装插件总是报错 npm install hexo-deployer-git –save然后用淘宝NPM镜像的“hexo-deployer-git”试了一下，成功了指令：$ cnpm install hexo-deployer-git –save]]></content>
      <categories>
        <category>基础知识学习</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
</search>
