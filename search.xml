<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JDBC连接池与Template]]></title>
    <url>%2F2019%2F10%2F05%2FJDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%B8%8ETemplate%2F</url>
    <content type="text"><![CDATA[jdbc连接池与Template数据库连接池 概念：其实就是一个容器(集合)，存放数据库连接的容器。当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。 好处：1. 节约资源 2. 用户访问高效 C3P0：数据库连接池技术。Druid：数据库连接池实现技术，由阿里巴巴提供。 c3p0数据库连接池 导入jar包 c3p0-0.9.5.2.jar 2. mchange-commons-java-0.2.12.jar 定义配置文件c3p0-cnfig.xml 在定义配置文件时，也要注意版本问题，可直接放在src目录下 创建数据库连接池对象ComboPooledDataSource() DataSource ds = new ComboPooledDataSource(); 获取连接gitConnection Connection conn = ds.getConnection(); Druid数据库连接池 导入jar包 druid-1.0.9.jar 定义配置文件： 是properties形式的 可以叫任意名称，可以放在任意目录下 加载配置文件。Properties 123InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream("druid.properties");Properties pro = new Properties();pro.load(is); 获取数据库连接池对象：通过工厂来来获取 DruidDataSourceFactory并 1DataSource ds = DruidDataSourceFactory.createDataSource(pro); 获取连接：getConnection 1Connection conn = ds.getConnection(); 定义Druid数据库连接池工具类JDBCUtils 提供静态代码块加载配置文件，初始化连接池对象 获取连接方法：通过数据库连接池获取连接 释放资源 获取连接池的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class JDBCUtils &#123; //定义一个成员变量 private static DataSource ds = null;; static &#123; try &#123; //1.加载配置文件 Properties pro = new Properties(); pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream("Druid.properties")); //获取获取数据库连接池对象dataSource ds = DruidDataSourceFactory.createDataSource(pro); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取连接 */ public static Connection getConnection() throws SQLException &#123; return ds.getConnection(); &#125; /** * 释放资源 */ public static void close(Statement statement, Connection connection) &#123; close(null,statement,connection); &#125; public static void close(ResultSet resultSet, Statement statement, Connection connection)&#123; if (resultSet != null)&#123; try &#123; resultSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (statement != null)&#123; try &#123; statement.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (connection != null)&#123; try &#123; connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 获取连接池方法 */ public static DataSource getDataSource()&#123; return ds; &#125;&#125; Spring JDBC是Spring框架对jdbc的简单封装，提供了JDBCTemplate对象简化jdbc开发 导入jar包 创建JDBCTemplate对象，依赖于数据源DataSource JDBCTemplate template = new JDBCTemplate（ds）； 调用JDBCTemplate方法操作 update() 方法，执行增删改语句 queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合，查询的结果集长度只能是1。 123456public void test4()&#123; String sql = "select * from emp where id = ? or id = ?"; Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002); System.out.println(map); //&#123;id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20&#125;&#125; queryForList():查询结果将结果集封装为list集合 将每一条记录封装为一个Map集合，再将Map集合装载到List集合中12345678public void test5()&#123; String sql = "select * from emp"; List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql); for (Map&lt;String, Object&gt; stringObjectMap : list) &#123; System.out.println(stringObjectMap); &#125;&#125; query():查询结果，将结果封装为JavaBean对象,emp为自定义的对象有成员变量，getset函数以及tostring方法。 12345678910111213141516171819202122232425262728293031323334public void test6()&#123; String sql = "select * from emp"; List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() &#123; @Override public Emp mapRow(ResultSet rs, int i) throws SQLException &#123; Emp emp = new Emp(); int id = rs.getInt("id"); String ename = rs.getString("ename"); int job_id = rs.getInt("job_id"); int mgr = rs.getInt("mgr"); Date joindate = rs.getDate("joindate"); double salary = rs.getDouble("salary"); double bonus = rs.getDouble("bonus"); int dept_id = rs.getInt("dept_id"); emp.setId(id); emp.setEname(ename); emp.setJob_id(job_id); emp.setMgr(mgr); emp.setJoindate(joindate); emp.setSalary(salary); emp.setBonus(bonus); emp.setDept_id(dept_id); return emp; &#125; &#125;); for (Emp emp : list) &#123; System.out.println(emp); &#125; &#125; query的参数：RowMapper 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装 new BeanPropertyRowMapper&lt;类型&gt;(类型.class)，如果类型.class中的参数和数据库匹配，那么就会自动封装。1234567public void test6_2()&#123; String sql = "select * from emp"; List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class)); for (Emp emp : list) &#123; System.out.println(emp); &#125; &#125; queryForObject：查询结果，将结果封装为对象，一般用于聚合函数查询 12345public void test7()&#123; String sql = "select count(id) from emp"; Long total = template.queryForObject(sql, Long.class); System.out.println(total);&#125;]]></content>
      <categories>
        <category>javaWeb</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC基本概念与操作]]></title>
    <url>%2F2019%2F10%2F05%2FJDBC%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[jdbc基本概念与操作jdbc：Java DataBase Connectivity Java 数据库连接本质：其实是官方定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。 1. 导入驱动jar包2. 注册驱动在注册驱动时，新版jdbc注册驱动的语句要在中间加上cj。 1Class.forName("com.mysql.cj.jdbc.Driver"); 3. 获取数据库连接对象 Connection1Connection connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/workstation?characterEncoding=UTF-8&amp;serverTimezone=UTC&amp;useSSL=false", "root", "123456"); DriverManager：驱动管理对象 注册驱动功能：告诉程序该使用那个数据库驱动jar包 Class.forName(“com.mysql.jdbc.Driver”); 获取数据库连接： static Connection getConnection(String url, String user, String password) url配置：jdbc:mysql://ip地址(域名):端口号/数据库名称 jdbc:mysql://localhost:3306/workstation?characterEncoding=UTF-8&amp;serverTimezone=UTC&amp;useSSL=false Connection：数据库连接对象 可以获取执行sql的对象Statement Statement createStatement() PreparedStatement prepareStatement(String sql) 管理事务 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 提交事务：commit() 回滚事务：rollback() 在获取数据库连接对象时，应为使用了最新版mysql的jdbc驱动，在看视频时按照原本的配置方法配置url值，不断报下面的错，在百度了半下午以后才找到问题所在，旧版本可以“jdbc:mysql://localhost:3306/db3”但新版本必须配置为上面的内容。 1Exception in thread &quot;main&quot; java.sql.SQLException: The server time zone value is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support. 4. 获取执行sql语句的对象 Statement1Statement statement = connection.createStatement(); Statement: 执行sql的对象 boolean execute(String sql) ：可以执行任意的sql int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句。返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。 ResultSet executeQuery(String sql) ：执行DQL（select)语句 5. 定义sql并执行sql，接受返回结果12String sql = "update users set Upasswords = '123345567' where number = 2";int i = statement.executeUpdate(sql); 6. 处理结果并释放资源123System.out.println(i);statement.close();connection.close(); 7. ResultSet: 结果集对象,封装查询结果 boolean next(): 游标向下移动一行（默认指向表头行），判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true getXxx(参数):获取数据 Xxx：代表数据类型 如： int getInt() ，String getString() 参数： int：代表列的编号,从1开始 如： getString(1) String：代表列名称。 如： getDouble(“balance”) 12345678//循环判断游标是否是最后一行末尾。while(rs.next())&#123;、//获取数据int id = rs.getInt(1);//当前行第一列String name = rs.getString("name");//当前行“name”列double balance = rs.getDouble(3);System.out.println(id + "---" + name + "---" + balance);&#125; 8. PreparedStatement：执行sql的对象 SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题 解决sql注入问题：使用PreparedStatement对象来解决 使用： sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?; 获取执行sql语句的对象 PreparedStatement Connection.prepareStatement(String sql) 给？赋值：setXxx(参数1,参数2) 执行sql，接受返回结果，不需要传递sql语句123456789//定义SQLString sql = "update users set Upasswords = ? where number = ?";//获取pstmt对象preparedStatement = conn.prepareStatement(sql);//给SQL赋值preparedStatement.setInt(1, 123);preparedStatement.setInt(2, 2);//执行int cont = preparedStatement.executeUpdate();]]></content>
      <categories>
        <category>javaWeb</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构--链表（静态链表）]]></title>
    <url>%2F2019%2F10%2F02%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E9%93%BE%E8%A1%A8%EF%BC%88%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据结构–链表（静态链表） 静态链表中，应为没有指针使用，所以我们用一个结构体数组来存放节点，用cur来代替指针，存放下一个元素在结构体数组中的位置。 在建立链表时，我们把这个结构体数组看成两个链，一个是没有存放内容的备用链，一个是存放了内容的使用链，同样的我们确定一个头结点data不存放数据，cur存放的是下一个可插入元素的节点位置，初始化为1，为备用链的头，确定一个尾节点，data也不存放数据，cur存放的是第一个存放了数据的节点的位置，为使用链的头。 这样定义的好处是：其一，当链表中间有元素被删除时，备用链头cur值存放中间被删节点的位置，这样下次插入就可以直接在此插入。所以删除节点时可以不移动其他元素，下次插入只需要在备用链依次取就好。 其二，用最后一个位置存放使用链的头，是防止当结构体数组中第一个节点被删去，会丢失头节点位置，通过这个保存则可以随意删除。 静态链表中存放的数据彼此之间是非线性不连续的，是通过cur代替指针将其联系起来。 优点：再插入和删除时候，只需要修改游标，不需要移动元素，从而改进了顺序存储结构中插入和删除操作需要移动大量元素的缺点。 缺点：没有解决连续存储分配带来的表长难以确定的问题；失去了顺序存储结构随机存取的特性。下面是具体实现过程 1. 结构体定义123456#define MAXSIZE 7//定义结构typedef struct&#123; int data;//数据域 int cur;//下一个节点的下标&#125;StaticList[MAXSIZE]; 2. 初始化静态链表123456789101112//初始化静态链表,主要任务是让每一个节点cur指向下一个节点void InitList(StaticList l)&#123; for (int i = 0; i &lt; MAXSIZE - 1; i++) &#123; l[i].cur = i + 1; &#125; //备用链表的最后一个空元素的cur指向0，这样才可以再分配节点时判断是否已经存满 l[MAXSIZE - 2].cur = 0; //最后一个节点是使用链的头结点，初始化为0； l[MAXSIZE - 1].cur = 0;&#125; 3. 寻找可用空间1234567891011//在插入元素时，为带插入元素寻找一个空间下标int Malloc(StaticList l)&#123; //l[0].cur代表下一个可以插入的位置 int i = l[0].cur; if (i)&#123;//如果位置是0则不能插入 //位置不是0，则在此位置插入，并且将其下一个位置赋给头 l[0].cur = l[i].cur; &#125; return i;&#125; 4. 删除元素释放空间12345678//删除元素时，将其位置保存，方便下次插入void Free(StaticList l, int k)&#123; //将头中保存的下个可插入节点的位置赋给此待删除节点 l[k].cur = l[0].cur; //将次待删除节点位置赋给头，通过这两部操作将此节点放入了待插入链 l[0].cur = k;&#125; 5. 静态链表中元素个数1234567891011121314//求静态链表中元素个数，不包括头尾节点int ListLength(StaticList L)&#123; //L[MAXSIZE - 1]是已用链的头结点，.cur是已用链第一个节点位置 int i = L[MAXSIZE - 1].cur; int j = 0; while (i) &#123; j++; //不断查找到下一个已用链，最后一个已用链cur值为0 i = L[i].cur; &#125; return j;&#125; 6. 在i位置插入元素12345678910111213141516171819202122232425//静态链表中i位置插入一个元素void lnsertList(StaticList L, int i, int data)&#123; //判断插入点是否合理,要按照顺序插入不能跳跃插入 if (i&lt;1 || i&gt;ListLength(L) + 1) &#123; printf("插入点不合理"); return; &#125; int j = Malloc(L);//分配到插入位置 int k = MAXSIZE - 1;//k表示已用链头结点 if (j) &#123; //循环让k指向待插入位置i的已用链中前一个位置 for (int l = 1; l &lt;= i - 1; l++) &#123; k = L[k].cur; &#125; L[j].data = data; //将新节点与上一个节点连接 L[j].cur = L[k].cur; //将新节点与下一个节点连接 L[k].cur = j; &#125;&#125; 7. 删除第i个元素123456789101112131415161718192021222324//删除第i个元素，将值放入data中void DeleteList(StaticList L, int i, int *data)&#123; if (i &lt; 1 || i &gt;= ListLength(L)) &#123; printf("删除位置不合法"); return; &#125; //k指向已用链头结点 int k = MAXSIZE - 1; //循环让k指向已用链中k待删除节点的上一个节点 for (int l = 1; l &lt;= i - 1; l++) &#123; k = L[k].cur; &#125; //j指向待删除节点 int j = L[k].cur; *data = L[j].data; //将上一个节点与下一个节点相连 L[k].cur = L[j].cur; //将本节点置空加入备用链 Free(L, j);&#125; 8. 输出链表12345678910111213//输出链表void printList(StaticList L)&#123; //k指向已用链头结点 int k = MAXSIZE - 1; //已用链的cur不为0时输出 while (L[k].cur) &#123; k = L[k].cur; printf("%d ", L[k].data); &#125; printf("\n");&#125; 9. 主函数1234567891011121314151617181920212223242526int main(void)&#123; StaticList L; int j = 0; int data; InitList(L); printf("输入元素，以-1结尾\n"); while (1) &#123; scanf("%d", &amp;data); if (data != -1) &#123; j++; lnsertList(L, j, data); &#125; else &#123; break; &#125; &#125; printList(L); DeleteList(L, 2, &amp;data); printf("删除的元素值为 %d\n", data); printList(L); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构--链表（循环链表和双向链表）]]></title>
    <url>%2F2019%2F09%2F27%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E9%93%BE%E8%A1%A8%EF%BC%88%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E5%92%8C%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据结构–链表（循环链表和双向链表）一、循环链表 循环链表和单链表不同的是，他的尾节点的指针指向了头节点，这样在一些很多操作中，就不怕丢失头节点，即使指针指向的是中间节点，也可以通过移动找到头节点以及此节点以前的节点。 在建立循环链表时，可以使用一个空余的节点做头节点，不存储数据，这样会使增删操作方便的多，不用考虑删除的或者增加的是第一个节点而要改变尾指针。以下是具体实现操作1. 循环链表定义12345678/*定义循环链表结构* 其中结构体变量Node 用来定义链表节点* 结构体指针LinkList 用来定义头结点*/typedef struct Node&#123; int data; struct Node * next;&#125;Node, *LinkList; 2. 循环链表初始化1234567//初始化void InitList(LinkList * l)&#123; *l = (LinkList)malloc(sizeof(Node)); (*l)-&gt;next = *l;//将尾节点的指针域指向头结点 (*l)-&gt;data = NULL;//将头结点的Data域赋为空，借此区分头结点和其他节点&#125; 3. 循环链表尾插法建立12345678910111213141516171819202122//尾插法建立新链表，当输入值为-1时停止输入void creatList(LinkList l)&#123; int data; Node * s;//申明一个新建节点 Node * r = l;//申明一个移动节点 while (true) &#123; scanf("%d", &amp;data); if (data != -1) &#123; s = (Node *)malloc(sizeof(Node)); s-&gt;data = data; r-&gt;next = s; //修改指针 s-&gt;next = l; r = r-&gt;next; &#125; else&#123;//判断当输入值为-1时停止输入 break; &#125; &#125;&#125; 4. 循环链表插入节点123456789101112131415161718192021222324252627282930//在i位置插入值为Data的节点void InsertNode(LinkList l, int i, int data)&#123; Node * r = l;//查找指向待插入位置 Node * p = l;//指向待插入节点前的节点 Node * s;//指向新建的节点 int j = 0; if (i &lt;= 0)//判断插入位置 &#123; printf("插入位置小于1"); return; &#125; //移动p节点，p节点是待删除节点的前一个节点 while (p-&gt;next-&gt;next != l &amp;&amp; j != i - 1) &#123; p = p-&gt;next; j++; &#125; r = p-&gt;next; if (r == l)//插入位置大于链表长度 &#123; printf("找不到待插入位置"); return; &#125; //新建节点并插入 s = (Node *)malloc(sizeof(Node)); s-&gt;data = data; p-&gt;next = s; s-&gt;next = r;&#125; 5. 循环链表删除节点123456789101112131415161718192021222324252627void deleteList(LinkList l, int i)&#123; Node * r = l;//查找指向待删除节点 Node * p = l;//指向待节点节点前的节点 int j = 0; if (i &lt;= 0)//判断删除位置 &#123; printf("删除位置小于1"); return ; &#125; //移动p节点，p节点是待删除节点的前一个节点 while (p-&gt;next-&gt;next != l &amp;&amp; j != i - 1) &#123; p = p-&gt;next; j++; &#125; r = p-&gt;next; if (r == l)//删除位置大于链表长度 &#123; printf("找不到待删除节点"); return; &#125; //应为有头结点，位置为0，不在删除范围之内所以可以直接删除， //不会影响头结点和尾指针 p-&gt;next = r-&gt;next; free(r);&#125; 6. 循环链表查找12345678910111213141516171819202122//查找节点，查找第i个节点Node * gitNode(LinkList l, int i)&#123; Node * r = l;//指向待查找节点 int j = 0; if (i &lt;= 0)//判断插入位置 &#123; printf("查找位置小于1"); return NULL; &#125; while (r-&gt;next != l &amp;&amp; j != i) &#123; r = r-&gt;next; j++; &#125; if (r == l)//插入位置大于链表长度 &#123; printf("找不到待查找节点"); return NULL; &#125; return r;//将查找到了节点返回&#125; 7. 循环链表输出123456789101112131415/*输出链表* 应为是循环链表，所以不用担心丢失头结点，* 且在定义头结点时将其data域赋值为NULL做了标记* 所以在循环时可以直接循环头指针l，*/void printList(LinkList l)&#123; l = l-&gt;next;//直接开始移动l指针 while (l-&gt;data != NULL)//判断是否循环一圈回到头结点 &#123; printf("%d ", l-&gt;data); l = l-&gt;next; &#125; printf("\n");&#125; 8. 主函数123456789101112131415int main(void)&#123; LinkList l; Node * s; InitList(&amp;l);//初始化链表 creatList(l);//建立新链表 printList(l); InsertNode(l, 3, 5);//在3位置插入值5 printList(l); deleteList(l, 2);//删除2节点 printList(l); s = gitNode(l, 4);//查找4节点 printf("%d", s-&gt;data); return 0;&#125; 二、双向链表双向链表相比于普通链表，每个节点增加了一个指向前一个节点的指针，如此则可以很方便的找到一个节点的前驱节点，在进行修改指针操作时，不再需要一个指向前驱节点的指针。同样的在双向链表中，为了算法方便，也使用一个空余的节点作为头结点,在初始化时定义。 1.双向链表结构体定义1234567//双向链表结构体//定义结构体类型Node，和结构体指针类型LinkListtypedef struct Node&#123; int data;//数据域 struct Node * piror;//指向前节点指针 struct Node * next;//指向后节点指针&#125;Node, *LinkList; 2.双向链表初始化123456789//双向链表初始化，传入的是头指针l的地址void initList(LinkList * l)&#123; (*l) = (Node *)malloc(sizeof(Node)); //一定要将尾节点指针域赋空，在以后移动指针判断操作才不会出现空指针异常 (*l)-&gt;next = NULL;//后指针指空 (*l)-&gt;piror = NULL;//前指针指空 (*l)-&gt;data = NULL;//将其data域赋为空，可区分头结点&#125; 3.建立新的双向链表12345678910111213141516171819202122232425//建立新链表，输入要插入的内容，以-1结束void creatFormTail(LinkList l)&#123; Node * r = l;//移动的指针 Node * s;//指向新建的节点 int c;//新节点data域 int flag = 1; while (flag) &#123; scanf("%d", &amp;c); if (c != -1) &#123; s = (Node*)malloc(sizeof(Node)); s-&gt;data = c; s-&gt;next = r-&gt;next;//新节点的后指针赋空 s-&gt;piror = r; r-&gt;next = s; r = r-&gt;next; &#125; else &#123; flag = 0; &#125; &#125;&#125; 4.双向链表插入操作在插入操作时，就可以体现出双向链表的优势，只需要一个指针指向待插入位置，通过r-&gt;piror就可以完成插入操作 1234567891011121314151617181920212223242526272829303132//在循环链表l的第i个元素前插入一个节点void lnslist(LinkList l, int i, int data)&#123; Node * r, *s; int j = 0; r = l; //首先判断插入位置是否合法 if (i &lt;= 0) &#123; //插入位置小于1 printf("查找序号不合法"); return NULL; &#125; //寻找插入位置 while ((r != NULL) &amp;&amp; j&lt;i) &#123; r = r-&gt;next; j++; &#125; if (r == NULL) &#123; //插入位置大于链表长度 printf("查找序号不合法"); return NULL; &#125; s = (Node *)malloc(sizeof(Node)); s-&gt;data = data; s-&gt;piror = r-&gt;piror;//插入节点前指针指向前一节点 r-&gt;piror-&gt;next = s;//插入节点前一节点后指针指向插入节点 s-&gt;next = r;//插入节点与后节点双向联通 r-&gt;piror = s;&#125; 5. 删除双向链表节点同样在删除中，也只需要一个指针就可以完成操作 1234567891011121314151617181920212223242526272829//删除第i个元素，并将该元素内容存入data中void deleteList(LinkList l, int i, int * data)&#123; Node * r = l; int j = 0; if (i &lt;= 0) &#123; //删除位置小于1 printf("查找序号不合法"); return NULL; &#125; //寻找删除位置 while (r != NULL &amp;&amp; j &lt; i) &#123; r = r-&gt;next; j++; &#125; if (r == NULL) &#123; //删除位置大于链表长度 printf("查找序号不合法"); return NULL; &#125; //修改指针删除 r-&gt;piror-&gt;next = r-&gt;next;//使前一个节点尾指针指向后一个节点 r-&gt;next-&gt;piror = r-&gt;piror;//使后一个节点的头指针指向前一个节点 *data = r-&gt;data; free(r);&#125; 6. 复制链表1234567891011121314151617181920//链表复制,返回复制后链表LinkList cloneList(LinkList l)&#123; Node * r = l-&gt;next;//定义一个指向原链表的移动指针 Node * p;//定义一个指向新链表的移动指针 LinkList s, l2;//s指向是新建立的节点，l2为新链表的头指针 initList(&amp;l2); p = l2;//将p指向头，方便尾插法建表 while (r != NULL) &#123; s = (Node *)malloc(sizeof(Node)); s-&gt;data = r-&gt;data;//给新节点复制值 r = r-&gt;next;//指向原链表下一个待复制位置 s-&gt;next = p-&gt;next;//新节点的后指针赋空 s-&gt;piror = p; p-&gt;next = s; p = p-&gt;next;//p指向新最新节点 &#125; return l2;&#125; 7. 链表输出及主函数1234567891011121314151617181920212223242526//链表输出void printList(LinkList l)&#123; Node * r = l-&gt;next; while (r != NULL) &#123; printf("%d ", r-&gt;data); r = r-&gt;next; &#125; printf("\n");&#125;//主函数int main(void)&#123; LinkList l; Node * s; int data; initList(&amp;l); creatFormTail(l);//建立链表 printList(l); deleteList(l, 2, &amp;data);//删除链表元素 printList(l); s = cloneList(l);//复制l链表 printList(s); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构--链表（单链表）]]></title>
    <url>%2F2019%2F09%2F26%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E9%93%BE%E8%A1%A8%EF%BC%88%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据结构–链表（单链表）从今天开始，工作室统一开始复习算法，明年蓝桥杯都进国赛哈哈哈。去年蓝桥杯的国赛还是有些遗憾，今年一定要好好学学，拿个国二。 链表是数据结构中最基础的存储结构。相比于数组，他是动态的，不论从存储内容还是存储长度来说都是动态的。可以借此延伸出其他很多数据结构。 对以下程序的变量说明：Node 结构体变量，一般用来定义节点；LinkList结构体指针，一般用来定义头节点；l一般用来指向头结点，引导整个链表；s，r一般用于操作过程中用来移动的指针。 1. 链表基本结构体的定义：123456//定义结构体typedef struct Node&#123; int data; struct Node * next;&#125;Node, *LinkList;//一个结构体类型的Node，一个指向结构体类型的指针变量 LinkList~ 其中定义两个变量，一个结构体类型的Node，一个指向结构体类型的指针变量 LinkList,在后续的算法中，这两者作用基本相同，LinkList用来申明头指针，Node * 用来申明节点指针，方便区分。 2. 链表初始化1234567//初始化InitList(LinkList * l)&#123; //分配头结点 *l = (LinkList)malloc(sizeof(Node)); (*l)-&gt;next = NULL; //让头节点next域为空&#125; 初始化链表的操作使用了二重指针，应为要头结点l是在主函数申明好的，在初始化函数中要改变指针的值，就需要二重指针，用LinkList * 申明。 3. 头插法建立新链表123456789101112131415161718192021222324//头插法建表，依次输入想要插入的值，以-1结束void CreatFormHead(LinkList l)&#123; Node * s; int c; int flag = 1; while (flag)//循环标记 &#123; scanf("%d", &amp;c); if (c != -1) &#123; //建立一个新节点 s = (Node*)malloc(sizeof(Node)); //修改指针 s-&gt;data = c; s-&gt;next = l-&gt;next; l-&gt;next = s; &#125; else &#123; flag = 0; &#125; &#125;&#125; 此方法在建立链表时，始终从头结点后面插入新的节点，所以插入以后可以将输入逆序。修改指针顺序为先修改新增节点的指针指向头结点的下一个节点，再让头结点指向新增节点。 4.尾插法建立新链表12345678910111213141516171819202122232425//尾插法建表,与头插法类似，不过此方法建表为正序void CreatFormTail(LinkList l)&#123; Node * s; //尾插需要有一个移动的指针，为了不丢失头结点则新定义一个指针r Node * r = l; int c; int flag = 1; while (flag) &#123; scanf("%d", &amp;c); if (c != -1) &#123; s = (Node*)malloc(sizeof(Node)); s-&gt;data = c; r-&gt;next = s; r = r-&gt;next; &#125; else &#123; flag = 0; &#125; r-&gt;next = NULL; &#125;&#125; 此方法建立新链表时，是从链表节点的尾部新增节点，所以插入的顺序是正序。应为要保留头结点，所以尾插法还需借用一个行的指针变量r为移动的指针。 5.查找操作5.1 按照元素值key查找123456789101112131415161718192021222324252627282930//按数值key查找节点，将查找到的节点返回Node * locate(LinkList l, int key)&#123; //定义一个可以移动的指针 Node * r = l; while (r-&gt;data != key) &#123; r = r-&gt;next; if (r == NULL) &#123; //key值不存在链表中 printf("查找不到相应值"); return NULL; &#125; &#125; return r;&#125;Node * locate(LinkList l, int key)&#123; Node * r = l; while (r-&gt;data != key) &#123; r = r-&gt;next; if (r == NULL) &#123; printf("查找不到相应值"); return NULL; &#125; &#125; return r;&#125; 5.1 按照顺序查找第i个12345678910111213141516171819202122232425//按序号i(第i个)查找，将查找到的节点返回Node * getNode(LinkList l, int i)&#123; Node * r = l; int j = 0; if (i &lt;= 0) &#123; //查找位置小于1 printf("查找序号不合法"); return NULL; &#125; while (r != NULL || j &lt;= i) &#123; r = r-&gt;next; j++; &#125; if (r == NULL) &#123; //查找位置大于链表长度 printf("查找值不合理"); return NULL; &#125; else return r;&#125; 查找操作时要注意查找位置是否合法，则要进行多次判断 6.删除节点删除第i个元素，并将该元素内容存入 data中 123456789101112131415161718192021222324252627282930//删除第i个元素，并将该元素内容存入data中void DeleteList(LinkList l, int i, int * data)&#123; Node * r = l; Node * p = l; int j = 0; if (i &lt;= 0) &#123; //删除位置小于1 printf("查找序号不合法"); return NULL; &#125; //寻找删除位置 while (p != NULL &amp;&amp; j &lt; i - 1) &#123; p = p-&gt;next; j++; &#125; if (p == NULL) &#123; //删除位置大于链表长度 printf("查找序号不合法"); return NULL; &#125; //修改指针删除 r = p-&gt;next; p-&gt;next = r-&gt;next; data = &amp;(r-&gt;data); free(r);&#125; 删除操作时，先按照查找操作找到相应位置，再移动指针，删除以后要将空间free掉。值得注意的是次过程需要两个指针，一个（p指针）指向待删除节点前的节点，另一个（r)指针指向待删除元素。 7. 在链表第i个元素前插入一个元素123456789101112131415161718192021222324252627282930//在单链表l的第i个元素前插入一个节点void lnslist(LinkList l, int i, int idata)&#123; Node * pre, *s; int j = 0; pre = l; //首先判断插入位置是否合法 if (i &lt;= 0) &#123; //插入位置小于1 printf("查找序号不合法"); return NULL; &#125; //寻找插入位置 while ((pre != NULL) &amp;&amp; (j&lt;i - 1)) &#123; pre = pre-&gt;next; j++; &#125; if (pre == NULL) &#123; //插入位置大于链表长度 printf("查找序号不合法"); return NULL; &#125; s = (Node *)malloc(sizeof(Node)); s-&gt;data = idata; s-&gt;next = pre-&gt;next; pre-&gt;next = s;&#125; 此操作是将查找与头插法相结合的应用。 8.计算链表长度并输出123456789101112131415161718192021222324//计算链表长度int listlength(LinkList l)&#123; Node * p; int j = 0; p = l-&gt;next; while (p != NULL) &#123; p = p-&gt;next; j++; &#125; return j;&#125;//链表输出void PrintList(LinkList l)&#123; Node * r = l-&gt;next; while (r-&gt;next != NULL) &#123; printf("%d ", r-&gt;data); r = r-&gt;next; &#125; printf("%d", r-&gt;data);&#125; 9.链表合并9.1将两个增有序的链表合成一个减有序的链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//链表合并,将两个增有序的链表合成一个减有序的链表LinkList MergeList(LinkList l1, LinkList l2)&#123; Node * s; Node * temp; //首先用其中一个链表头结点作为新链表头结点 s = l1; l1 = l1-&gt;next; s-&gt;next = NULL; //定义一个临时节点，以便头插法建表时移动链表 temp = l2; l2 = l2-&gt;next; free(temp); //l1，l2都指向待比较的节点 while (l1 != NULL &amp;&amp; l2 != NULL) &#123; //选择两者中小的进行插入 if (l1-&gt;data &lt;= l2-&gt;data)&#123; //要先保留l1指针并移动，然后再修改指针 temp = l1; l1 = l1-&gt;next; temp-&gt;next = s-&gt;next; s-&gt;next = temp; &#125; else &#123; temp = l2; l2 = l2-&gt;next; temp-&gt;next = s-&gt;next; s-&gt;next = temp; &#125; &#125; //当一个链表插入结束后，将另一个链表继续使用头插法逐一插入， //以保证建表顺序 if (l1 == NULL) &#123; while (l2 != NULL) &#123; temp = l2; l2 = l2-&gt;next; temp-&gt;next = s-&gt;next; s-&gt;next = temp; &#125; &#125; else &#123; while (l1 != NULL) &#123; temp = l1; l1 = l1-&gt;next; temp-&gt;next = s-&gt;next; s-&gt;next = temp; &#125; &#125; return s;&#125; 此过程中，值得注意的就是（1）在合并过程中，应为一开始将头结点指向了空，且在合并指针变化过程中会使当前节点指针域改变，所以要先有一个temp指针为当前节点修改，l1指针直接指向下一个节点。（2）还有一点就是合并过程中，当一个链表先结束时，另一个链表也要继续头插法插入不能直接插在后面。 9.2 将两个增有序的链表合成一个增有序的链表1234567891011121314151617181920212223242526272829303132333435//将两个增有序的链表合成一个增有序的链表LinkList mergelinklist(LinkList la, LinkList lb)&#123; Node * r, *p, *s; LinkList lc; //与上一个插入类似，先建立头结点 r = la-&gt;next; p = lb-&gt;next; lc = la; lc-&gt;next = NULL; s = lc; while (r-&gt;next != NULL || p-&gt;next != NULL) &#123; //应为是尾插，本来就有移动临时节点，所以和标准尾插一样 if (r-&gt;data &lt;= p-&gt;data) &#123; s-&gt;next = r; s = r; r = r-&gt;next; &#125; else &#123; s-&gt;next = p; s = p; p = p-&gt;next; &#125; &#125; //一方插入结束后，应为用尾插法，所以可以将另一方直接接到新节点后面 if (r-&gt;next != NULL) s-&gt;next = r; else s-&gt;next = p; free(lb); return(lc);&#125; 10.主函数123456789101112131415161718192021222324252627282930int main(void)&#123; LinkList l1; LinkList l2; LinkList s; int data = 0; InitList(&amp;l1); InitList(&amp;l2); printf("请输入第一个链表"); CreatFormTail(l1);//尾插法建表1 PrintList(l1); printf("请输入第二个链表"); CreatFormHead(l2);//头差法建表2 PrintList(l2); printf("\n"); lnslist(l1, 2, 5);//在l1链表第2个位置插入5 PrintList(l1); printf("\n"); DeleteList(l2, 2, &amp;data);//删除元素 printf("%d", data);//输出删除元素 printf("\n"); PrintList(l2); printf("\n"); s = locate(l2, 3);//查找值为3的节点 printf("%d",s-&gt;data); printf("\n"); s = MergeList(l1, l2);//两链表合并 PrintList(s); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-动态规划]]></title>
    <url>%2F2019%2F09%2F25%2F%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[算法篇——动态规划在我看来，动态规划是一种思想，一种解决问题的手段。总的来说就是找到基于当前状态的最优决策。一般通过递归来实现，但与递归不同的，递归有些问题被反复计算多次，但动态规划对每个子问题只计算一次，然后将其保存起来，以后在遇到同样的问题就直接引用，不必直接求解。其重点就是保存以前的状态，通过以前状态推得现有最优态。 例: 数字三角形73 88 1 02 7 4 44 5 2 6 5在上面的数字三角形中寻找一条从顶部到底边的路径，使得路径上所经过的数字之和最大。路径上的每一步都只能往左下或 右下走。只需要求出这个最大和即可，不必给出具体路径。 1. 纯递归解法 单纯用递归很简答就能解决这个问题只用用一个数组 d(i,j)来存储这个数字三角形，用max(i,j)表示从d(i,j)到底边各条路径中最佳数字之和。从d(i,j)出发，下一步只能走d(r+1,j)或者d(r+1,j+1)代码如下 123456789101112131415161718192021222324252627import java.util.Scanner;public class triangle &#123; static int[][] a = new int[100][100]; static int n; public static void main(String[] arge)&#123; Scanner input = new Scanner(System.in); n = input.nextInt(); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; a[i][j] = input.nextInt(); &#125; &#125; System.out.println(sum(0,0)); &#125; static int sum(int i, int j)&#123; int m; if(i == n)&#123; return a[i][j]; &#125; else &#123; int x = sum(i + 1, j); int y = sum(i + 1, j + 1); m = x&gt;y?x:y; return m + a[i][j]; &#125; &#125;&#125; 2. 用记忆递归型的动态规划 如果用上面的单纯递归，一旦数据稍微过大，则会运行超时。应为其中出现了大量的重复计算。此时就需要用到递归的第一个思路，保存每次的值，则可以避免过多的重复。则在每次算出MaxSum值的时候将其保存起来则可以免去重复计算。 1234567891011121314151617181920212223242526272829public class triangle1 &#123; static int[][] a = new int[100][100]; static int n; static int[][] max = new int[100][100]; public static void main(String[] arge)&#123; Scanner input = new Scanner(System.in); n = input.nextInt(); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; a[i][j] = input.nextInt(); max[i][j] = -1; &#125; &#125; System.out.println(sum(0,0)); &#125; static int sum(int i, int j)&#123; if (max[i][j] != -1) return max[i][j]; if(i == n)&#123; return a[i][j]; &#125; else &#123; int x = sum(i + 1, j); int y = sum(i + 1, j + 1); max[i][j] = (x&gt;y?x:y) + a[i][j]; &#125; return max[i][j]; &#125;&#125; 3.递推类型动态规划 上面的方法，虽然可以有效的降低实践复杂度，但是其递归调用要占用大量的堆栈空间，容易早场栈溢出，所以就需要把递归思想转变为递推思想。从最后开始，如下表，倒数第二行的2可以和最后一行的4,5相加，但是和5相加较大，则将7保存下来，以此类推。 30 23 21 20 13 10 7 12 10 10 4 5 2 6 5 12345678910111213141516171819202122public class triangle2 &#123; static int[][] a = new int[100][100]; static int n; static int[][] max = new int[100][100]; public static void main(String[] arge)&#123; Scanner input = new Scanner(System.in); n = input.nextInt(); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; a[i][j] = input.nextInt(); &#125; &#125; for (int i = n-2; i &gt;= 0; i--) &#123; for (int j = 0; j &lt;= i; j++) &#123; int x = a[i+1][j+1] + a[i][j]; int y = a[i+1][j] + a[i][j]; a[i][j] = x&gt;y?x:y; &#125; &#125; System.out.println(a[0][0]); &#125;&#125; 则不难总结出递归到动态规划的一般转化方法：构造一个数组，数组元素的值是递归函数返回值，数组下标值是递归函数参数。从边界开始填充数组。 总结：动态规划的一般解题思路 将原问题分解为若干小问题，将子问题求出后保存，每个子问题只求解一次 保存状态，一般通过一个数组作为状态空间 确定初始状态 确定状态转移方程例如数字三角形12MaxSum[i][j] = a[i][j] (i=n)MaxSum[i][j] = max(MaxSum[i+1][j] + MaxSum[i+1][j+1]) (i!=n)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客搭建]]></title>
    <url>%2F2019%2F09%2F19%2Fhexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[hexo博客搭建一、博客基本操作 博客部署到本地 hexo clean 清楚缓存hexo g 生成静态网页hexo s 本地启动预览查看 http://localhost:4000 部署到git服务器上 hexo deploy https://foreverxwwl.github.io/ next主题安装 git clone https://github.com/iissnan/hexo-theme-next themes/next 进入配置文件_config.yml 找到 theme 设置为 theme: next 二、next主题设置 增加标签页等页面 进入next主题的配置文件 _config.yml 找到menu: 将要添加的页面注释删掉 在blog页面 hexo n page tags 增加标签tags页面 hexo n page categories 增加分类categories页面 修改头像姓名等信息 主要参考文档在主题的_config文件中修改 头像 avatar: 修改地址主题 scheme: 设置大的标题、姓名在全局的_config.yml中的 title: 新建一篇博客 hexo n hexo博客搭建 用markdowm编写博客 启用功能 （1）启用侧边栏社交链接 进入主题的_config.yml文件 将social: 一栏的注释取消 （2）启用打赏功能 进入主题的_config.yml文件 将reward项目注释删除 comment：加上用语 也可在后面添加图片 （3）设置头像样式 进入目录 \blog\themes\next\source\css_common\components\sidebar 修改sidebar-author.styl文件中的样式 12345678910111213&gt; &gt; .site-author-image &#123;&gt; &gt; display: block;&gt; &gt; margin: 0 auto;&gt; &gt; padding: $site-author-image-padding;&gt; &gt; max-width: $site-author-image-width;&gt; &gt; height: $site-author-image-height;&gt; &gt; border: $site-author-image-border-width solid $site-author-image-border-color;&gt; &gt; border-radius: 50%;&gt; &gt; transition: 3s all;&gt; &gt; &#125;&gt; &gt; .site-author-image:hover&#123;&gt; &gt; transform: rotate(360deg);&gt; &gt; &#125; （3）设置首页阅读全文 在主题配置文件中找到auto_excerpt:选项 将false 改为true 并设置可看长度 也可在博客编辑时在相应位置添加;此代码以下的点击查看 （4）添加动态背景 在主题配置文件找到canvas 默认都是关闭的 将需要的设置为true （5）修改文章内链接样式 进入F:\blog\themes\next\source\css_common\components\post\post.sty 在尾部添加样式 123456789.post-body p a&#123; color: #345; border-bottom: none; font-size: 13px;/*字体大小*/ font-weight: 500; /*字体粗细*/ &amp;:hover&#123; color: #fcfcfc; &#125;&#125; （6）修改文章底部标签 进入F:\blog\themes\next\layout_macro\post.swig 修改 tag.path 可将这行的 # 替换成别的 1&lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt; &lt;i class="fa fa-tag"&gt;&lt;/i&gt; （7）Valine评论系统 进入主题配置文件 打开 valine https://leancloud.cn/ 网站配置appid并在配置文件中使用 （8）搜索，统计功能 都是进入next主题官网 开启第三方服务 三、一个小问题 再部署的时候 提示 ERROR Deployer not found: git按照晚上提示安装插件总是报错 npm install hexo-deployer-git –save然后用淘宝NPM镜像的“hexo-deployer-git”试了一下，成功了指令：$ cnpm install hexo-deployer-git –save]]></content>
      <categories>
        <category>基础知识学习</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github学习]]></title>
    <url>%2F2019%2F09%2F19%2Fgithub%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[github基本操作 初始化 git init 状态查看 git status 添加到暂存区 git add 提交到本地库 git commit -m 查看历史 git log / git –online / git reflog 版本前进或后退 git reset –hard &lt;索引值&gt; / git reset –hard HEAD~2 比较工作区与暂存区文件差异 git diff [文件名] 将工作区与本地库文件比较 git diff [本地库历史版本（HEAD）] [文件名] 分支管理 创建分支 git branch [分支名] 查看分支 git branch -v 切换分支 git checkout [分支名] 合并分支 git merge [分支名] 解决冲突 git add git commit -m 远程库操作 创建远程库地址别名 git remote add [远程库地址]git remote add origin git@github.com:xiasf/github-note.git 查看别名 git remote -v 推送 git push [远程库地址名] [分支名] 克隆 git clone [远程库地址名] 拉取 git pull [远程库地址名] [远程库分支] 抓取 git fetch [远程库地址名] [远程库分支] 合并 git merge [远程库地址名/远程库分支] 跨团队合作 团队2进入团队1项目目录,点击fork。 团队2 git clone &lt;远程地址&gt;，修改并commit，git push 提交到远程库。 团队2进入页面，点击 pull requests、 new pull requests， Create pull requests 然后发消息给团队1。 团队1点击pull requests，Commits 、files changed 代码审核。 如果没有问题 则点击 merge pull request 并添加-m信息，结束远程库修改。 团队1将远程库拉取到本地 git pull origin master。]]></content>
      <categories>
        <category>基础知识学习</category>
      </categories>
      <tags>
        <tag>git学习</tag>
      </tags>
  </entry>
</search>
