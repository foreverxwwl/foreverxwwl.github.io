<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[算法-动态规划]]></title>
    <url>%2F2019%2F09%2F25%2F%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[算法篇——动态规划在我看来，动态规划是一种思想，一种解决问题的手段。总的来说就是找到基于当前状态的最优决策。一般通过递归来实现，但与递归不同的，递归有些问题被反复计算多次，但动态规划对每个子问题只计算一次，然后将其保存起来，以后在遇到同样的问题就直接引用，不必直接求解。其重点就是保存以前的状态，通过以前状态推得现有最优态。 例: 数字三角形73 88 1 02 7 4 44 5 2 6 5在上面的数字三角形中寻找一条从顶部到底边的路径，使得路径上所经过的数字之和最大。路径上的每一步都只能往左下或 右下走。只需要求出这个最大和即可，不必给出具体路径。 1. 纯递归解法 单纯用递归很简答就能解决这个问题只用用一个数组 d(i,j)来存储这个数字三角形，用max(i,j)表示从d(i,j)到底边各条路径中最佳数字之和。从d(i,j)出发，下一步只能走d(r+1,j)或者d(r+1,j+1)代码如下 123456789101112131415161718192021222324252627import java.util.Scanner;public class triangle &#123; static int[][] a = new int[100][100]; static int n; public static void main(String[] arge)&#123; Scanner input = new Scanner(System.in); n = input.nextInt(); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; a[i][j] = input.nextInt(); &#125; &#125; System.out.println(sum(0,0)); &#125; static int sum(int i, int j)&#123; int m; if(i == n)&#123; return a[i][j]; &#125; else &#123; int x = sum(i + 1, j); int y = sum(i + 1, j + 1); m = x&gt;y?x:y; return m + a[i][j]; &#125; &#125;&#125; 2. 用记忆递归型的动态规划 如果用上面的单纯递归，一旦数据稍微过大，则会运行超时。应为其中出现了大量的重复计算。此时就需要用到递归的第一个思路，保存每次的值，则可以避免过多的重复。则在每次算出MaxSum值的时候将其保存起来则可以免去重复计算。 1234567891011121314151617181920212223242526272829public class triangle1 &#123; static int[][] a = new int[100][100]; static int n; static int[][] max = new int[100][100]; public static void main(String[] arge)&#123; Scanner input = new Scanner(System.in); n = input.nextInt(); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; a[i][j] = input.nextInt(); max[i][j] = -1; &#125; &#125; System.out.println(sum(0,0)); &#125; static int sum(int i, int j)&#123; if (max[i][j] != -1) return max[i][j]; if(i == n)&#123; return a[i][j]; &#125; else &#123; int x = sum(i + 1, j); int y = sum(i + 1, j + 1); max[i][j] = (x&gt;y?x:y) + a[i][j]; &#125; return max[i][j]; &#125;&#125; 3.递推类型动态规划 上面的方法，虽然可以有效的降低实践复杂度，但是其递归调用要占用大量的堆栈空间，容易早场栈溢出，所以就需要把递归思想转变为递推思想。从最后开始，如下表，倒数第二行的2可以和最后一行的4,5相加，但是和5相加较大，则将7保存下来，以此类推。 30 23 21 20 13 10 7 12 10 10 4 5 2 6 5 12345678910111213141516171819202122public class triangle2 &#123; static int[][] a = new int[100][100]; static int n; static int[][] max = new int[100][100]; public static void main(String[] arge)&#123; Scanner input = new Scanner(System.in); n = input.nextInt(); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; a[i][j] = input.nextInt(); &#125; &#125; for (int i = n-2; i &gt;= 0; i--) &#123; for (int j = 0; j &lt;= i; j++) &#123; int x = a[i+1][j+1] + a[i][j]; int y = a[i+1][j] + a[i][j]; a[i][j] = x&gt;y?x:y; &#125; &#125; System.out.println(a[0][0]); &#125;&#125; 则不难总结出递归到动态规划的一般转化方法：构造一个数组，数组元素的值是递归函数返回值，数组下标值是递归函数参数。从边界开始填充数组。 总结：动态规划的一般解题思路 将原问题分解为若干小问题，将子问题求出后保存，每个子问题只求解一次 保存状态，一般通过一个数组作为状态空间 确定初始状态 确定状态转移方程例如数字三角形12MaxSum[i][j] = a[i][j] (i=n)MaxSum[i][j] = max(MaxSum[i+1][j] + MaxSum[i+1][j+1]) (i!=n)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表复习]]></title>
    <url>%2F2019%2F09%2F24%2F%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0%EF%BC%88%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据结构–链表（单链表）从今天开始，工作室统一开始复习算法，明年蓝桥杯都进国赛哈哈哈。去年蓝桥杯的国赛还是有些遗憾，今年一定要好好学学，拿个国二。 链表是数据结构中最基础的存储结构。相比于数组，他是动态的，不论从存储内容还是存储长度来说都是动态的。可以借此延伸出其他很多数据结构。 对以下程序的变量说明：Node 结构体变量，一般用来定义节点；LinkList结构体指针，一般用来定义头节点；l一般用来指向头结点，引导整个链表；s，r一般用于操作过程中用来移动的指针。 1. 链表基本结构体的定义：123456//定义结构体typedef struct Node&#123; int data; struct Node * next;&#125;Node, *LinkList;//一个结构体类型的Node，一个指向结构体类型的指针变量 LinkList~ 其中定义两个变量，一个结构体类型的Node，一个指向结构体类型的指针变量 LinkList,在后续的算法中，这两者作用基本相同，LinkList用来申明头指针，Node * 用来申明节点指针，方便区分。 2. 链表初始化1234567//初始化InitList(LinkList * l)&#123; //分配头结点 *l = (LinkList)malloc(sizeof(Node)); (*l)-&gt;next = NULL; //让头节点next域为空&#125; 初始化链表的操作使用了二重指针，应为要头结点l是在主函数申明好的，在初始化函数中要改变指针的值，就需要二重指针，用LinkList * 申明。 3. 头插法建立新链表123456789101112131415161718192021222324//头插法建表，依次输入想要插入的值，以-1结束void CreatFormHead(LinkList l)&#123; Node * s; int c; int flag = 1; while (flag)//循环标记 &#123; scanf("%d", &amp;c); if (c != -1) &#123; //建立一个新节点 s = (Node*)malloc(sizeof(Node)); //修改指针 s-&gt;data = c; s-&gt;next = l-&gt;next; l-&gt;next = s; &#125; else &#123; flag = 0; &#125; &#125;&#125; 此方法在建立链表时，始终从头结点后面插入新的节点，所以插入以后可以将输入逆序。修改指针顺序为先修改新增节点的指针指向头结点的下一个节点，再让头结点指向新增节点。 4.尾插法建立新链表12345678910111213141516171819202122232425//尾插法建表,与头插法类似，不过此方法建表为正序void CreatFormTail(LinkList l)&#123; Node * s; //尾插需要有一个移动的指针，为了不丢失头结点则新定义一个指针r Node * r = l; int c; int flag = 1; while (flag) &#123; scanf("%d", &amp;c); if (c != -1) &#123; s = (Node*)malloc(sizeof(Node)); s-&gt;data = c; r-&gt;next = s; r = r-&gt;next; &#125; else &#123; flag = 0; &#125; r-&gt;next = NULL; &#125;&#125; 此方法建立新链表时，是从链表节点的尾部新增节点，所以插入的顺序是正序。应为要保留头结点，所以尾插法还需借用一个行的指针变量r为移动的指针。 5.查找操作5.1 按照元素值key查找123456789101112131415161718192021222324252627282930//按数值key查找节点，将查找到的节点返回Node * locate(LinkList l, int key)&#123; //定义一个可以移动的指针 Node * r = l; while (r-&gt;data != key) &#123; r = r-&gt;next; if (r == NULL) &#123; //key值不存在链表中 printf("查找不到相应值"); return NULL; &#125; &#125; return r;&#125;Node * locate(LinkList l, int key)&#123; Node * r = l; while (r-&gt;data != key) &#123; r = r-&gt;next; if (r == NULL) &#123; printf("查找不到相应值"); return NULL; &#125; &#125; return r;&#125; 5.1 按照顺序查找第i个12345678910111213141516171819202122232425//按序号i(第i个)查找，将查找到的节点返回Node * getNode(LinkList l, int i)&#123; Node * r = l; int j = 0; if (i &lt;= 0) &#123; //查找位置小于1 printf("查找序号不合法"); return NULL; &#125; while (r != NULL || j &lt;= i) &#123; r = r-&gt;next; j++; &#125; if (r == NULL) &#123; //查找位置大于链表长度 printf("查找值不合理"); return NULL; &#125; else return r;&#125; 查找操作时要注意查找位置是否合法，则要进行多次判断 6.删除节点删除第i个元素，并将该元素内容存入 data中 123456789101112131415161718192021222324252627282930//删除第i个元素，并将该元素内容存入data中void DeleteList(LinkList l, int i, int * data)&#123; Node * r = l; Node * p = l; int j = 0; if (i &lt;= 0) &#123; //删除位置小于1 printf("查找序号不合法"); return NULL; &#125; //寻找删除位置 while (p != NULL &amp;&amp; j &lt; i - 1) &#123; p = p-&gt;next; j++; &#125; if (p == NULL) &#123; //删除位置大于链表长度 printf("查找序号不合法"); return NULL; &#125; //修改指针删除 r = p-&gt;next; p-&gt;next = r-&gt;next; data = &amp;(r-&gt;data); free(r);&#125; 删除操作时，先按照查找操作找到相应位置，再移动指针，删除以后要将空间free掉。值得注意的是次过程需要两个指针，一个（p指针）指向待删除节点前的节点，另一个（r)指针指向待删除元素。 7. 在链表第i个元素前插入一个元素123456789101112131415161718192021222324252627282930//在单链表l的第i个元素前插入一个节点void lnslist(LinkList l, int i, int idata)&#123; Node * pre, *s; int j = 0; pre = l; //首先判断插入位置是否合法 if (i &lt;= 0) &#123; //插入位置小于1 printf("查找序号不合法"); return NULL; &#125; //寻找插入位置 while ((pre != NULL) &amp;&amp; (j&lt;i - 1)) &#123; pre = pre-&gt;next; j++; &#125; if (pre == NULL) &#123; //插入位置大于链表长度 printf("查找序号不合法"); return NULL; &#125; s = (Node *)malloc(sizeof(Node)); s-&gt;data = idata; s-&gt;next = pre-&gt;next; pre-&gt;next = s;&#125; 此操作是将查找与头插法相结合的应用。 8.计算链表长度并输出123456789101112131415161718192021222324//计算链表长度int listlength(LinkList l)&#123; Node * p; int j = 0; p = l-&gt;next; while (p != NULL) &#123; p = p-&gt;next; j++; &#125; return j;&#125;//链表输出void PrintList(LinkList l)&#123; Node * r = l-&gt;next; while (r-&gt;next != NULL) &#123; printf("%d ", r-&gt;data); r = r-&gt;next; &#125; printf("%d", r-&gt;data);&#125; 9.链表合并9.1将两个增有序的链表合成一个减有序的链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//链表合并,将两个增有序的链表合成一个减有序的链表LinkList MergeList(LinkList l1, LinkList l2)&#123; Node * s; Node * temp; //首先用其中一个链表头结点作为新链表头结点 s = l1; l1 = l1-&gt;next; s-&gt;next = NULL; //定义一个临时节点，以便头插法建表时移动链表 temp = l2; l2 = l2-&gt;next; free(temp); //l1，l2都指向待比较的节点 while (l1 != NULL &amp;&amp; l2 != NULL) &#123; //选择两者中小的进行插入 if (l1-&gt;data &lt;= l2-&gt;data)&#123; //要先保留l1指针并移动，然后再修改指针 temp = l1; l1 = l1-&gt;next; temp-&gt;next = s-&gt;next; s-&gt;next = temp; &#125; else &#123; temp = l2; l2 = l2-&gt;next; temp-&gt;next = s-&gt;next; s-&gt;next = temp; &#125; &#125; //当一个链表插入结束后，将另一个链表继续使用头插法逐一插入， //以保证建表顺序 if (l1 == NULL) &#123; while (l2 != NULL) &#123; temp = l2; l2 = l2-&gt;next; temp-&gt;next = s-&gt;next; s-&gt;next = temp; &#125; &#125; else &#123; while (l1 != NULL) &#123; temp = l1; l1 = l1-&gt;next; temp-&gt;next = s-&gt;next; s-&gt;next = temp; &#125; &#125; return s;&#125; 此过程中，值得注意的就是（1）在合并过程中，应为一开始将头结点指向了空，且在合并指针变化过程中会使当前节点指针域改变，所以要先有一个temp指针为当前节点修改，l1指针直接指向下一个节点。（2）还有一点就是合并过程中，当一个链表先结束时，另一个链表也要继续头插法插入不能直接插在后面。 9.2 将两个增有序的链表合成一个增有序的链表1234567891011121314151617181920212223242526272829303132333435//将两个增有序的链表合成一个增有序的链表LinkList mergelinklist(LinkList la, LinkList lb)&#123; Node * r, *p, *s; LinkList lc; //与上一个插入类似，先建立头结点 r = la-&gt;next; p = lb-&gt;next; lc = la; lc-&gt;next = NULL; s = lc; while (r-&gt;next != NULL || p-&gt;next != NULL) &#123; //应为是尾插，本来就有移动临时节点，所以和标准尾插一样 if (r-&gt;data &lt;= p-&gt;data) &#123; s-&gt;next = r; s = r; r = r-&gt;next; &#125; else &#123; s-&gt;next = p; s = p; p = p-&gt;next; &#125; &#125; //一方插入结束后，应为用尾插法，所以可以将另一方直接接到新节点后面 if (r-&gt;next != NULL) s-&gt;next = r; else s-&gt;next = p; free(lb); return(lc);&#125; 10.主函数123456789int main(void)&#123; LinkList l1; InitList(&amp;l1); printf("请输入第一个链表"); CreatFormTail(l1); PrintList(s); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客搭建]]></title>
    <url>%2F2019%2F09%2F19%2Fhexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[hexo博客搭建一、博客基本操作 博客部署到本地 hexo clean 清楚缓存hexo g 生成静态网页hexo s 本地启动预览查看 http://localhost:4000 部署到git服务器上 hexo deploy https://foreverxwwl.github.io/ next主题安装 git clone https://github.com/iissnan/hexo-theme-next themes/next 进入配置文件_config.yml 找到 theme 设置为 theme: next 二、next主题设置 增加标签页等页面 进入next主题的配置文件 _config.yml 找到menu: 将要添加的页面注释删掉 在blog页面 hexo n page tags 增加标签tags页面 hexo n page categories 增加分类categories页面 修改头像姓名等信息 主要参考文档在主题的_config文件中修改 头像 avatar: 修改地址主题 scheme: 设置大的标题、姓名在全局的_config.yml中的 title: 新建一篇博客 hexo n hexo博客搭建 用markdowm编写博客 启用功能 （1）启用侧边栏社交链接 进入主题的_config.yml文件 将social: 一栏的注释取消 （2）启用打赏功能 进入主题的_config.yml文件 将reward项目注释删除 comment：加上用语 也可在后面添加图片 （3）设置头像样式 进入目录 \blog\themes\next\source\css_common\components\sidebar 修改sidebar-author.styl文件中的样式 12345678910111213&gt; &gt; .site-author-image &#123;&gt; &gt; display: block;&gt; &gt; margin: 0 auto;&gt; &gt; padding: $site-author-image-padding;&gt; &gt; max-width: $site-author-image-width;&gt; &gt; height: $site-author-image-height;&gt; &gt; border: $site-author-image-border-width solid $site-author-image-border-color;&gt; &gt; border-radius: 50%;&gt; &gt; transition: 3s all;&gt; &gt; &#125;&gt; &gt; .site-author-image:hover&#123;&gt; &gt; transform: rotate(360deg);&gt; &gt; &#125; （3）设置首页阅读全文 在主题配置文件中找到auto_excerpt:选项 将false 改为true 并设置可看长度 也可在博客编辑时在相应位置添加;此代码以下的点击查看 （4）添加动态背景 在主题配置文件找到canvas 默认都是关闭的 将需要的设置为true （5）修改文章内链接样式 进入F:\blog\themes\next\source\css_common\components\post\post.sty 在尾部添加样式 123456789.post-body p a&#123; color: #345; border-bottom: none; font-size: 13px;/*字体大小*/ font-weight: 500; /*字体粗细*/ &amp;:hover&#123; color: #fcfcfc; &#125;&#125; （6）修改文章底部标签 进入F:\blog\themes\next\layout_macro\post.swig 修改 tag.path 可将这行的 # 替换成别的 1&lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt; &lt;i class="fa fa-tag"&gt;&lt;/i&gt; （7）Valine评论系统 进入主题配置文件 打开 valine https://leancloud.cn/ 网站配置appid并在配置文件中使用 （8）搜索，统计功能 都是进入next主题官网 开启第三方服务 三、一个小问题 再部署的时候 提示 ERROR Deployer not found: git按照晚上提示安装插件总是报错 npm install hexo-deployer-git –save然后用淘宝NPM镜像的“hexo-deployer-git”试了一下，成功了指令：$ cnpm install hexo-deployer-git –save]]></content>
      <categories>
        <category>基础知识学习</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github学习]]></title>
    <url>%2F2019%2F09%2F19%2Fgithub%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[github基本操作 初始化 git init 状态查看 git status 添加到暂存区 git add 提交到本地库 git commit -m 查看历史 git log / git –online / git reflog 版本前进或后退 git reset –hard &lt;索引值&gt; / git reset –hard HEAD~2 比较工作区与暂存区文件差异 git diff [文件名] 将工作区与本地库文件比较 git diff [本地库历史版本（HEAD）] [文件名] 分支管理 创建分支 git branch [分支名] 查看分支 git branch -v 切换分支 git checkout [分支名] 合并分支 git merge [分支名] 解决冲突 git add git commit -m 远程库操作 创建远程库地址别名 git remote add [远程库地址] 查看别名 git remote -v 推送 git push [远程库地址名] [分支名] 克隆 git clone [远程库地址名] 拉取 git pull [远程库地址名] [远程库分支] 抓取 git fetch [远程库地址名] [远程库分支] 合并 git merge [远程库地址名/远程库分支] 跨团队合作 团队2进入团队1项目目录,点击fork。 团队2 git clone &lt;远程地址&gt;，修改并commit，git push 提交到远程库。 团队2进入页面，点击 pull requests、 new pull requests， Create pull requests 然后发消息给团队1。 团队1点击pull requests，Commits 、files changed 代码审核。 如果没有问题 则点击 merge pull request 并添加-m信息，结束远程库修改。 团队1将远程库拉取到本地 git pull origin master。]]></content>
      <categories>
        <category>基础知识学习</category>
      </categories>
      <tags>
        <tag>git学习</tag>
      </tags>
  </entry>
</search>
