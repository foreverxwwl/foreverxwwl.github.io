<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[链表复习]]></title>
    <url>%2F2019%2F09%2F24%2F%E9%93%BE%E8%A1%A8%E5%A4%8D%E4%B9%A0%EF%BC%88%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据结构–链表（单链表）从今天开始，工作室统一开始复习算法，明年蓝桥杯都进国赛哈哈哈。去年蓝桥杯的国赛还是有些遗憾，今年一定要好好学学，拿个国二。 链表是数据结构中最基础的存储结构。相比于数组，他是动态的，不论从存储内容还是存储长度来说都是动态的。可以借此延伸出其他很多数据结构。 对以下程序的变量说明：Node 结构体变量，一般用来定义节点；LinkList结构体指针，一般用来定义头节点；l一般用来指向头结点，引导整个链表；s，r一般用于操作过程中用来移动的指针。 1. 链表基本结构体的定义：12345typedef struct Node&#123; int data; struct Node * next;&#125;Node, *LinkList;~ 其中定义两个变量，一个结构体类型的Node，一个指向结构体类型的指针变量 LinkList,在后续的算法中，这两者作用基本相同，LinkList用来申明头指针，Node * 用来申明节点指针，方便区分。 2. 链表初始化12345InitList(LinkList * l)&#123; *l = (LinkList)malloc(sizeof(Node)); (*l)-&gt;next = NULL;&#125; 初始化链表的操作使用了二重指针，应为要头结点l是在主函数申明好的，在初始化函数中要改变指针的值，就需要二重指针，用LinkList * 申明。 3. 头插法建立新链表12345678910111213141516171819void CreatFormHead(LinkList l)&#123; Node * s; int c; int flag = 1; while (flag) &#123; scanf("%d", &amp;c); if (c != -1) &#123; s = (Node*)malloc(sizeof(Node)); s-&gt;data = c; s-&gt;next = l-&gt;next; l-&gt;next = s; &#125; else flag = 0; &#125;&#125; 此方法在建立链表时，始终从头结点后面插入新的节点，所以插入以后可以将输入逆序。修改指针顺序为先修改新增节点的指针指向头结点的下一个节点，再让头结点指向新增节点。 4.尾插法建立新链表1234567891011121314151617181920212223void CreatFormTail(LinkList l)&#123; Node * s; Node * r = l; int c; int flag = 1; while (flag) &#123; scanf("%d", &amp;c); if (c != -1) &#123; s = (Node*)malloc(sizeof(Node)); s-&gt;data = c; r-&gt;next = s; r = r-&gt;next; &#125; else &#123; flag = 0; &#125; r-&gt;next = NULL; &#125;&#125; 此方法建立新链表时，是从链表节点的尾部新增节点，所以插入的顺序是正序。应为要保留头结点，所以尾插法还需借用一个行的指针变量r为移动的指针。 5.查找操作5.1 按照元素值key查找1234567891011121314Node * locate(LinkList l, int key)&#123; Node * r = l; while (r-&gt;data != key) &#123; r = r-&gt;next; if (r == NULL) &#123; printf("查找不到相应值"); return NULL; &#125; &#125; return r;&#125; 5.1 按照顺序查找第i个1234567891011121314151617Node * getNode(LinkList l, int i)&#123; Node * r = l; int j = 0; while (r != NULL || j &lt;= i) &#123; r = r-&gt;next; j++; &#125; if (r == NULL) &#123; printf("查找值不合理"); return NULL; &#125; else return r;&#125; 查找操作时要注意查找位置是否合法，则要进行多次判断 6.删除节点删除第i个元素，并将该元素内容存入 data中 12345678910111213141516171819202122232425void DeleteList(LinkList l, int i, int * data)&#123; Node * r = l; Node * p = l; int j = 0; if (i &lt;= 0) &#123; printf("查找序号不合法"); return NULL; &#125; while (p != NULL &amp;&amp; j &lt; i - 1) &#123; p = p-&gt;next; j++; &#125; if (p == NULL) &#123; printf("查找序号不合法"); return NULL; &#125; r = p-&gt;next; p-&gt;next = r-&gt;next; data = &amp;(r-&gt;data); free(r);&#125; 删除操作时，先按照查找操作找到相应位置，再移动指针，删除以后要将空间free掉。值得注意的是次过程需要两个指针，一个（p指针）指向待删除节点前的节点，另一个（r)指针指向待删除元素。 7. 在链表第i个元素前插入一个元素1234567891011121314151617181920212223242526//在单链表l的第i个元素前插入一个节点void lnslist(LinkList l, int i, int idata)&#123; Node * pre, *s; int j = 0; pre = l; if (i &lt;= 0) &#123; printf("查找序号不合法"); return NULL; &#125; while ((pre != NULL) &amp;&amp; (j&lt;i - 1)) &#123; pre = pre-&gt;next; j++; &#125; if (pre == NULL) &#123; printf("查找序号不合法"); return NULL; &#125; s = (Node *)malloc(sizeof(Node)); s-&gt;data = idata; s-&gt;next = pre-&gt;next; pre-&gt;next = s;&#125; 此操作是将查找与头插法相结合的应用。 8.计算链表长度并输出123456789101112131415161718192021222324//计算链表长度int listlength(LinkList l)&#123; Node * p; int j = 0; p = l-&gt;next; while (p != NULL) &#123; p = p-&gt;next; j++; &#125; return j;&#125;//链表输出void PrintList(LinkList l)&#123; Node * r = l-&gt;next; while (r-&gt;next != NULL) &#123; printf("%d ", r-&gt;data); r = r-&gt;next; &#125; printf("%d", r-&gt;data);&#125; 9.链表合并9.1将两个增有序的链表合成一个减有序的链表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849LinkList MergeList(LinkList l1, LinkList l2)&#123; Node * s; Node * temp; s = l1; l1 = l1-&gt;next; s-&gt;next = NULL; temp = l2; l2 = l2-&gt;next; free(temp); while (l1 != NULL &amp;&amp; l2 != NULL) &#123; if (l1-&gt;data &lt;= l2-&gt;data)&#123; temp = l1; l1 = l1-&gt;next; temp-&gt;next = s-&gt;next; s-&gt;next = temp; &#125; else &#123; temp = l2; l2 = l2-&gt;next; temp-&gt;next = s-&gt;next; s-&gt;next = temp; &#125; &#125; if (l1 == NULL) &#123; while (l2 != NULL) &#123; temp = l2; l2 = l2-&gt;next; temp-&gt;next = s-&gt;next; s-&gt;next = temp; &#125; &#125; else &#123; while (l1 != NULL) &#123; temp = l1; l1 = l1-&gt;next; temp-&gt;next = s-&gt;next; s-&gt;next = temp; &#125; &#125; return s;&#125; 此过程中，值得注意的就是（1）在合并过程中，应为一开始将头结点指向了空，且在合并指针变化过程中会使当前节点指针域改变，所以要先有一个temp指针为当前节点修改，l1指针直接指向下一个节点。（2）还有一点就是合并过程中，当一个链表先结束时，另一个链表也要继续头插法插入不能直接插在后面。 9.2 将两个增有序的链表合成一个增有序的链表12345678910111213141516171819202122232425262728293031LinkList mergelinklist(LinkList la, LinkList lb)&#123; Node * r, *p, *s; LinkList lc; r = la-&gt;next; p = lb-&gt;next; lc = la; lc-&gt;next = NULL; s = lc; while (r-&gt;next != NULL || p-&gt;next != NULL) &#123; if (r-&gt;data &lt;= p-&gt;data) &#123; s-&gt;next = r; s = r; r = r-&gt;next; &#125; else &#123; s-&gt;next = p; s = p; p = p-&gt;next; &#125; &#125; if (r-&gt;next != NULL) s-&gt;next = r; else s-&gt;next = p; free(lb); return(lc);&#125; 10.主函数123456789int main(void)&#123; LinkList l1; InitList(&amp;l1); printf("请输入第一个链表"); CreatFormTail(l1); PrintList(s); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客搭建]]></title>
    <url>%2F2019%2F09%2F19%2Fhexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[hexo博客搭建一、博客基本操作 博客部署到本地 hexo clean 清楚缓存hexo g 生成静态网页hexo s 本地启动预览查看 http://localhost:4000 部署到git服务器上 hexo deploy https://foreverxwwl.github.io/ next主题安装 git clone https://github.com/iissnan/hexo-theme-next themes/next 进入配置文件_config.yml 找到 theme 设置为 theme: next 二、next主题设置 增加标签页等页面 进入next主题的配置文件 _config.yml 找到menu: 将要添加的页面注释删掉 在blog页面 hexo n page tags 增加标签tags页面 hexo n page categories 增加分类categories页面 修改头像姓名等信息 主要参考文档在主题的_config文件中修改 头像 avatar: 修改地址主题 scheme: 设置大的标题、姓名在全局的_config.yml中的 title: 新建一篇博客 hexo n hexo博客搭建 用markdowm编写博客 启用功能 （1）启用侧边栏社交链接 进入主题的_config.yml文件 将social: 一栏的注释取消 （2）启用打赏功能 进入主题的_config.yml文件 将reward项目注释删除 comment：加上用语 也可在后面添加图片 （3）设置头像样式 进入目录 \blog\themes\next\source\css_common\components\sidebar 修改sidebar-author.styl文件中的样式 12345678910111213&gt; &gt; .site-author-image &#123;&gt; &gt; display: block;&gt; &gt; margin: 0 auto;&gt; &gt; padding: $site-author-image-padding;&gt; &gt; max-width: $site-author-image-width;&gt; &gt; height: $site-author-image-height;&gt; &gt; border: $site-author-image-border-width solid $site-author-image-border-color;&gt; &gt; border-radius: 50%;&gt; &gt; transition: 3s all;&gt; &gt; &#125;&gt; &gt; .site-author-image:hover&#123;&gt; &gt; transform: rotate(360deg);&gt; &gt; &#125; （3）设置首页阅读全文 在主题配置文件中找到auto_excerpt:选项 将false 改为true 并设置可看长度 也可在博客编辑时在相应位置添加;此代码以下的点击查看 （4）添加动态背景 在主题配置文件找到canvas 默认都是关闭的 将需要的设置为true （5）修改文章内链接样式 进入F:\blog\themes\next\source\css_common\components\post\post.sty 在尾部添加样式 123456789.post-body p a&#123; color: #345; border-bottom: none; font-size: 13px;/*字体大小*/ font-weight: 500; /*字体粗细*/ &amp;:hover&#123; color: #fcfcfc; &#125;&#125; （6）修改文章底部标签 进入F:\blog\themes\next\layout_macro\post.swig 修改 tag.path 可将这行的 # 替换成别的 1&lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt; &lt;i class="fa fa-tag"&gt;&lt;/i&gt; （7）Valine评论系统 进入主题配置文件 打开 valine https://leancloud.cn/ 网站配置appid并在配置文件中使用 （8）搜索，统计功能 都是进入next主题官网 开启第三方服务 三、一个小问题 再部署的时候 提示 ERROR Deployer not found: git按照晚上提示安装插件总是报错 npm install hexo-deployer-git –save然后用淘宝NPM镜像的“hexo-deployer-git”试了一下，成功了指令：$ cnpm install hexo-deployer-git –save]]></content>
      <categories>
        <category>基础知识学习</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github学习]]></title>
    <url>%2F2019%2F09%2F19%2Fgithub%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[github基本操作 初始化 git init 状态查看 git status 添加到暂存区 git add 提交到本地库 git commit -m 查看历史 git log / git –online / git reflog 版本前进或后退 git reset –hard &lt;索引值&gt; / git reset –hard HEAD~2 比较工作区与暂存区文件差异 git diff [文件名] 将工作区与本地库文件比较 git diff [本地库历史版本（HEAD）] [文件名] 分支管理 创建分支 git branch [分支名] 查看分支 git branch -v 切换分支 git checkout [分支名] 合并分支 git merge [分支名] 解决冲突 git add git commit -m 远程库操作 创建远程库地址别名 git remote add [远程库地址] 查看别名 git remote -v 推送 git push [远程库地址名] [分支名] 克隆 git clone [远程库地址名] 拉取 git pull [远程库地址名] [远程库分支] 抓取 git fetch [远程库地址名] [远程库分支] 合并 git merge [远程库地址名/远程库分支] 跨团队合作 团队2进入团队1项目目录,点击fork。 团队2 git clone &lt;远程地址&gt;，修改并commit，git push 提交到远程库。 团队2进入页面，点击 pull requests、 new pull requests， Create pull requests 然后发消息给团队1。 团队1点击pull requests，Commits 、files changed 代码审核。 如果没有问题 则点击 merge pull request 并添加-m信息，结束远程库修改。 团队1将远程库拉取到本地 git pull origin master。]]></content>
      <categories>
        <category>基础知识学习</category>
      </categories>
      <tags>
        <tag>git学习</tag>
      </tags>
  </entry>
</search>
